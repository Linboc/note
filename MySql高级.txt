
    MySQL是一个关系型数据库，由瑞典MySQL AB公司开发，目前属于Oracle公司

    MySQL支持大数据库，支持5000万条记录的数据仓库，32位系统表文件最大支持4GB，64位系统最大支持表文件为8GB


Linux下的MySQL安装：

	1、上mysql官网找一个linux系统下的mysql server rpm包
	2、用rpm指令安装服务器的rpm包，可以用mysqladmin --version、cat /etc/passwd | grep mysql等指令查询是否安装成功，mysql安装后会自动创建相关用户与分组信息
	3、用service mysql start指令启动mysql服务，可以用ps -ef | grep mysql查看是否启动成功
	4、可以用service mysql stop停止mysql服务，也可以用service mysql restart重启mysql服务

	刚安装的mysql可以通过/usr/bin/mysqladmin -u root password 123456来为root用户设置密码，root是默认初始用户，默认无密码

	设置mysql服务的开机自启动：chkconfig mysql on；可以通过ntsysv查看有哪些服务是自启动的，ntsysv用tab可以选择退出


Linux下MySQL各个目录的作用：

	/var/lib/mysql：数据库文件目录
	/usr/share/mysql：配置文件目录
	/usr/bin：MySQL命令目录
	/etc/init.d/mysql：启停相关脚本


MySQL的中文乱码处理：
	
	需要修改MySQL的默认字符集编码

	查看当前数据库的字符集：SHOW VARIABLES LIKE 'character%';可以看到很多比如数据库、服务器的默认编码都是latin1

	mysql会自动加载/ect/my.cnf这个文件的配置，因此很多时候都是把/usr/share/mysql/my-huge.cnf文件复制一份出来到/ect/my.cnf来当做自定义配置文件；这个文件在Windows系统下就是MySQL安装目录根路径下的my.ini

	通过/ect/my.cnf文件修改MySQL配置，在[client]下增加default-character-set=utf8，在[mysqld]下增加character_set_server=utf8、character_set_client=utf8、collation-server=utf8_general_ci，在[mysql]下增加default-character-set=utf8，然后重启mysql服务来解决中文乱码问题。注意：如果是在修改配置之前创建的库表，由于编码已经确定，因此依然会是乱码，只有新创建的库表才会应用到新配置
	

MySQL的主要配置文件：

	log-bin：MySQL的二进制日志，主从复制
	log-err：MySQL的错误日志，同时里面也包含启停等信息，默认关闭
	log：查询日志，记录MySQL的查询sql语句，如果开启会降低MySQL的整体性能，默认关闭
	数据库：每个数据库都以目录的方式存在，Linux系统下放在/var/lib/mysql，Windows系统下放在MySQL的安装目录下的data目录
	表名.frm：存放表结构
	表名.myd：存放表数据
	表名.myi：存放表索引
	表名.ibd：存放数据与索引文件

	如果存储引擎是myisam，那么就会用myi、myd类型的文件，如果引擎是InnoDB，那么就会用ibd类型的文件，它们的作用都是存储数据和索引


MySQL的逻辑架构：

	第一层：连接层，比如JDBC、ODBC、PHP、.NET等
	    一层半：连接池比如c3p0，客户端有连接池，MySQL也有自己服务器的连接池

	第二层：插件层，比如备份、集群、安全、分布式、语句解析，优化器，缓存缓冲等等

	第三层：引擎层，比如MyISAM、InnoDB、NDB等等。存储引擎主要使用MyISAM和InnoDB，5.5以后默认使用InnoDB，因为它支持行锁和事务

	第四层：存储，文件系统

	只有一层半到第三层是MySQL所直接涉及的

	MySQL是插件式的可拔插结构


存储引擎介绍：

	查看所有存储引擎：show engines，可以看到所有支持或不支持的存储引擎，和它们的简单描述，不支持是没默认安装

	查看当前存储引擎：show variables like '%_engine%'，可以当前和默认的存储引擎

	InnoDB和MyISAM对比：
			MyISAM			InnoDB
	    主外键	不支持			支持
	    事务	不支持			支持
	    行表锁	表锁			行锁(更适合高并发)
	    缓存	只缓存索引，内存占用少	缓存索引和真实数据，因此内存占用更高，性能也更好
	    表占空间	小			大
	    关注点	性能			事务
	    默认按照    是			是


MySQL性能下降原因：

	首先确定是否MySQL的问题，比如执行时间长，等待时间长

	1、查询写的烂
	2、索引失效
	3、关联太多表
	4、服务器参数设置不合理


SQL执行加载顺序：

	原语句：
		SELECT DISTINCT xxx
		FROM xxx
		LEFT JOIN xxx
		ON xxx
		WHERE xxx
		GROUP BY xxx
		HAVING xxx
		ORDER BY xxx
		LIMIT xxx

	MySQL解析后的语句顺序：
		1、FROM xxx
		2、ON xxx
		3、LEFT JOIN xxx
		4、WHERE xxx
		5、GROUP BY xxx
		6、HAVING xxx
		7、SELECT xxx
		8、DISTINCT xxx
		9、ORDER BY xxx
		10、LIMIT xxx

连接：
	其它都是基础的左右内连，仅有一个全连接比较新奇，看下面

	全连接，ORACLE语法：FULL OUTER JOIN，例如：SELECT * FROM t1 FULL OUTER JOIN t2 ON t1.id = t2.id，逻辑是左连加右连，如果左边和右边有匹配的就两个凑一条;如果只有左边就保留左边，右边留Null;如果只有右边就保留右边，左边留Null
	MySQL不支持全连接，解决方案是LEFT JOIN UNION RIGHT JOIN，比如：
	SELECT * FROM t1 LEFT JOIN t2 ON t1.id = t2.t_id 
	UNION		
	SELECT * FROM t1 RIGHT JOIN t2 ON t1.id = t2.t_id
	左连+右连会造成两边能匹配条件的部分出现重复，UNION可以对这部分进行除重，并保留两边无法匹配的部分


索引：

    索引简介：

	索引是一种数据结构，它目的在于提高查询效率，它对查询和排序的效率都有影响

	假如数据经常删除，删除的空间没有重用，索引就会出现碎片（是磁盘碎片还是索引里面的无效数据碎片？），经常增删改的表也不适合建索引，因为数据改动也会导致索引跟着改动，使用索引会使写入成本更高

	唯一索引默认使用B+树结构，除了B+树之外索引还有哈希结构

    索引分类：

	单列索引：一个索引只包含单个列，一个表可以有多个单列索引

	唯一索引：索引的列必须唯一，但允许NULL值，NULL允许存在多个

	复合索引：一个索引包含多个列

	全文索引：

    索引基本语法：

	创建索引：
	    语法1：CREATE [UNIQUE] INDEX index_name ON table_name(field1, field2...)，和语法2作用一样
	    语法2：ALTER table_name ADD [UNIQUE] [INDEX] index_name ON (field1, field2...)，UNIQUE和INDEX同时只用			   其一，分别代表了唯一索引和普通索引
	    语法3：ALTER TABLE table_name ADD PRIMARY KEY (field1, field2...)，添加主键，同时也会添加唯一索引，但		   这个唯一索引不能存在NULL
	    语法4：ALTER TABLE table_name ADD FULLTEXT index_name(field1, field2...)，创建全文索引

	    [UNIQUE]是可选的，如果加上说明是唯一索引
	    一般索引命名是：idx_表名_字段名1_字段名2...

	删除索引：
	    DROP INDEX index_name ON table_name

	查看索引：
	    SHOW INDEX FROM table_name

    索引结构：

	BTree：
	    BTree一般有三层，第一层有两个虚拟数据A、B，还有三个指针，三个指针由左到右分别代表，小于等于的部分，大		于A小于B的部分，大于等于B的部分；然后根据要查找的数据找到相对应的指针，这个指针还是指向第一层一样的数据，	然后通过相同的方式再找到一个指针；这次到了第三层，也就是叶子节点，就是真实数据，只需在这部分数据里找目标数		据就行了；三层的BTree可以表示上百万的数据，并且每次查询只需要三次IO，每层一次

	Hash：

	Full-Text：

	R-Tree：

    适合创建索引的场景：

	1、主键自动建立的唯一索引
	2、频繁作为查询条件的字段
	3、查询中与其他表关联的字段，也就是作为外键的字段
	4、查询中需要排序的字段
	5、查询中统计或者分组的字段
	6、相比于单列索引更倾向于建立组合索引

    不适合创建索引的场景：

	1、频繁更新的字段
	2、WHERE或ON条件里用不到的字段
	3、数据量太少
	4、经常增删改的表，因为MySQL不仅要保存数据，还要更新索引文件
	5、数据大量重复的字段

    建立索引的选择性：
	索引字段中的不同值数量 / 所有索引值数量，结果越接近1就越值得建，比如2000个数据有1999个不同值，那么选择值的    结果就是0.99，这种情况非常值得建立索引


性能分析：

    

























































































