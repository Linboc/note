
分布式事务相关概念：
    事务：一个程序执行单元，用户定义的一组操作，需要满足ACID属性
    本地事务：本地事务由本地资源管理器管理
    分布式事务：事务的操作位于不同的服务器节点
    分支事务：分布式事务中，由本资源管理器管理的本地事务
    全局事务：一次性操作多个资源管理器完成的事务，由一组分支事务组成

分布式事务主要有两种：基于XA协议的强一致性与基于MQ的最终一致性


XA：
    XA是基于二阶段提交协议设计的接口标准，实现了XA规范的资源管理器就可以参与XA全局事务。一般而言应用作为事务管
理器TM(Transaction Manage，TM)，数据库作为资源管理器RM(Resouce Manage，RM)，TM生成全局事务id，控制RM的
提交和回滚
    注：这里的TM是Seata里TM和TC的结合体
    1、TM生成全局事务id
    2、RM执行本地事务，执行完后暂不提交
    3、TM询问每个RM是否准备好，也就是prepare阶段，此时RM会获取锁并执行，只不过未commit，就差临门一脚
    4、一旦有任意一个RM进行回滚，TM就会通知所有RM进行回滚
    5、一旦所有RM都准备完成，TM就会通知所有RM进行提交，TM出现超时，那么RM就会长时间阻塞，不释放资源


3PC：
    三阶段提交，是二阶段提交的改进版

    分为三个阶段：
        1、第一阶段：询问(CanCommit)
        2、第二阶段：锁资源(PreCommit)
        3、第三阶段：提交(DoCommit)

    具体流程：
        1、TM向TC注册全局事务
        2、RM向TC注册分支事务，然后执行
        3、TM通知RC执行完毕
        4、TC询问所有RM是否就绪(CanCommit)，RM响应就绪，否则TC通知全部RM回滚
        5、TC询问所有RM是否准备(PreCommit)，RM响应准备完毕，否则TC通知全部RM回滚
        5、TC向所有RM确认提交(DoCommit)，RM响应准提交完毕，否则TC通知全部RM回滚

    表面上看3PC比2PC多了一个准备阶段，或者说把原prepare阶段一分为二。

    3PC的优势：
        1、二阶段在prepare阶段就把所有锁都占用，并执行完所有的操作，仅剩提交，如果此时rollback就会白白浪费大量资源，而
    3PC多了一个PreComit阶段，这个阶段让分支事务可以不用做那么多事，如果此时失败了损失也没那么大
        2、支持超时策略，在2PC中，如果TC长时间没响应，所有RM都会一直等待。而在3PC中，分为RM和TC两种超时：

            参与者：CanCommit和PreCommit阶段，如果RM长时间收不到响应就会进行rollback，而DoCommit阶段如果依然超时，RM就
          会认为大概率会进行提交，因此直接提交本地事务

            协调者：三个阶段如果出现超时都会进行回滚

        3、2PC会出现数据不一致的情况，比如commit只发送给一个参与者后TC就挂了。而3PC会选举出一个新的TC，然后询问所有的
      参与者的状态，因为commit的前提是所有参与者都PreCommit了，因此一但有任意一个commit他就会通知其它所有参与者commit。
      否则就通知所有参与者rollback。因为它不知道所有参与者的状态，如果有commit它就能确定所有参与者PreCommit完毕，而如果
      没有commit，为了保险一点就只能rollback了
    3PC的劣势：
        1、如果出现网络超时，参与者自动commit，但其实TC想要的是rollback，就会出现数据不一致
        2、3PC步骤更多，导致并发更低


柔性事务的最终一致性：
    该规范主要有3种：TCC、MQ事务消息、本地消息表

    TCC：
        TCC指的是：try、confirm、cancel，也就是尝试、确认、取消，TCC同样有一个事务管理器
        1、TM生成全局事务ID
        2、本地事务执行，这一步只是锁定资源，比如从已配送改为取消中，扣库存改为冻结库存，锁定后直接提交事务
        3、然后事务管理器就会根据是否所有本地事务都锁定成功
        4、如果有任意一个本地资源管理器try失败，事务管理器就会通知所有资源管理器进行cancel，将锁定的资源释放
        5、如果所有本地资源管理器都能锁定成功，那么事务管理器就尝试confirm，也就是通知所有的本地资源管理器将中间
    状态改为完成状态

    MQ事务：
        MQ事务的前提是消息系统支持事务消息，比如RocketMQ
        1、本地事务在提交前发送消息到MQ，此时消息处于未提交状态，消费者无法消费到，这种消息叫半消息
        2、本地事务提交后，会提交MQ上的半消息
        3、如果第二步失败了，MQ后续将会对用户状态进行回查
        4、如果用户确认该事务已提交，MQ就会提交该消息，让其可被消费
        5、如果用户确认该事务已回滚，或者长期无法确认事务的状态，MQ就可以把该消息删除
        6、消费者只要能消费到该消息就代表生产者的事务肯定提交成功了

    本地消息表：
        本地消息表跟MQ事务消息类似，区别在于MQ不支持事务消息时，需要借助本地数据库的事务管理功能


Seata：

    Seata有三个核心组件：
        Transaction Coordinator(TC，事务协调器)：
            维护全局事务和分支事务的状态，驱动全局事务提交或回滚，TC以服务的形式独立部署

        Transaction Manager(TM，事务管理器)：
            定义全局事务的范围，开始事务、提交事务、回滚事务，向TC注册全局事务，管理RM之间的事务传递

        Resource Manager(RM，资源管理器)：
            管理分支事务上的资源，向TC注册分支事务，汇报分支事务状态，驱动分支事务的提交或回滚，向TC注册分支事务，
        分支事务回滚

    关于Seata的疑惑：
        1、如果A服务调用B服务，B服务要返回结果就必须prepare然后commit，但是B服务不返回A服务就无法prepare：
            B服务可以做到prepare不commit，直接返回结果，等收到TC的commit或rollback后再进行，因为事务的提交或回滚
        也是通过AOP进行的，完全可以做到Seata自定义的事务在方法结束后不提交，而是等TC的调用

Seata支持的4种工作模式：

1、
    AT(Auto Transaction，自动事务)：
        AT模式是Seata默认的工作模式，需要基于支持本地ACID事务的关系型数据库与Java应用，通过JDBC访问数据库

    AT协议是XA协议的演变，AT协议也分为两个阶段：
        一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和资源连接
        二阶段：提交异步化，这可以非常快速的完成，如果发生回滚则通过一阶段的回滚日志进行补偿
    具体流程：
        1、TM向TC注册全局事务，也就是申请全局事务ID，在各个子调用之间传递
        2、RM向TC注册分支事务，这一步需要带着TM的全局事务标识来进行
        3、RM执行完成后提交或回滚自己的分支事务，并把结果通知TC
        4、当代码执行到TM的全局事务出口时，也就是最外层开启全局事务的方法已结束，TM就进行提交
        5、如果期间有任何RM发生异常，TM就会通知TC进行该全局事务的回滚，TC将通知个个参与该全局事务的RM通过本地
    日志进行补偿性回滚

    AT模式的优点：并发性高，对代码无入侵，每个分支事务的锁在第一阶段就会释放，不需要数据库对XA进行支持
                  缺点：只能用在支持ACID的关系型数据库，SQL解析不支持全部语法，因此无法完全准确的进行补偿


2、
    TCC(try、commit、cancel，尝试、提交、取消)：
        一阶段：TM注册全局事务后，调用服务的try接口
        二阶段；TM观察是否全部服务接口的try都返回成功，如果都成功就commit，否则就rollback，TC会调服务相对应的接口
    具体流程：
        1、TM向TC注册全局事务，也就是申请全局事务ID，在各个子调用之间传递
        2、每个子调用所在的TM都向TC注册分支事务，随后执行本地prepare，并向TC汇报执行结果，prepare只是锁定资源
        3、TM根据各个分支事务的执行结果确定第二阶段进行commit还是rollback，然后对TC进行提交或回滚 
        4、如果TM进行提交，TC就调用个个分支服务的commit接口，否则调用cancel接口

    TCC模式的优点：不依赖本地事务
                    缺点：资源锁定、提交、回滚都需要手动编码，对业务侵入性较大


3、
    Saga：
        简单来说，Saga就是将一个长事务分解成一系列子事务，并且每个子事务都有对应的补偿动作，用于撤销对应子事务产生
    的影响
        Saga是Seata提供的长事务解决方案。如果全局事务中涉及到外部系统，无法去管理它的资源，也无法实行TCC，就可以
    用Saga这种方案
        例如：事务1->事务2->事务3，全部成功则全部提交
              ：事务1->事务2->事务3失败->事务2补偿->事务1补偿，出现失败则对之前的事务进行逆向补偿

    具体流程：
        1、Saga应用(集成了Saga状态机)向TC注册全局事务
        2、Saga应用在数据库记录状态机启动
        3、Saga应用向TC注册分支事务，并在数据库记录分支启动
        4、Saga应用执行具体任务，也就是调其它第三方服务的执行接口
        5、Saga应用调用第三方服务后在数据库记录执行结果，并向TC报告分支任务的执行结果
        6、Saga应用将执行结果记录到数据库
        7、Saga应用告知TC此时需要提交还是回滚，如果是回滚，则从TC获取相关会话，然后从DB加载详细信息来恢复状态机

    Saga模式的优点：一阶段本地事务提交，无锁，高性能，事件驱动架构，参与者之间可以异步执行，高吞吐，补偿易于实现
              缺点：不保证隔离性(不同的Saga操作的每一个分支事务都有ACID特效，为什么说保证不了隔离性)，额外的Saga协调器
                    增加了系统的复杂度，并且需考虑协调器自身的故障


4、
    XA模式：
        XA模式是Seata利用事务资源对XA协议的支持，以XA协议的机制来管理分支事务的一种事务模式
        初始阶段：TM向TC注册全局事务
        执行阶段：业务SQL在XA分支中执行，由分支事务的RM管理器进行管理，然后执行XA prepare
        完成阶段：TM通知TC各个分支执行结果，TC再根据结果确定对各个RM是进行rollback还是commit
    具体流程：
        1、TM向TC注册全局事务，拿到全局事务ID
        2、业务开始对其它服务进行调用，如果其它服务有开启全局事务，则通过自己所在的RM将分支事务注册到TC
        3、TM通知TC是进行提交还是回滚，因为TM是最外层最先开启全局事务的组件，它知道全局事务何时结束
        4、TC询问所有分支事务是否prepare完成，随后TC通知各个分支事务的RM进行commit或rollback

    XA模式的优点：继承了XA协议的优势，事务具有强一致性
            缺点：分支事务持续时间长，并发度低


Seata的默认模式是AT，因此这里分析AT模式核心模块：

    TC(事务协调器)以独立的服务启动，作为Server，维护全局事务和分支事务的状态，驱动全局事务提交或回滚
    启动流程如下：
        1、获取NettyServer启动端口，默认是8091
        2、监控初始化，可用于接入prometheus
        3、UUID生成器初始化，用于生成事务ID
        4、会话管理器初始化，支持file、db、redis模式
        5、TC处理器初始化，支持AT、TCC、SAGA、XA等模式
        6、定时任务创建，用于异步处理
        7、启动NettyServer

    TM(事务管理器)，TM集成在应用中启动，负责定义全局事务的范围、开始事务、提交事务、回滚事务。TM所在应用需要
配置GlobalTransactionScannerBean
    启动流程如下：
        1、初始化TMClient，包括：注册TC响应处理器，注册心跳处理器、启动NettyClient
        2、初始化RMClient，包括：注册分支事务处理器，注册TC响应处理器，注册心跳处理器、启动NettyClient
        3、注册shutdown hook，用于关闭TMClient、RMClient
        4、对使用@GlobalTransactional注解的Bean进行动态代理

    RM(资源管理器)，RM集成在应用中启动，负责管理分支事务上的资源，向TC注册分支事务，汇报分支事务状态，驱动分支
事务的提交或回滚。RM所在的应用除了要跟TM一样配置GlobalTransactionScanner以启动RMClient外，还要配置
DataSourceProxy，以实现对数据源访问代理。该数据源代理实现了sql的解析、生产undo log -> 将业务sql和undo log一起
提交到本地事务等操作

一下以一个简单的例子来说明：

    @GlobalTransactional(timeoutMills = 30000, name = 'demo-tx')
    public void buy(String userId, String itemId, int itemCount) {
        stockClient.deuct(itemId, itemCount);
        ......
    }
    以上代码很简单，第一行开启全局事务，第二行定义了一个购买商品的方法，第三行调用库存服务扣库存

正常流程：
    1、TM应用里@GlobalTransactional注解的方法被代理，被调用时执行GlobalTransactionalInterceptor.invoke过滤器
    2、GlobalTransactionalInterceptor.invoke向TC注册，申请全局事务XID
    3、TC生产全局事务ID，并返回给TM
    4、执行buy方法
    5、调用stockClient.deuct()，RPC框架，比如Dubbo的ApacheDubboTransactionPropagationFilter.invoke会将XID设置
到Dubbo上下文
    6、在stock服务中，这里是RM，Dubbo的ApacheDubboTransactionPropagationFilter.invoke从dubbo上下文中拿到XID
    7、stock服务的RM获取sql执行前的镜像，然后执行sql，再获取sql执行后的镜像，然后通过镜像生成undo-log，这里的镜
像是原数据？
    8、向TC注册BranchID，然后TC返回分支事务ID
    9、RM将undo-log插入数据库，然后提交本地事务
    10、此时RM执行结束，回到TM
    11、TM发现调用完成，向TC发起提交全局事务
    12、TC给全局会话加锁，然后关闭会话设置，进行会话清理，将全局事务设置为提交中，最后异步去进行commit
    13、TC异步删除undo-log，然后清理分支会话，并提交全局事务

异常流程：
    从上面第10点开始
    10、TM出现异常，执行结束，异常抛回给TM
    11、TM回调TC进行回滚
    12、TC全局会话加锁，并将全局事务设置为提交中
    13、TC回滚分支事务，回滚后删除会话分支，删除全局事务
    14、TC事务回滚能成功，TM调用结束抛出异常

AT模式的写隔离：
    考虑到一种情况，两个线程同时调用A服务的业务，其中A服务内部又调了B服务。此时线程1先执行，它调用B服务成功，由
于AT模式是先提交后补偿的机制，因此直接提交事务。但是线程1回到A服务后执行失败，TC对B服务进行补偿性回滚，而TC对
B服务回滚之前，B服务的数据已经被线程2读到了，这种情况就出现了脏数据
    为了解决这种事务之间资源隔离的问题，Seata使用了全局锁，锁的key是表名:复合主键，这个锁在每个RM的分支事务开始
时加，在TM提交或回滚全局事务后释放。如果全局事务A已经拿到锁了，另外一个事务还来拿锁就会一直重试，直至事务A释
放锁

AT模式的读隔离：
    也就是全局事务提交后，分支事务的修改才能被读到，Seata会对加了FOR UPDATE的SELECT语句进行代理，也就是说如果
在Seata代理的数据源中使用FOR UPDATE，Seata会先去拿全局锁，拿到了才允许执行，否则就会进行重试



注册中心：

    



















































