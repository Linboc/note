
分布式事务相关概念：
    事务：一个程序执行单元，用户定义的一组操作，需要满足ACID属性
    本地事务：本地事务由本地资源管理器管理
    分布式事务：事务的操作位于不同的服务器节点
    分支事务：分布式事务中，由本资源管理器管理的本地事务
    全局事务：一次性操作多个资源管理器完成的事务，由一组分支事务组成

分布式事务主要有两种：基于XA协议的强一致性与基于MQ的最终一致性


XA：
    XA是基于二阶段提交协议设计的接口标准，实现了XA规范的资源管理器就可以参与XA全局事务。一般而言应用作为事务管
理器TM(Transaction Manage，TM)，数据库作为资源管理器RM(Resouce Manage，RM)，TM生成全局事务id，控制RM的
提交和回滚
    1、TM生成全局事务id
    2、RM执行本地事务，执行完后暂不提交
    3、TM询问每个RM是否准备好，也就是prepare阶段
    4、一旦有任意一个RM进行回滚，TM就会通知所有RM进行回滚
    5、一旦所有RM都准备完成，TM就会通知所有RM进行提交

3PC：
    


柔性事务的最终一致性：
    该规范主要有3种：TCC、MQ事务消息、本地消息表

    TCC：
        TCC指的是：try、confirm、cancel，也就是尝试、确认、取消，TCC同样有一个事务管理器
        1、TM生成全局事务ID
        2、本地事务执行，这一步只是锁定资源，比如从已配送改为取消中，扣库存改为冻结库存，锁定后直接提交事务
        3、然后事务管理器就会根据是否所有本地事务都锁定成功
        4、如果有任意一个本地资源管理器try失败，事务管理器就会通知所有资源管理器进行cancel，将锁定的资源释放
        5、如果所有本地资源管理器都能锁定成功，那么事务管理器就尝试confirm，也就是通知所有的本地资源管理器将中间
    状态改为完成状态

    MQ事务：
        MQ事务的前提是消息系统支持事务消息，比如RocketMQ
        1、本地事务在提交前发送消息到MQ，此时消息处于未提交状态，消费者无法消费到，这种消息叫半消息
        2、本地事务提交后，会提交MQ上的半消息
        3、如果第二步失败了，MQ后续将会对用户状态进行回查
        4、如果用户确认该事务已提交，MQ就会提交该消息，让其可被消费
        5、如果用户确认该事务已回滚，或者长期无法确认事务的状态，MQ就可以把该消息删除
        6、消费者只要能消费到该消息就代表生产者的事务肯定提交成功了

    本地消息表：
        本地消息表跟MQ事务消息类似，区别在于MQ不支持事务消息时，需要借助本地数据库的事务管理功能


Seata：

    Seata有三个核心组件：
        Transaction Coordinator(TC，事务协调器)：
            维护全局事务和分支事务的状态，驱动全局事务提交或回滚，TC以服务的形式独立部署

        Transaction Manager(TM，事务管理器)：
            定义全局事务的范围，开始事务、提交事务、回滚事务，向TC注册全局事务，管理RM之间的事务传递

        Resource Manager(RM，资源管理器)：
            管理分支事务上的资源，向TC注册分支事务，汇报分支事务状态，驱动分支事务的提交或回滚，向TC注册分支事务，
        分支事务回滚

Seata支持的4种工作模式：

1、
    AT(Auto Transaction，自动事务)：
        AT模式是Seata默认的工作模式，需要基于支持本地ACID事务的关系型数据库与Java应用，通过JDBC访问数据库

    AT协议是XA协议的演变，AT协议也分为两个阶段：
        一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和资源连接
        二阶段：提交异步化，这可以非常快速的完成，如果发生回滚则通过一阶段的回滚日志进行补偿
    具体流程：
        1、TM向TC注册全局事务，也就是申请全局事务ID，在各个子调用之间传递
        2、RM向TC注册分支事务，这一步需要带着TM的全局事务标识来进行
        3、RM执行完成后提交或回滚自己的分支事务，并把结果通知TC
        4、当代码执行到TM的全局事务出口时，也就是最外层开启全局事务的方法已结束，TM就进行提交
        5、如果期间有任何RM发生异常，TM就会通知TC进行该全局事务的回滚，TC将通知个个参与该全局事务的RM通过本地
    日志进行补偿性回滚

    AT模式的优点：并发性高，对代码无入侵，每个分支事务的锁在第一阶段就会释放，不需要数据库对XA进行支持
                  缺点：只能用在支持ACID的关系型数据库，SQL解析不支持全部语法，因此无法完全准确的进行补偿


2、
    TCC(try、commit、cancel，尝试、提交、取消)：
        一阶段：TM注册全局事务后，调用服务的try接口
        二阶段；TM观察是否全部服务接口的try都返回成功，如果都成功就commit，否则就rollback，TC会调服务相对应的接口
    具体流程：
        1、TM向TC注册全局事务，也就是申请全局事务ID，在各个子调用之间传递
        2、每个子调用所在的TM都向TC注册分支事务，随后执行本地prepare，并向TC汇报执行结果，prepare只是锁定资源
        3、TM根据各个分支事务的执行结果确定第二阶段进行commit还是rollback，然后对TC进行提交或回滚 
        4、如果TM进行提交，TC就调用个个分支服务的commit接口，否则调用cancel接口

    TCC模式的优点：不依赖本地事务
                    缺点：资源锁定、提交、回滚都需要手动编码，对业务侵入性较大


3、
    Saga：
        简单来说，Saga就是将一个长事务分解成一系列子事务，并且每个子事务都有对应的补偿动作，用于撤销对应子事务产生
    的影响
        Saga是Seata提供的长事务解决方案。如果全局事务中涉及到外部系统，无法去管理它的资源，也无法实行TCC，就可以
    用Saga这种方案
        例如：事务1->事务2->事务3，全部成功则全部提交
              ：事务1->事务2->事务3失败->事务2补偿->事务1补偿，出现失败则对之前的事务进行逆向补偿











