
分布式事务相关概念：
    事务：一个程序执行单元，用户定义的一组操作，需要满足ACID属性
    本地事务：本地事务由本地资源管理器管理
    分布式事务：事务的操作位于不同的服务器节点
    分支事务：分布式事务中，由本资源管理器管理的本地事务
    全局事务：一次性操作多个资源管理器完成的事务，由一组分支事务组成

分布式事务主要有两种：基于XA协议的强一致性与基于MQ的最终一致性


XA：
    XA是基于二阶段提交协议设计的接口标准，实现了XA规范的资源管理器就可以参与XA全局事务。一般而言应用作为事务管
理器TM(Transaction Manage，TM)，数据库作为资源管理器RM(Resouce Manage，RM)，TM生成全局事务id，控制RM的
提交和回滚
    注：这里的TM是Seata里TM和TC的结合体
    1、TM生成全局事务id
    2、RM执行本地事务，执行完后暂不提交
    3、TM询问每个RM是否准备好，也就是prepare阶段，此时RM会获取锁并执行，只不过未commit，就差临门一脚
    4、一旦有任意一个RM进行回滚，TM就会通知所有RM进行回滚
    5、一旦所有RM都准备完成，TM就会通知所有RM进行提交，TM出现超时，那么RM就会长时间阻塞，不释放资源


3PC：
    三阶段提交，是二阶段提交的改进版

    分为三个阶段：
        1、第一阶段：询问(CanCommit)
        2、第二阶段：锁资源(PreCommit)
        3、第三阶段：提交(DoCommit)

    具体流程：
        1、TM向TC注册全局事务
        2、RM向TC注册分支事务，然后执行
        3、TM通知RC执行完毕
        4、TC询问所有RM是否就绪(CanCommit)，RM响应就绪，否则TC通知全部RM回滚
        5、TC询问所有RM是否准备(PreCommit)，RM响应准备完毕，否则TC通知全部RM回滚
        5、TC向所有RM确认提交(DoCommit)，RM响应准提交完毕，否则TC通知全部RM回滚

    表面上看3PC比2PC多了一个准备阶段，或者说把原prepare阶段一分为二。

    3PC的优势：
        1、二阶段在prepare阶段就把所有锁都占用，并执行完所有的操作，仅剩提交，如果此时rollback就会白白浪费大量资源，而
    3PC多了一个PreComit阶段，这个阶段让分支事务可以不用做那么多事，如果此时失败了损失也没那么大
        2、支持超时策略，在2PC中，如果TC长时间没响应，所有RM都会一直等待。而在3PC中，分为RM和TC两种超时：

            参与者：CanCommit和PreCommit阶段，如果RM长时间收不到响应就会进行rollback，而DoCommit阶段如果依然超时，RM就
          会认为大概率会进行提交，因此直接提交本地事务

            协调者：三个阶段如果出现超时都会进行回滚

        3、2PC会出现数据不一致的情况，比如commit只发送给一个参与者后TC就挂了。而3PC会选举出一个新的TC，然后询问所有的
      参与者的状态，因为commit的前提是所有参与者都PreCommit了，因此一但有任意一个commit他就会通知其它所有参与者commit。
      否则就通知所有参与者rollback。因为它不知道所有参与者的状态，如果有commit它就能确定所有参与者PreCommit完毕，而如果
      没有commit，为了保险一点就只能rollback了
    3PC的劣势：
        1、如果出现网络超时，参与者自动commit，但其实TC想要的是rollback，就会出现数据不一致



柔性事务的最终一致性：
    该规范主要有3种：TCC、MQ事务消息、本地消息表

    TCC：
        TCC指的是：try、confirm、cancel，也就是尝试、确认、取消，TCC同样有一个事务管理器
        1、TM生成全局事务ID
        2、本地事务执行，这一步只是锁定资源，比如从已配送改为取消中，扣库存改为冻结库存，锁定后直接提交事务
        3、然后事务管理器就会根据是否所有本地事务都锁定成功
        4、如果有任意一个本地资源管理器try失败，事务管理器就会通知所有资源管理器进行cancel，将锁定的资源释放
        5、如果所有本地资源管理器都能锁定成功，那么事务管理器就尝试confirm，也就是通知所有的本地资源管理器将中间
    状态改为完成状态

    MQ事务：
        MQ事务的前提是消息系统支持事务消息，比如RocketMQ
        1、本地事务在提交前发送消息到MQ，此时消息处于未提交状态，消费者无法消费到，这种消息叫半消息
        2、本地事务提交后，会提交MQ上的半消息
        3、如果第二步失败了，MQ后续将会对用户状态进行回查
        4、如果用户确认该事务已提交，MQ就会提交该消息，让其可被消费
        5、如果用户确认该事务已回滚，或者长期无法确认事务的状态，MQ就可以把该消息删除
        6、消费者只要能消费到该消息就代表生产者的事务肯定提交成功了

    本地消息表：
        本地消息表跟MQ事务消息类似，区别在于MQ不支持事务消息时，需要借助本地数据库的事务管理功能


Seata：

    Seata有三个核心组件：
        Transaction Coordinator(TC，事务协调器)：
            维护全局事务和分支事务的状态，驱动全局事务提交或回滚，TC以服务的形式独立部署

        Transaction Manager(TM，事务管理器)：
            定义全局事务的范围，开始事务、提交事务、回滚事务，向TC注册全局事务，管理RM之间的事务传递

        Resource Manager(RM，资源管理器)：
            管理分支事务上的资源，向TC注册分支事务，汇报分支事务状态，驱动分支事务的提交或回滚，向TC注册分支事务，
        分支事务回滚

Seata支持的4种工作模式：

1、
    AT(Auto Transaction，自动事务)：
        AT模式是Seata默认的工作模式，需要基于支持本地ACID事务的关系型数据库与Java应用，通过JDBC访问数据库

    AT协议是XA协议的演变，AT协议也分为两个阶段：
        一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和资源连接
        二阶段：提交异步化，这可以非常快速的完成，如果发生回滚则通过一阶段的回滚日志进行补偿
    具体流程：
        1、TM向TC注册全局事务，也就是申请全局事务ID，在各个子调用之间传递
        2、RM向TC注册分支事务，这一步需要带着TM的全局事务标识来进行
        3、RM执行完成后提交或回滚自己的分支事务，并把结果通知TC
        4、当代码执行到TM的全局事务出口时，也就是最外层开启全局事务的方法已结束，TM就进行提交
        5、如果期间有任何RM发生异常，TM就会通知TC进行该全局事务的回滚，TC将通知个个参与该全局事务的RM通过本地
    日志进行补偿性回滚

    AT模式的优点：并发性高，对代码无入侵，每个分支事务的锁在第一阶段就会释放，不需要数据库对XA进行支持
                  缺点：只能用在支持ACID的关系型数据库，SQL解析不支持全部语法，因此无法完全准确的进行补偿


2、
    TCC(try、commit、cancel，尝试、提交、取消)：
        一阶段：TM注册全局事务后，调用服务的try接口
        二阶段；TM观察是否全部服务接口的try都返回成功，如果都成功就commit，否则就rollback，TC会调服务相对应的接口
    具体流程：
        1、TM向TC注册全局事务，也就是申请全局事务ID，在各个子调用之间传递
        2、每个子调用所在的TM都向TC注册分支事务，随后执行本地prepare，并向TC汇报执行结果，prepare只是锁定资源
        3、TM根据各个分支事务的执行结果确定第二阶段进行commit还是rollback，然后对TC进行提交或回滚 
        4、如果TM进行提交，TC就调用个个分支服务的commit接口，否则调用cancel接口

    TCC模式的优点：不依赖本地事务
                    缺点：资源锁定、提交、回滚都需要手动编码，对业务侵入性较大


3、
    Saga：
        简单来说，Saga就是将一个长事务分解成一系列子事务，并且每个子事务都有对应的补偿动作，用于撤销对应子事务产生
    的影响
        Saga是Seata提供的长事务解决方案。如果全局事务中涉及到外部系统，无法去管理它的资源，也无法实行TCC，就可以
    用Saga这种方案
        例如：事务1->事务2->事务3，全部成功则全部提交
              ：事务1->事务2->事务3失败->事务2补偿->事务1补偿，出现失败则对之前的事务进行逆向补偿

    具体流程：
        1、Saga应用(集成了Saga状态机)向TC注册全局事务
        2、Saga应用在数据库记录状态机启动
        3、Saga应用向TC注册分支事务，并在数据库记录分支启动
        4、Saga应用执行具体任务，也就是调其它第三方服务的执行接口
        5、Saga应用调用第三方服务后在数据库记录执行结果，并向TC报告分支任务的执行结果
        6、Saga应用将执行结果记录到数据库
        7、Saga应用告知TC此时需要提交还是回滚，如果是回滚，则从TC获取相关会话，然后从DB加载详细信息来恢复状态机

    Saga模式的优点：一阶段本地事务提交，无锁，高性能，事件驱动架构，参与者之间可以异步执行，高吞吐，补偿易于实现
              缺点：不保证隔离性(不同的Saga操作的每一个分支事务都有ACID特效，为什么说保证不了隔离性)，额外的Saga协调器
                    增加了系统的复杂度，并且需考虑协调器自身的故障


4、
    XA模式：
        XA模式是Seata利用事务资源对XA协议的支持，以XA协议的机制来管理分支事务的一种事务模式
        初始阶段：TM向TC注册全局事务
        执行阶段：业务SQL在XA分支中执行，由分支事务的RM管理器进行管理，然后执行XA prepare
        完成阶段：TM通知TC各个分支执行结果，TC再根据结果确定对各个RM是进行rollback还是commit
    具体流程：
        1、TM向TC注册全局事务，拿到全局事务ID
        2、业务开始对其它服务进行调用，如果其它服务有开启全局事务，则通过自己所在的RM将分支事务注册到TC
        3、TM通知TC是进行提交还是回滚，因为TM是最外层最先开启全局事务的组件，它知道全局事务何时结束
        4、TC询问所有分支事务是否prepare完成，随后TC通知各个分支事务的RM进行commit或rollback

    XA模式的优点：继承了XA协议的优势，事务具有强一致性
            缺点：分支事务持续时间长，并发度低


Seata的默认模式是AT，因此这里分析AT模式核心模块：
    



















