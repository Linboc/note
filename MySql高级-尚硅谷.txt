
    MySQL是一个关系型数据库，由瑞典MySQL AB公司开发，目前属于Oracle公司

    MySQL支持大数据库，支持5000万条记录的数据仓库，32位系统表文件最大支持4GB，64位系统最大支持表文件为8TB


Linux下的MySQL安装：

	1、上mysql官网找一个linux系统下的mysql server rpm包
	2、用rpm指令安装服务器的rpm包，可以用mysqladmin --version、cat /etc/passwd | grep mysql等指令查询是否安装成功，mysql安装后会自动创建相关用户与分组信息
	3、用service mysql start指令启动mysql服务，可以用ps -ef | grep mysql查看是否启动成功
	4、可以用service mysql stop停止mysql服务，也可以用service mysql restart重启mysql服务

	刚安装的mysql可以通过/usr/bin/mysqladmin -u root password 123456来为root用户设置密码，root是默认初始用户，默认无密码

	设置mysql服务的开机自启动：chkconfig mysql on；可以通过ntsysv查看有哪些服务是自启动的，ntsysv用tab可以选择退出


Linux下MySQL各个目录的作用：

	/var/lib/mysql：数据库文件目录
	/usr/share/mysql：配置文件目录
	/usr/bin：MySQL命令目录
	/etc/init.d/mysql：启停相关脚本


MySQL的中文乱码处理：
	
	需要修改MySQL的默认字符集编码

	查看当前数据库的字符集：SHOW VARIABLES LIKE 'character%';可以看到很多比如数据库、服务器的默认编码都是latin1

	mysql会自动加载/ect/my.cnf这个文件的配置，因此很多时候都是把/usr/share/mysql/my-huge.cnf文件复制一份出来到/ect/my.cnf来当做自定义配置文件；这个文件在Windows系统下就是MySQL安装目录根路径下的my.ini

	通过/ect/my.cnf文件修改MySQL配置，在[client]下增加default-character-set=utf8，在[mysqld]下增加character_set_server=utf8、character_set_client=utf8、collation-server=utf8_general_ci，在[mysql]下增加default-character-set=utf8，然后重启mysql服务来解决中文乱码问题。注意：如果是在修改配置之前创建的库表，由于编码已经确定，因此依然会是乱码，只有新创建的库表才会应用到新配置
	

MySQL的主要配置文件：

	log-bin：MySQL的二进制日志，主从复制
	log-err：MySQL的错误日志，同时里面也包含启停等信息，默认关闭
	log：查询日志，记录MySQL的查询sql语句，如果开启会降低MySQL的整体性能，默认关闭
	数据库：每个数据库都以目录的方式存在，Linux系统下放在/var/lib/mysql，Windows系统下放在MySQL的安装目录下的data目录
	表名.frm：存放表结构
	表名.myd：存放表数据
	表名.myi：存放表索引
	表名.ibd：存放数据与索引文件

	如果存储引擎是myisam，那么就会用myi、myd类型的文件，如果引擎是InnoDB，那么就会用ibd类型的文件，它们的作用都是存储数据和索引


MySQL的逻辑架构：

	第一层：连接层，比如JDBC、ODBC、PHP、.NET等
	    一层半：连接池比如c3p0，客户端有连接池，MySQL也有自己服务器的连接池

	第二层：插件层，比如备份、集群、安全、分布式、语句解析，优化器，缓存缓冲等等

	第三层：引擎层，比如MyISAM、InnoDB、NDB等等。存储引擎主要使用MyISAM和InnoDB，5.5以后默认使用InnoDB，因为它支持行锁和事务

	第四层：存储，文件系统

	只有一层半到第三层是MySQL所直接涉及的

	MySQL是插件式的可拔插结构


存储引擎介绍：

	查看所有存储引擎：show engines，可以看到所有支持或不支持的存储引擎，和它们的简单描述，不支持是没默认安装

	查看当前存储引擎：show variables like '%_engine%'，可以当前和默认的存储引擎

	InnoDB和MyISAM对比：
			MyISAM			InnoDB
	    主外键	不支持			支持
	    事务	不支持			支持
	    行表锁	表锁			行锁(更适合高并发)
	    缓存	只缓存索引，内存占用少	缓存索引和真实数据，因此内存占用更高，性能也更好
	    表占空间	小			大
	    关注点	性能			事务
	    默认按照    是			是


MySQL性能下降原因：

	首先确定是否MySQL的问题，比如执行时间长，等待时间长

	1、查询写的烂
	2、索引失效
	3、关联太多表
	4、服务器参数设置不合理


SQL执行加载顺序：

	原语句：
		SELECT DISTINCT xxx
		FROM xxx
		JOIN xxx
		ON xxx
		WHERE xxx
		GROUP BY xxx
		HAVING xxx
		ORDER BY xxx
		LIMIT xxx

	MySQL解析后的语句顺序：
		1、FROM xxx
		2、ON xxx
		3、LEFT JOIN xxx
		4、WHERE xxx
		5、GROUP BY xxx
		6、HAVING xxx
		7、SELECT xxx
		8、DISTINCT xxx
		9、ORDER BY xxx
		10、LIMIT xxx

连接：
	其它都是基础的左右内连，仅有一个全连接比较新奇，看下面

	全连接，ORACLE语法：FULL OUTER JOIN，例如：SELECT * FROM t1 FULL OUTER JOIN t2 ON t1.id = t2.id，逻辑是左        连加右连，如果左边和右边有匹配的就两个凑一条;如果只有左边就保留左边，右边留Null;如果只有右边就保留右边，左边      留Null
	MySQL不支持全连接，解决方案是LEFT JOIN UNION RIGHT JOIN，比如：
	SELECT * FROM t1 LEFT JOIN t2 ON t1.id = t2.t_id 
	UNION		
	SELECT * FROM t1 RIGHT JOIN t2 ON t1.id = t2.t_id
	左连+右连会造成两边能匹配条件的部分出现重复，UNION可以对这部分进行除重，并保留两边无法匹配的部分


索引：

    索引简介：

	索引是一种数据结构，它目的在于提高查询效率，它对查询和排序的效率都有影响

	假如数据经常删除，删除的空间没有重用，索引就会出现碎片（是磁盘碎片还是索引里面的无效数据碎片？），经常增删       改的表也不适合建索引，因为数据改动也会导致索引跟着改动，使用索引会使写入成本更高

	唯一索引默认使用B+树结构，除了B+树之外索引还有哈希结构

    索引分类：

	单列索引：一个索引只包含单个列，一个表可以有多个单列索引

	唯一索引：索引的列必须唯一，但允许NULL值，NULL允许存在多个

	复合索引：一个索引包含多个列

	全文索引：

    索引基本语法：

	创建索引：
	    语法1：CREATE [UNIQUE] INDEX index_name ON table_name(field1, field2...)，和语法2作用一样
	    语法2：ALTER table_name ADD [UNIQUE] [INDEX] index_name ON (field1, field2...)，UNIQUE和INDEX同时只用			   其一，分别代表了唯一索引和普通索引
	    语法3：ALTER TABLE table_name ADD PRIMARY KEY (field1, field2...)，添加主键，同时也会添加唯一索引，但		   这个唯一索引不能存在NULL
	    语法4：ALTER TABLE table_name ADD FULLTEXT index_name(field1, field2...)，创建全文索引

	    [UNIQUE]是可选的，如果加上说明是唯一索引
	    一般索引命名是：idx_表名_字段名1_字段名2...

	删除索引：
	    DROP INDEX index_name ON table_name

	查看索引：
	    SHOW INDEX FROM table_name

    索引结构：

	BTree：
	    BTree一般有三层，第一层有两个虚拟数据A、B，还有三个指针，三个指针由左到右分别代表，小于等于的部分，大		于A小于B的部分，大于等于B的部分；然后根据要查找的数据找到相对应的指针，这个指针还是指向第一层一样的数据，		然后通过相同的方式再找到一个指针；这次到了第三层，也就是叶子节点，就是真实数据，只需在这部分数据里找目标数		据就行了；三层的BTree可以表示上百万的数据，并且每次查询只需要三次IO，每层一次

	Hash：

	Full-Text：

	R-Tree：

    适合创建索引的场景：

	1、主键自动建立的唯一索引
	2、频繁作为查询条件的字段
	3、查询中与其他表关联的字段，也就是作为外键的字段
	4、查询中需要排序的字段
	5、查询中统计或者分组的字段
	6、相比于单列索引更倾向于建立组合索引

    不适合创建索引的场景：

	1、频繁更新的字段
	2、WHERE或ON条件里用不到的字段
	3、数据量太少
	4、经常增删改的表，因为MySQL不仅要保存数据，还要更新索引文件
	5、数据大量重复的字段

    建立索引的选择性：
	索引字段中的不同值数量 / 所有索引值数量，结果越接近1就越值得建，比如2000个数据有1999个不同值，那么选择值的    结果就是0.99，这种情况非常值得建立索引


性能分析：

    EXPLAIN：模拟优化器执行SQL查询语句，从而知道MySQL是如何处理SQL语句的

    用法：EXPLAIN SQL

    EXPLAIN包含的信息：

	id：SELECT查询的序列号，包含一组数字，表示SELECT语句操作表的顺序，id解释：

	    id相同：在同一条子语句中表的id是相同的，WHERE引用字段越靠右字段所属的表优先级越高，假如WHERE中分不出优		  先级则以FROM后面的顺序来分，排越前面优先级越高，当然如果是右连接就优先右边的表，左连接和内连接就优先左边		  的表，毕竟要先把主表的数据查出来才能根据数据用条件去匹配其他表

	    id不同：不同的子语句中id就会不同，子查询id会比父查询id大，优先级最高的是最内的子查询，id越大优先级越高

	    id同时存在相同与不同：id大的优先级最高，相同的则前面的优先级最高

	    假如子查询会用作衍生表(临时表)，那么这个子查询的id结束之后跟着读取的就是这个延伸表，table列的值会为			  <derived子查询id>

	    id能看出表的读取顺序

	select_type：这个子语句的查询类型，类型解释如下：

	    SIMPLE：简单查询，包含关联查询，不包含子查询和UNION

	    PRIMARY：如果有子查询或UNION，被最后加载的那个子查询包含的表都是PRIMARY

	    SUBQUERY：子查询，子查询的结果不用做衍生表则是SUBQUERY

	    DERIVED：衍生表，子查询的结果被当做衍生表(临时表)使用则是DERIVED

	    UNION：在UNION后面的表类型会为UNION

	    UNION RESULT：UNION RESULT的id会总NULL，它的table结构是<union1,2>，1,2代表着返回union的子语句id，代表		  着UNION RESULT会在id为1和2的子查询全部执行完后读取，因为所有关联的表都执行完后才能生成结果给它读取

	    DEPENDENT SUBQUERY：子查询的结果依赖取决于外面

	table：这行的数据关于哪张表

	    如果表有别名就用别名，没有就用表名；一些特殊的查询类型，比如衍生表、UNION RESULT表，就会是<>里面有相关		  关键字加id，比如<derived子查询id>、<union关联表id1,关联表id2>，详细情况在上边的id和selece_type中有顺带提

	type：表的读取方式，优化效果的重要依据，常见类型的解释如下：

	    ALL：全表扫描

	    index：遍历索引树，如果查询的列都刚好是索引，就会直接读取索引文件，因为索引文件通常比数据文件小，因此		  虽然都是读全表，index通常还是比ALL快

	    range：使用索引列来进行范围查询，比如使用between、<、>、in，这种方式比全表好，因为只要索引开始结束的点

	    ref：使用索引扫描，并且查询条件能匹配索引或复合索引，扫描结果可能有多个符合条件

	    eq_ref：使用索引扫描结果只有一条记录与之匹配，常见于主键或唯一索引扫描

	    const：在用主键或者唯一索引当查询字段时，查询条件是常量，MySQL在这次查询中会把这个查询当做常量，因为结	  果总是不变

	    system：系统表，表只有一行记录，这是const类型的特例，一般情况几乎不会出现

	    NULL：不用读表

	  type的优劣排序：	  	  system>const>eq_ref>ref>fulltext>ref_or_null>index_merge>unique_subquery>index_subquery>range>index>ALL

	possible_keys：涉及到查询字段可能会用到的索引

	key：实际用到的索引，如果使用了覆盖索引可能possible_keys中没有key中却有
	    比如查询条件没有用到索引列，MySQL认为用不上索引，可是查询列却按照索引列来查，这时候又需要索引来避免全		  盘扫描，因此就会出现索引仅在key中存在

	key_len：使用索引匹配的情况下，索引使用的字节数，该值通过计算得出，而非实际统计值，相同结果下越小越好

	ref：哪些列或常量被用于索引搜索，比如等于：db01.user.id,const，则说明db01这个库的user表的id和一个常量(比如       是'abc', 223这种)，被用来匹配一个两列的复合索引；主要说明了索引被哪些列所引用
	
	rows：大致估算出执行子语句时这个表需要读取的行数，每行的行数都相乘就是这条SQL总共需要读取的行数，当然只是      估算，因此会出现有时候rows贼夸张，可是查询依然很快，这时就是个估算错误

	Extra：不适合在其它列展示却又重要的额外信息

	    Using filesort：使用外部的索引排序，MySQL无法利用索引完成的排序称为文件排序，也就是说在有索引的情况下
	  又另外做了一次只靠索引的数据无法完成的排序。例如使用了a、b列的索引，然后再order by的时候用了abc，这三列		  无论怎么组合排序，MySQL都会尝试去找到既能满足ab列索引的查询又同时存在c列的索引，如果找不到，哪怕排序列是		  主键，因为索引已经读取好了，这时候就要重新读取数据进行排序，因此也会出Using filesort。如果order by的时候		  没有取已经用到的索引，并且不能衔接上前面的索引组合成复合索引，也会引发这问题，因为索引断开了，后面的数据	  又成了无序状态，order by的索引跟where的可以重叠，不能中断。如果在where中有条件中断了复合索引，但是order 		  by中的列能和where里某些列衔接成复合索引，那么order by中的索引也能生效。如果order by的列在where中已经确定	  是常量，那么在order by中就可以忽略它，因为固定值的列不需要排序，比如：复合索引c1,c2,c3，WHERE c1='xx' 	  AND c2 = 'xx' ORDER BY c3,c2，这种情况也不会出现Using filesort，因为c2是常量，是不需要排序的，相当于只要	  排c3，因此会用到索引，需要优化

	    Using temporary：使用临时表保存中间结果，MySQL对查询结果排序时使用了临时表。常见于group by,例如在group 
	  by的时候，原本索引是f1, f2，而group by直接对f2分组，就会同时出现Using filesort和Using temporary。它的使		  用注意事项和Using filesort一样，一但造成group by中的列索引失效，就会出现此问题。需要优化

	    Useing index：使用了索引。如果同时出现Using where和Using index，就说明索引被用来匹配条件，如果只存在		  Using index则说明使用了覆盖索引，只用索引来读取数据而不进行查找，详情参考key覆盖索引的描述，不需要优化。
	  覆盖索引的意思就是查询的列被索引覆盖，刚好查的就是索引，因此直接读取索引返回，索引的数据通常比全表少

	    Using where：使用了where查询，不需要优化

	    Using join buff：使用了连接缓存，如果用了很多join，就会提示，这时候就要注意查询缓存是否要调大点，不需		  要优化

	    Impossible WHERE：永远为false的条件，比如：name='a' AND name='b'，同一个字段不可能同时等于两个值

	    select tables optimized away：在没有GROUP BY的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优		  化COUNT(*)操作，不必等到执行操作完成再计算，在执行计划生成阶段即可完成优化，也就是直接根据某个变量计算，		  而非进行实际统计

	    distinct：优化DISTINCT操作，第一次找到某个值后，接下来就不会再查找相同的值了


    并不是用了or就会使索引失效，而是用了or后，每个or之间的条件如果不是全都用了索引，那么索引就会失效，假如多个or条件用的列都用了索引，那么索引还是会生效的，否则就会全表扫描，比如：索引查询 or 复合索引1 and 复合索引2 or 索引查询，这种情况依然会用到索引

    用了复合索引的前半部分，可以在order by或group by后面跟着剩下的索引部分，MySQL会自动续上剩下的索引，当然如果是in和or就续不上，就只能重新在order by或group by引用完整索引了

    查询后面加/G，会把查询结果竖着排，默认是横着排，\G之前不能有分号，否则就会提示：No query specified


索引建立的抉择：

	两表时，左连接就在右表建索引，右连接就在左边建索引，因为连接的表数据是已确定的全数据，只有针对未读取的数据      建索引才能有效优化，当然左连接时左边也可以建，比如左边的id去匹配右边id，那么左边建连接可以使左边的type提升为       index，因为左边数据直接从索引读取，右表也建了的话，右边的type就会为ref，因此索引建在数据未知的表性价比最高

	尽量用小表驱动大表，因为第一个表经常需要全表扫描，比如left join和right join时主驱动表分别在左边跟右边，因     此每次JOIN都需要申请、连接、释放，如果表1有5条记录，表2有10W条记录，用表1只需要进行5次JOIN流程，而用表2则需要     10W次

	优先优化嵌套的子语句，由内而外，毕竟SQL的执行逻辑也是由内而外

	被驱动表的字段最好加索引，如果无法保证加索引，在内存足够的情况下就要考虑join buffer调高一点，毕竟缓存高每      次处理的数据也多，join buffer是每次join都会分配一次，比如三表关联就分配两次，配置文件里可能找不到join buffer       ，在数据库里直接SHOW variables WHERE variable_name LIKE '%join%'就能看到join_buffer_size的具体配置

	尽可能把过滤性更好的字段排更前

避免索引失效：

    1、索引使用必须连贯，假如在使用复合索引的情况下，仅使用了索引后面的列而跳过前面的列，那么前面的列索引依然会被用到，后面不连贯部分的索引就会失效，这会造成索引部分失效。假如直接用了后面的列，前面的列从第一个开始就没用，那这个索引就会完全失效

    2、不要在需要索引生效的时候在对索引列上做任何操作，例如计算、函数、自动或手动造成的类型转换，这些都会导致索引失效转向全表扫描

    3、使用了范围查询之后，例如：<、<、between等，那么type会变成range，并且它之后的索引都会失效。例如有a、b、c3列，他们是复合索引，查询条件是：a='xx' AND b > 3 AND c = 'xx'，a会用到索引，b也会用到索引，不过是range，而c的索引就会失效。这些关键字的相同点是，要么有个开始或结束定位，要么就是相当于多次索引匹配，跟!=、<>是两回事

    4、尽量少用SELECT *，最好能使用覆盖索引，否则就算查询条件用到了索引，也依然要另外去读表数据，如果使用覆盖索引就省去了索引检索后去读表的步骤，使用覆盖索引后，Extra会有Using index提示

    5、使用!=或<>都会导致全表扫描，因为排除某一个值后剩余的数据全都是想要的，MySQL要给他们排除指定值后，还要读取剩余的所有数据，因此会导致全表扫描

    6、IS NULL对索引依然有效，不过IS NOT NULL就会进行全表了，原因参考第五条

    7、LIKE的%在右边索引依然会生效，不过type变range,并且后面的索引依然还能续上。如果写在左边就会导致全表扫描，因为%在右边还可以拿左边的一个一个匹配过去，虽然只能匹配部分，这部分匹配完了就只能全部读取剩下的了，但也比完全没有索引好。解决方法是使用覆盖索引的数据进行扫描，虽然也是全扫描，但是扫描索引比扫描全表强。比如有索引a、b，这时候非要对b进行LIKE '%xx%'，那么在b有索引的情况下，LIKE会优先拿索引的数据进行匹配，这样type好歹是index；假如还有个id主键，但是复合索引只有a、b，然后SELECT id，这时候key虽然显示只用了a、b的索引，但依然是index，id索引用了却不会显示，假如这时候用了SELECT a, b, c，那么覆盖索引就会失效，从而进行全表扫描；反正这列在索引中没有，无论如何都要读表了，干脆就读表算了，免得另外再读索引

    8、使用or、in会使索引失效

    9、使用了<、>、between、like之后，可能使用的那个索引还有部分生效，但是之后的索引都不会生效了，因为在这里索引断了

    10、GROUP BY使用注意事项和ORDER BY基本是一致的，因为分组前是要经过排序的，这个排序需要一个临时文件，如果排序列刚好匹配索引，那么就可以省去临时文件


优化分析：

1、开启慢查询日志

1、explain + 慢SQL分析

2、show profile(explain升级版)

3、数据库服务器参数调优



















































