
    JUC就是java.util.concurrent，指的是java并发工具包，包括java.util.concurrent、java.util.concurrent.locks和java.util.concurrent.atomic

    wait和sleep的区别，它们都会阻塞线程，而wait就是放弃释放当前线程锁的资源，sleep则会继续维持着锁


线程的状态：

    Thread.State是一个枚举类，代表着线程的状态，状态如下：
	NEW：线程创建
	RUNNABLE：线程就绪
	BLOCKED：线程阻塞，正在等待获取锁
	WAITING：线程无期限阻塞，比如调用wait
	TIMED_WAITING：线程有期限阻塞，比如sleep或者wait(long)
	TERMINATED：线程结束

synchronized：
    synchronized在实例方法时，锁的是当前调用对象，在静态方法时，锁的是类。类和实例的锁是分开互不干涉的，在代码里加synchronized(obj)的锁的是obj这个对象，实例方法的锁可以看做synchronized(this)，静态方法的锁可以看做synchronized(当前类.class)，其实锁的都是对象，不过一个是实例对象，一个是Class对象。当一个线程试图访问同步方法时，它必须首先得到锁，退出代码块或者抛出异常都会必须释放锁


虚假唤醒：
    在使用wait配合notifyAll的时候，需要防止出现虚假唤醒，比如if判断某个线程进入wait状态，假如这是一个资源类，那么在状态不变的情况下后续的线程调用这里也会调wait，就算用了synchronized后续的线程依然会进来，因为有wait释放锁。
    这时候调了notifyAll，本意可能是想让其中一个线程去执行某个逻辑，可是如果有多个线程都在wait那里，那么就会全部wait的线程就会一股脑的执行这个逻辑。比如买票卖票，每次+1或-1，多线程情况下卖票到1了就会阻塞，多个线程都阻塞在一起，然后开始买票，买完票一调notifyAll，卖票线程所有线程都给放开了，第一个线程买了第二个线程依然去买，这就是虚假唤醒      这时候判断票就不应该用if，而是用while，让卖票线程被唤醒后再去执行一遍判断，防止前面的线程卖票后面的线程依然去卖。不用担心多个线程同时执行while，同时跳出循环，同时执行卖票，因为synchronizedd原因，只有唤醒的第一个线程才会获得锁，其它线程会等待锁，等第一个线程执行完回到wait的时候，其它线程依然无法通过while的判断，会继续wait


线程安全集合类：

Vector：
    ArrayList加synchronized版本

Collections.synchronizedXXX：
    各种转线程安全集合函数，其实就是在内部创建了一个对象，实现了相同的方法，然后在相同方法里在synchronized代码块里面调用传进去对象的方法

CopyOnWriteArrayList：
    在进行写入操作的时候，先用lock上个锁，然后创建一个新的数组对象，再给这个新的数组对象进行copy，add就是长度+1，remove就是长度-1，然后Arrays.copy，如果操作在数组中间的元素，就先copy前半部分，略过操作的那个元素再copy后半部分，新数组处理好之后，在setArray，让后面的调用者使用新数组，旧数组就废弃了，除了一些之前创建的迭代器可能会保存着快照(snapshot)对象

CopyOnWriteArraySet：
    内部使用了一个CopyOnWriteArrayList来实现相关功能，每次添加都遍历一遍数组来进行除重判断，如果已存在就添加失败，其他功能也使用了类似的机制

ConcurrentHashMap：
    1.7采用了分段锁机制，1.8采用了CAS(比较并替换，涉及到底层内存操作)+Synchronized

线程的创建方式：
    1、extends Thread：继承
    2、implments Runable：实现
    3、implments Callable<T>：实现+返回值，可往方法上级抛异常
	第三种直接用Callable是用不了的，要new FutureTask类，然后把Callable传进它的构造器里，再把FutureTask传进    Thread的构造器里，然后启动Thread，如果想要返回则则用FutureTask对象的get方法，它会一直阻塞到拿到返回值，并且    FutureTask对象只会执行call函数一次，返回值会缓存起来，也就是如果放进多个Thread对象里start，那么也只会执行一次      ，第一次之后的Thread发现能直接拿到返回值就不会去执行call函数

互斥锁：
    让资源在同一时间只有一个线程能访问，比如synchronized或lock

CAS(Compare-and-Swap：比较并替换)：
    CAS是一种算法，能让一个变量的修改值操作具有原子性，原理是：
	1、拿到旧值
	2、修改到新值
	3、比较当前内存中的值和旧值是否一样，如果不是就回到第一步，是就替换掉旧值，判断和替换是原子性操作
    它有三个问题，循环时间开销可能会很大、只能同时保证一个变量的原子性操作、ABA问题
	1、循环时间是设计问题
	2、多操作原子性的问题可以通过互斥锁或者AtomicReference来解决
	3、ABA问题就是，怎么能保证在比较时拿到的值是否在修改期间被修改后又被改了回来。JUC的解决方式是，提供一个带    有标记的原子引用类AtomicStampedReference，通过控制变量的版本(其实就是时间戳)来解决ABA问题

thread.interrupted()：
    线程中断，这仅仅会把打断标识位设置为true，而不会真的打断线程，还需要在程序中进行thread.isInterrupted()判断来做相应处理。如果线程正阻塞时被其它线程进行了中断，比如sleep、join、wait、join等，那么就会抛出InterruptedException异常，并且把interrupted重置为false。在synchronized获取锁时阻塞是不会被打断的

thread.join：
    在当前线程中调用其它线程的join方法时，就会阻塞到调用join的线程执行结束才会继续执行

JUC工具类：

CountDownLatch(倒计数锁)：
    倒计数锁，构造器需要传一个总计数，线程安全。主要使用两个函数，countDown：计数减一，await：在哪个线程使用就把当前线程阻塞到计数为零。一但countDown把计数减到0，就会把所有线程从执行await的地方唤醒

CyclicBarrier(计数锁)：
    计数锁，构造器需要传一个计数和一个Runable对象(可选，用来在计数满足时执行)，使用了ReentrantLock保证了计数时的线程安全。函数如下：
	getParties()：获得总计数
	getNumberWaiting()：获得当前计数
	isBroken()：是否计数完成
	await()：阻塞当前线程，并且计数+1
	reset()：重置计数，await()的地方会抛BrokenBarrierException异常
    当计数达到指定数目，则会让最后一个进行await的线程去执行Runable对象的run方法，然后唤醒所有通过await阻塞的线程

Semaphore(信号量)：
    用于多个共享资源在并发线程数下的控制(比如服务器只允许同时有100个请求访问)，构造器传个3代表同时允许3个线程获取资源，后面的其它线程再获取就会被阻塞。主要有如下方法：
	acquire：要么获取锁(信号量-1)，要么一直阻塞直到有线程释放信号量或超时，还能指定要获取多少信号量
	tryAcquire：尝试获取信号量，不阻塞，无法获取就返回false，还可以指定超时时间，超时结束前一直尝试获取
	release：释放锁(信号量+1)，然后唤醒等待的线程，还能指定释放多少信号量
	availablePermits：当前剩余可用信号量


lock：

    lock的功能可以代替synchronized，其中synchronized的加锁和解锁分别用lock和unlock代替，wait、notify、notifyAll则用lock.newCondition对象的await、signal、signalAll来代替

ReentrantLock：

    可重入锁，同一个ReentrantLock对象只有第一次进行lock的时候生效，后面的lock都会被阻塞，只有lock执行unlock才    会释放前面的锁，因此每次lock都对应一个unlock，前面的lock没有进行unlock，后面的lock就会一直被阻塞，并且释放锁的    顺序和调用lock的顺序一致。
    lock.newCondition()函数可以获得一个Condition对象，这个对象对应着Object类的几个方法:wait、notify、notifyAll，他们分别对应着Condition对象的await、signal、signalAll，作用是一致的，Object的方法对调用的对象与当前线程生效Condition的方法对它所属的lock和当前线程生效
    并且Lock还有一个优势，可以精准决定解哪个锁，只需要用一个lock创建多个condition对象，每个锁分别用一个，锁的时候用对应condition的await()，解锁的时候用要解锁的那个condition的signal()就行了，同一个condition还可以进行多次     await，然后使用signalAll()进行一次性全部唤醒，比wait和nodity灵活在自由控制解锁的线程，nodify的解锁是由操作系统决  定的。
    这跟new几个Object对象有什么区别，不同地方的加锁和解锁分别用这几个对象进行就可以了？因为Object的几个线程相关方法都需要使用synchronized锁住相关对象才能使用这些对象的线程方法，如果没锁定就用会抛出IllegalMonitorStateException异常，总不能每次阻塞或唤醒都要先给对应的对象加锁吧。虽然condition也要它所属的lock对象加锁，不然也会出现那个异常，但是多个condition对象只要用同一个把它new出来的lock进行锁定就行了

ReadWriteLock：

    这是一个接口，实现类是ReentrantReadWriteLock。这个类主要有两个锁，分别是readLock()和writeLock()，可以获取到读锁和写锁，然后分别用lock和unlock进行加锁和释放锁。其中写锁是排他的，也就是写锁lock之后，无论是读锁还是写锁进行lock都会进行阻塞，只有等写锁unlock之后才能再进入。而读锁是共享的，也就是读锁只要不被写锁干涉就可以随意加锁解锁，读锁进行lock的的作用是，在写锁lock之后能在读锁lock的地方进行阻塞


BlockingQueue(阻塞队列)：

    这是一个接口，当队列是空的，获取元素操作将会被阻塞，直到元素被添加；当队列是满的，添加元素操作将会被阻塞，直到元素被获取

    核心函数：
	插入：add(已满则抛异常)、offer(已满返回false)、put(已满则阻塞)、offer(e, time, unit)(offer等待至超时版本)
	移除：remove(没有则抛异常)、poll(没有则返回null)、take(没有则阻塞)、poll(time, unit)(poll等待至超时版本)
	检查(跟移除相同的是都返回第一个元素，但是检查后元素依然在)：element(没有则抛异常)、peek(没有则返回null)














多线程使用诀窍：
    1、使用线程来操作资源类，资源类自己内聚实现线程安全
    2、判断(假如可以操作就继续，否则就阻塞)、干活(执行业务操作)、通知(唤醒其它线程)
    3、多线程交互环境下，要防止多线程的虚假唤醒，判断只用while，不用if
    4、根据标识位来判断不同的线程该执行还是阻塞等待唤醒










