
    JUC就是java.util.concurrent，指的是java并发工具包，包括java.util.concurrent、java.util.concurrent.locks和java.util.concurrent.atomic

    wait和sleep的区别，它们都会阻塞线程，而wait就是放弃释放当前线程锁的资源，sleep则会继续维持着锁


线程的状态：

    Thread.State是一个枚举类，代表着线程的状态，状态如下：
	NEW：线程创建
	RUNNABLE：线程就绪
	BLOCKED：线程阻塞，正在等待获取锁
	WAITING：线程无期限阻塞，比如调用wait
	TIMED_WAITING：线程有期限阻塞，比如sleep或者wait(long)
	TERMINATED：线程结束

synchronized：
    synchronized在实例方法时，锁的是当前调用对象，在静态方法时，锁的是类。类和实例的锁是分开互不干涉的，在代码里加synchronized(obj)的锁的是obj这个对象，实例方法的锁可以看做synchronized(this)，静态方法的锁可以看做synchronized(当前类.class)，其实锁的都是对象，不过一个是实例对象，一个是Class对象。当一个线程试图访问同步方法时，它必须首先得到锁，退出代码块或者抛出异常都会必须释放锁


虚假唤醒：
    在使用wait配合notifyAll的时候，需要防止出现虚假唤醒，比如if判断某个线程进入wait状态，假如这是一个资源类，那么在状态不变的情况下后续的线程调用这里也会调wait，就算用了synchronized后续的线程依然会进来，因为有wait释放锁。
    这时候调了notifyAll，本意可能是想让其中一个线程去执行某个逻辑，可是如果有多个线程都在wait那里，那么就会全部wait的线程就会一股脑的执行这个逻辑。比如买票卖票，每次+1或-1，多线程情况下卖票到1了就会阻塞，多个线程都阻塞在一起，然后开始买票，买完票一调notifyAll，卖票线程所有线程都给放开了，第一个线程买了第二个线程依然去买，这就是虚假唤醒      这时候判断票就不应该用if，而是用while，让卖票线程被唤醒后再去执行一遍判断，防止前面的线程卖票后面的线程依然去卖。不用担心多个线程同时执行while，同时跳出循环，同时执行卖票，因为synchronizedd原因，只有唤醒的第一个线程才会获得锁，其它线程会等待锁，等第一个线程执行完回到wait的时候，其它线程依然无法通过while的判断，会继续wait

lock：

    lock的功能可以代替synchronized，其中synchronized的加锁和解锁分别用lock和unlock代替，wait、notify、notifyAll则用lock.newCondition对象的await、signal、signalAll来代替

    ReentrantLock：
	可重入锁，同一个ReentrantLock对象只有第一次进行lock的时候生效，后面的lock都会被阻塞，只有lock执行unlock才    会释放前面的锁，因此每次lock都对应一个unlock，前面的lock没有进行unlock，后面的lock就会一直被阻塞，并且释放锁的    顺序和调用lock的顺序一致。
	lock.newCondition()函数可以获得一个Condition对象，这个对象对应着Object类的几个方法:wait、notify、notifyAll
    ，他们分别对应着Condition对象的await、signal、signalAll，作用是一致的，Object的方法对调用的对象与当前线程生效    ，Condition的方法对它所属的lock和当前线程生效
	并且Lock还有一个优势，可以精准决定解哪个锁，只需要用一个lock创建多个condition对象，每个锁分别用一个，锁的    时候用对应condition的await()，解锁的时候用要解锁的那个condition的signal()就行了，比wait和nodity灵活在自由控制    解锁的线程，nodify的解锁是由操作系统决定的。
        这跟new几个Object对象有什么区别，不同地方的加锁和解锁分别用这几个对象进行就可以了？因为Object的几个线程相    关方法都需要使用synchronized锁住相关对象才能使用这些对象的线程方法，如果没锁定就用会抛出IllegalMonitorStateExc     eption异常，总不能每次阻塞或唤醒都要先给对应的对象加锁吧。虽然condition也要它所属的lock对象加锁，不然也会出现    那个异常，但是多个condition对象只要用同一个把它new出来的lock进行锁定就行了

CopyOnWriteArrayList：
    在进行写入操作的时候，先用lock上个锁，然后创建一个新的数组对象，再给这个新的数组对象进行copy，add就是长度+1，remove就是长度-1，然后Arrays.copy，如果操作在数组中间的元素，就先copy前半部分，略过操作的那个元素再copy后半部分，新数组处理好之后，在setArray，让后面的调用者使用新数组，旧数组就废弃了，除了一些之前创建的迭代器可能会保存着快照(snapshot)对象



多线程使用诀窍：
    1、使用线程来操作资源类，资源类自己内聚实现线程安全
    2、判断(假如可以操作就继续，否则就阻塞)、干活(执行业务操作)、通知(唤醒其它线程)
    3、多线程交互环境下，要防止多线程的虚假唤醒，判断只用while，不用if
    4、根据标识位来判断不同的线程该执行还是阻塞等待唤醒










