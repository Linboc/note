
对于每个请求，servlet会为其完成以下3个操作：

	1、创建一个request对象，servlet会把有可能用到的信息填充到request对象，如参数、头、cookie、查询字
符串、URI等，request对象是javax.servle.ServletRequest接口的示例

	2、创建一个response对象，response对象是javax.servlet.ServletResponse接口的实例
	
	3、调用Servlet的service()方法，将request和response对象作为参数传入


JavaWeb服务器的运行：

	Web服务器也成为超文本传输协议(HTTP)服务器，基于Java的Web服务器会使用两个重要的类：java.net.Socket
和java.net.ServerSocket类，并通过发送HTTP消息进行通信

	HTTP：
		HTTP是一种基于“请求-响应”的协议

	一个HTTP请求包含以下三个部分：

		1、请求方法 统一资源标识符(URI) 协议/版本
		    示例：POST /examples/default.jsp HTTP/1.0
		    请求方法会出现在请求的第一行
		    HTTP/1.1支持7种请求方法：GET、POST、HEAD、OPTIONS、PUT、DELETE、TRACE

		    URI指定Internet资源的完整路径，URI通常会被解释为相对于服务器根目录的相对路径，
		因此它总是以“/”开头，统一资源定位符(URL)实际上是URI的一种类型

		    URL和URI的区别，URI是唯一地标识了一个资源，而URL是为资源给定了一个唯一的定位，比如
		https://www.jianshu.com/index.html就是标志了index.html的定位，所以它是一个URL，而URL是URI
		的一种类型，因此它也算一个URI，因为通过这个定位也能唯一的标识这个资源，总结：URI就是能唯
		一地标识资源，不管用什么方式，能做到就是一个URI，而URL是一种实现，用定位的方式做到了唯一
		的标识资源

		    协议版本指明了当前请求使用的HTTP版本
				
		2、请求头

		    请求头包含的信息类似于key:value的方式，示例：
			Connection: Keep-Alive
			Host: localhost
			Conten-Length: 33
			Accept: text/plain; text/html
			User-Agent: Mozilla/4.0 (compatible; MSIE 4.01; Windows 98)
		    请求头包含客户端环境和请求体相关的信息。例如浏览器语言、请求体长度等，多个请求体直接
		用换行符隔开

		3、请求体
	
		    示例：agsnkjbdjkbk什么乱七八糟的都可以有
		    请求头和请求体之间有一个空行，这个空行告诉HTTP服务器请求体从哪里开始

	一个HTTP响应也分为三个部分：

		1、协议 状态码 描述
		    示例： HTTP/1.1 200 OK
		    
		2、响应头

		    也和请求类似示例：
			Server: Microsoft-IIS/4.0
			Date: Mon, 5 Jan 2004 13:13:33 GMT
			Content-Type: text/html
			Content-Length: 112

		3、响应体
		    示例：<html><body>hello world</body></html>
	
	把自己写的Request和Response实现ServletRequest和ServletResponse接口，然后在调用Servlet的service方
法的时候传进去，这样有个风险，因为传入的对象可以向下转型成Request和Response，而这两个对象中有一些方法并
不想让其它人调用，如parse和sendStaticResource方法，这时候用了外观模式，新建两个类RequestFacade和ResponseFacade
，他们也分别实现了ServletRequest和ServletResponse接口，并且它们的构造器需要一个参数，分别是ServletRequest
和ServletResponse接口的对象，其实传入的就是Request和Response对象，并把这个对象设为私有，他们只有ServletRequest
和ServletResponse接口的方法，外部每次调用它们的方法它们都会去用内部保存的那个变量去调用相关的方法，这样就
能做到保护parse和sendStaticResource方法了，外部无法调用，向下转型也只能转成Facade类

StringManage：

	Tomcat处理错误消息的方法是将错误消息存储在一个个properties文件中，并在程序出现错误的时候调用对应
的属性，这样把错误的提示信息放在properties文件中，方便管理，并且这些properties还是分包存储的，对应类的错
误文件都放在它的包下面，可以看到Tomcat很多包下面都有LocalStrings.properties文件，这就是它的错误消息文件了
，并且还可以在调用的时候传参数来达到动态消息的目的，示例代码：

	//获取HTTPServer.class包下的LocalStrings.properties文件，当然还可以通过传包名来获取，还可以根据语
	//言分不同文件，在文件名后面加"_"再加上语言名称，StringManager会用本地的默认语言去获取该文件，StringManager
	//对象是单例的，只有第一次获取在缓存中找不到才会去创建新的对象，缓存结构是一个HashTable
	StringManager manager = StringManager.getManager(HTTPServer.class);

	//第一个参数是要在该文件中获取的属性，后面的是可变参数，可以通过{0}、{1}...这种方式来插入参数，这
	//种动态参数是StringManager来处理的，把原始数据取出来，再自己根据参数进行格式化
	//比如：dataSourceLinkFactory.badWrapper=Not a wrapper for type {0}，结果就是Not a wrapper for type aaa
	manager.getString("dataSourceLinkFactory.badWrapper", "aaa");

	关于不同多语言的LocalStrings.properties，由于StringManager会通过Locale.getDefault去获取默认的语言
环境，比如是中国，就会去找LocalStrings_zh_ch.properties，找不到就去找通用的LocalStrings.properties，会优
先使用符合环境的，如果需要切换环境，就用Locale类的静态方法setDefault就可以了，通过这种方式实现多语言的错
误提示

	Tomcat通过这种方式进行提示信息的统一处理，并通过StringManager对象对这些信息进行操作

第三章简单服务器的执行流程：
	Bootstrap调用Connector，然后每一个Connector进来都调用Processor去创建Request和Response对象，并且从
InputStream中解析各种资源填充进对象里，如果请求的是Servlet，Processor就创建Servlet对象去调用service方法，
静态资源就直接返回

HTTP1.1的3个新特性：

	持久连接：

	    在HTTP1.1之前，无论浏览器何时连接到Web服务器，当服务器将请求的资源返回后，就会断开与浏览器的
连接。但是网页通常包含一些其它资源，比如图片、文件、applet等。因此，当请求一个页面时，浏览器还要下载这些
资源，如果每个不同的资源文件都用不同的连接进行下载的话，处理过程会很慢。这就是HTTP1.1引入持久连接的原因，
使用持久连接后，当下载了页面后，服务器不会立即关闭连接，它会等待Web客户端请求被该页面所引用的所有资源，这
样一来，页面和页面所引用的资源都会使用同一个连接来下载，考虑到建立/关闭HTTP连接是一个系统开销很大的操作，
使用同一个连接来下载会为Web服务器、客户端和网络节省很多时间和工作量
	如果使用HTTP1.1，就会默认使用持久连接。也可以在请求头中加显式地指定使用：connection: keep-alive

	块编码：

	    由于要使用一个连接发送多个资源，而客户端不知道每个资源从哪里开始到哪里结束，因此HTTP1.1使用了
块编码，来指明字节码会分块发送，对于每个块，最前面是块的长度，以16进制表示，然后是一个\r\n字符，然后是块
的内容，客户端不用管这个块的内容有多少，只要按照给定的长度读，读完之后就开始第二个块的长度读取，然后再读
\r\n，接着一直读完第二个块的长度，如果读到某个块的长度是0，那就说明这个事务已经完成，举个例子：

	1A\r\n				//说明这个块有26个字节
	aabb123654789zxcvasqwrgsz	//读完26个字节就开始准备下个块
	3\r\n				//第二个块有3个字节
	321				//读完第二个块，开始第三个
	0\r\n				//说明已经没了，事务结束

	    HTTP1.1的每个持久连接可能要按照请求的顺序去返回数据，否则就会把请求和响应的资源搞混，既然要
	保持顺序那每个持久连接就要用单线程了，这就是很多网站的资源时由上而下地一个个刷新出来的原因？
	    HTTP1.1可以用一个特殊的请求头“transfer-encoding”来指明字节流会分块发送

	状态码100：

	    客户端如果准备发送一个较大的资源给服务器，而不确定服务器是否会接受，如果直接发送，而服务器却
拒收时，可能会造成较大的浪费，因此客户端可以在向服务器发送请求体之前发送一个请求头：Expect: 100-continue
，若服务器确认可以接收并处理该请求，就会发送如下响应头：HTTP/1.1 100 Continue，注意返回的内容要加上CRLF字
符，客户端收到这个响应头之后就可以开始发送剩下的数据了，服务器只要继续读取输入流的内容就行了

Servlet容器：

	Tomcat中有4种类型的容器，分别是：Engine、Host、Context、Wrapper
	    Engine：表示整个Catalina servlet引擎
	    Host：表示包含有一个或多个Context容器的虚拟主机
	    Context：表示一个Seb应用程序，一个Context包含多个Wrapper
	    Wrapper：表示一个独立的servlet
	    它们都用接口表示，都继承了Container接口

	它们的继承关系：
	    4个接口继承自Container接口，然后每个接口有一个Standard实现类比如Engine的实现类就是StandardEngine
	，由于它们有一个共同的接口Container，为了减少重复代码，就创建了一个ContainerBase抽象类，实现了Container
	接口的常用方法，这样4个Standard实现类只要继承ContainerBase类就不用重复写来自Container接口的方法了

	子容器：
	    每个容器可以有0个或多个低层级的子容器，一个Engine可以包含多个Host，一个Host可以包含多个Context
，一个Context可以包含多个Wrapper，Wrapper由于是最低级，因此它无法包含子容器
	可以通过Container接口的addChild(Container child)方法来添加子容器
	可以通过Container接口的removeChild(Container child)方法删除子容器
	可以通过findChild(String name)方法来查找子容器
	可以通过Container[] findChildren()方法来获取所有子容器	

	    容器可以包含一些支持的组件，如载入器、记录器、管理器、领域和资源等，这些组件Container都提供了
	get和set方法将这些组件与容器相关联

	    Container接口的设计可以在部署应用时，Tomcat管理员可以通过编辑配置(server.xml)文件来决定使用哪
	种容器。这是通过引入容器中的管道(pipeline)和阀(valve)的集合实现的。

Container接口：

	所有的servlet容器必须要实现Container接口，Catalina中一共有4种类型的setvlet容器接口，它们都继承了Container：
	    Engine：表示整个Catalina servlet引擎
	    Host：表示包含有一个或多个Context容器的虚拟主机
	    Context：表示一个Web引用，可以包含多个Wrapper
	    Wrapper：表示一个servlet
	这几个容器由上而下，每个上级都能包含多个下级，由于Wrapper是最底层的容器，它无法包含子容器

	每种容器都有一个标准实现类，比如Engine接口的实现类就是StandardEngine，其它几个的命名规则也一样，由于每个实
现类都间接实现了Container接口，因此Container接口由ContainerBase抽象类实现了，这样4种容器的实现类只要继承ContainerBase
类，就不用各自重复实现Container接口的方法了

	Container接口的几个常用方法：
	    adChild(Container child)：添加一个容器
	    removeChild(Container child)：删除一个容器
	    findChild(String name)：根据name查找某个容器
	    findChildren()：返回所有的容器

	容器可以包含一些支持的组件，如载入器、记录器、管理器、领域和资源等，这些组件Container接口都提供了get和set
方法让它们与容器相关联，比如setManager、getManager、setResources、getResources等，并且Tomcat管理员可以通过编辑配置
文件(server.xml)来决定使用哪种容器。通过引入容器中的管道(pipeline)和阀(valve)的集合实现

管道Pipeline与Valve阀：

	管道和阀适用于所有的servlet容器
	
	一个管道包含该servlet容器将要调用的任务，而阀则是管道在执行要调用的具体任务，一个管道中有多个阀，管道就像是
过滤器链，而阀就是一个个过滤器，管道调用第一个阀，阀则调用它的下一个阀，在servlet容器的管道中，有一个基础阀，基础阀
总是最后一个执行，基础阀与其他阀是分开的，管道可以添加任意个数量的阀，他们放在同一个集合，而基础阀则放在额外的属性

	在HttpProcessor，会调用一个Container.invoke(req, resp)方法，这一步就是调用该容器的管道，而管道会去调用第一
个阀，并把Request、Response和管道对象一起传过去，在第一个阀调用完之后，会调用它的下一个，其实就是用指针指向集合中
的某个下标，一但到达最后一个元素，再调用的话就会调用基础阀

	前面说过，几种容器都会继承ContainerBase类来减少来自Container接口的重复代码，如果调用这个类的invoke方法，它
就会执行pipeline的invoke方法，而pipeline = StandardPipeline(this)，而StandardPipeline类的invoke方法则是new 一个它的
内部类StandardPipelineValveContext，并执行它的invokeNext方法，这个方法就会调用它所属外部对象的valves属性的第一个valve
，然后执行valve的invoce方法，并且把自身传过去，这样每个valve执行结束后都调用它的invokeNext方法就会执行每一个阀了
	流程：创建一个Container，用它的addValve方法添加阀，当HttpProcessor执行container.invoke的时候就会执行该容器
pipeline对象的invoke方法，而这个方法会执行第一个阀的invoce，并把自身传过去，只要后面的valve每次都会调用它的invokeNext
方法，他就会执行valves集合中的每一个阀，并且在valves执行到最后一个元素之后执行基础阀basic对象的invoke方法

	管道(实现了Pipeline)是容器的属性，而阀(valve)又是管道的属性，而阀容器(ValveContext)也是管道里的对象，用来
实现每个阀调用的流程，上面那个StandardPipelineValveContext，就是一个阀容器，调用第一个，然后把自己穿进去，然后每个
阀再调用阀容器的invokeNext，让阀容器来保证执行顺序

	管道的几个相关接口：

	    Pipeline：
		管道接口，定义了一些管理阀的方法，比如阀的增删改查

	    Valve：
		阀接口，有getInfo()和invoke(Requser, Response, ValveContext)方法

	    ValveContext：
		阀上下文接口，是管道用来执行阀的具体逻辑实现类，有getInfo(返回的是管道的info)和invokeNext方法

	    Contained：
		该接口的实现类可以通过它的方法与某个servlet容器关联，可以在在容器添加Valve的时候，判断他如果是Contained
	的子类，就把当前的容器调用它的setContained方法传进去，它有getContainerd和setContainer方法	    

Mapper：
	Mapper是映射器接口，
	

Wrapper接口(容器)：
	每个Wrapper容器都包含一个Servlet对象

Request、Response:
	HttpRequestImpl继承了HttpRequestBase，而HttpRequestBase实现了ServletRequest、Request、HttpRequest、HttpServletRequest
等接口其中ServletRequest和Reques是RequestBase实现的，了HttpRequestBase只是及继承了RequestBase，目前服务器中的HttpConnector
类的createRequest方法只会创建HttpRequestImpl类的对象，Response也一样创建一个HttpResponseImpl类的对象，体系跟Request
一样，在Valve中的invoke方法传递的都是Request和Response类型

Context接口(容器)：
	Context容器可以包含多个Wrapper容器，也就是包含多个Servlet对象，在启动的时候把Wrapper容器加入Context容器的
集合中作为子容器，并且在添加的时候把Context容器加入Wrapper容器的父容器中，这些方法Container接口都提供了

Lifecycle接口：
	Lifecycle接口是Tomcat中代表生命周期的接口，主要方法有start和stop方法，新的版本加了init和destory和getState、
getStateName等方法，还有addLifecycleListener、findLifecycleListeners、removeLifecycleListener等侦听器方法，这些方法
主要是让生命周期对实现了LifecycleListener侦听器接口的组件进行事件通知，增删查方法通常是固定的，一般通过LefecycleSupport
类的对象来实现就可以了，直接在Lifecycle实现类中创建一个LefecycleSupport对象，在内部使用这个对象调用相关方法就行了

	相关的类有LifecycleListener、LifecycleEvent，LifecycleListener是侦听器接口，只要实现了这个接口的实例都可以
用容器的addLifecycleListener方法添加到容器中，容器发布事件的时候就会遍历所有的侦听器接口的lifecycleEvent方法，并把
发布的事件对象传进去，而LifecycleEvent类就是事件类，要发布事件就要创建LifecycleEvent对象，并把相关信息放进去，比如
事件类型、事件数据、发布事件的生命周期对象等

	而LefecycleSupport则实现了了Lefecycle与生命周期事件相关的几个常用方法















注意：

	写服务器遇到的深坑：
	
	1、在header里写Content-Lenght的时候，可以写少，可以不写，但是不能写多，如果写多了，浏览器就会认为
数据没有读完，一直读，导致内容无法展示，而写少了会有什么影响还不知道，目前少了数据写少了也能完全展示，可
能是因为目前的数据一次性就读出来了，如果一次读不出来，而浏览器根据Content-Lenght认为已经读完了，可能就不
会再读了，造成数据缺失

	2、超级坑，由于socket在close之后read才会返回-1，因此这里会一直阻塞，直到刷新页面才会继续，因此前
面第二次刷新才会打印数据，因为客户端主动关闭了连接，因此也会返回-1；而并且不会输出数据是因为，客户端在刷
新页面后跳出了read循环，可是连接都关闭了这时候服务器在输出客户端也收不到，因此不会有输出。书上贼的很，就
读了一次1024字节的数据，而我根据以往的读取经验直接写了个循环一直读，自己坑自己。
	解决途径：1、约定结束标识
		  2、设置超时时长
		  3、在request的header中标注好数据长度，按照这个长度来读

	CRLF是回车换行的意思

























