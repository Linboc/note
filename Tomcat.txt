
对于每个请求，servlet会为其完成以下3个操作：

	1、创建一个request对象，servlet会把有可能用到的信息填充到request对象，如参数、头、cookie、查询字
符串、URI等，request对象是javax.servle.ServletRequest接口的示例

	2、创建一个response对象，response对象是javax.servlet.ServletResponse接口的实例
	
	3、调用Servlet的service()方法，将request和response对象作为参数传入


JavaWeb服务器的运行：

	Web服务器也成为超文本传输协议(HTTP)服务器，基于Java的Web服务器会使用两个重要的类：java.net.Socket
和java.net.ServerSocket类，并通过发送HTTP消息进行通信

	HTTP：
		HTTP是一种基于“请求-响应”的协议

	一个HTTP请求包含以下三个部分：

		1、请求方法 统一资源标识符(URI) 协议/版本
		    示例：POST /examples/default.jsp HTTP/1.0
		    请求方法会出现在请求的第一行
		    HTTP/1.1支持7种请求方法：GET、POST、HEAD、OPTIONS、PUT、DELETE、TRACE

		    URI指定Internet资源的完整路径，URI通常会被解释为相对于服务器根目录的相对路径，
		因此它总是以“/”开头，统一资源定位符(URL)实际上是URI的一种类型

		    URL和URI的区别，URI是唯一地标识了一个资源，而URL是为资源给定了一个唯一的定位，比如
		https://www.jianshu.com/index.html就是标志了index.html的定位，所以它是一个URL，而URL是URI
		的一种类型，因此它也算一个URI，因为通过这个定位也能唯一的标识这个资源，总结：URI就是能唯
		一地标识资源，不管用什么方式，能做到就是一个URI，而URL是一种实现，用定位的方式做到了唯一
		的标识资源

		    协议版本指明了当前请求使用的HTTP版本
				
		2、请求头

		    请求头包含的信息类似于key:value的方式，示例：
			Connection: Keep-Alive
			Host: localhost
			Conten-Length: 33
			Accept: text/plain; text/html
			User-Agent: Mozilla/4.0 (compatible; MSIE 4.01; Windows 98)
		    请求头包含客户端环境和请求体相关的信息。例如浏览器语言、请求体长度等，多个请求体直接
		用换行符隔开

		3、请求体
	
		    示例：agsnkjbdjkbk什么乱七八糟的都可以有
		    请求头和请求体之间有一个空行，这个空行告诉HTTP服务器请求体从哪里开始

	一个HTTP响应也分为三个部分：

		1、协议 状态码 描述
		    示例： HTTP/1.1 200 OK
		    
		2、响应头

		    也和请求类似示例：
			Server: Microsoft-IIS/4.0
			Date: Mon, 5 Jan 2004 13:13:33 GMT
			Content-Type: text/html
			Content-Length: 112

		3、响应体
		    示例：<html><body>hello world</body></html>
	
	把自己写的Request和Response实现ServletRequest和ServletResponse接口，然后在调用Servlet的service方
法的时候传进去，这样有个风险，因为传入的对象可以向下转型成Request和Response，而这两个对象中有一些方法并
不想让其它人调用，如parse和sendStaticResource方法，这时候用了外观模式，新建两个类RequestFacade和ResponseFacade
，他们也分别实现了ServletRequest和ServletResponse接口，并且它们的构造器需要一个参数，分别是ServletRequest
和ServletResponse接口的对象，其实传入的就是Request和Response对象，并把这个对象设为私有，他们只有ServletRequest
和ServletResponse接口的方法，外部每次调用它们的方法它们都会去用内部保存的那个变量去调用相关的方法，这样就
能做到保护parse和sendStaticResource方法了，外部无法调用，向下转型也只能转成Facade类

StringManage：

	Tomcat处理错误消息的方法是将错误消息存储在一个个properties文件中，并在程序出现错误的时候调用对应
的属性，这样把错误的提示信息放在properties文件中，方便管理，并且这些properties还是分包存储的，对应类的错
误文件都放在它的包下面，可以看到Tomcat很多包下面都有LocalStrings.properties文件，这就是它的错误消息文件了
，并且还可以在调用的时候传参数来达到动态消息的目的，示例代码：

	//获取HTTPServer.class包下的LocalStrings.properties文件，当然还可以通过传包名来获取，还可以根据语
	//言分不同文件，在文件名后面加"_"再加上语言名称，StringManager会用本地的默认语言去获取该文件，StringManager
	//对象是单例的，只有第一次获取在缓存中找不到才会去创建新的对象，缓存结构是一个HashTable
	StringManager manager = StringManager.getManager(HTTPServer.class);

	//第一个参数是要在该文件中获取的属性，后面的是可变参数，可以通过{0}、{1}...这种方式来插入参数，这
	//种动态参数是StringManager来处理的，把原始数据取出来，再自己根据参数进行格式化
	//比如：dataSourceLinkFactory.badWrapper=Not a wrapper for type {0}，结果就是Not a wrapper for type aaa
	manager.getString("dataSourceLinkFactory.badWrapper", "aaa");

	关于不同多语言的LocalStrings.properties，由于StringManager会通过Locale.getDefault去获取默认的语言
环境，比如是中国，就会去找LocalStrings_zh_ch.properties，找不到就去找通用的LocalStrings.properties，会优
先使用符合环境的，如果需要切换环境，就用Locale类的静态方法setDefault就可以了，通过这种方式实现多语言的错
误提示

	Tomcat通过这种方式进行提示信息的统一处理，并通过StringManager对象对这些信息进行操作

第三章简单服务器的执行流程：
	Bootstrap调用Connector，然后每一个Connector进来都调用Processor去创建Request和Response对象，并且从
InputStream中解析各种资源填充进对象里，如果请求的是Servlet，Processor就创建Servlet对象去调用service方法，
静态资源就直接返回

HTTP1.1的3个新特性：

	持久连接：

	    在HTTP1.1之前，无论浏览器何时连接到Web服务器，当服务器将请求的资源返回后，就会断开与浏览器的
连接。但是网页通常包含一些其它资源，比如图片、文件、applet等。因此，当请求一个页面时，浏览器还要下载这些
资源，如果每个不同的资源文件都用不同的连接进行下载的话，处理过程会很慢。这就是HTTP1.1引入持久连接的原因，
使用持久连接后，当下载了页面后，服务器不会立即关闭连接，它会等待Web客户端请求被该页面所引用的所有资源，这
样一来，页面和页面所引用的资源都会使用同一个连接来下载，考虑到建立/关闭HTTP连接是一个系统开销很大的操作，
使用同一个连接来下载会为Web服务器、客户端和网络节省很多时间和工作量
	如果使用HTTP1.1，就会默认使用持久连接。也可以在请求头中加显式地指定使用：connection: keep-alive

	块编码：

	    由于要使用一个连接发送多个资源，而客户端不知道每个资源从哪里开始到哪里结束，因此HTTP1.1使用了
块编码，来指明字节码会分块发送，对于每个块，最前面是块的长度，以16进制表示，然后是一个\r\n字符，然后是块
的内容，客户端不用管这个块的内容有多少，只要按照给定的长度读，读完之后就开始第二个块的长度读取，然后再读
\r\n，接着一直读完第二个块的长度，如果读到某个块的长度是0，那就说明这个事务已经完成，举个例子：

	1A\r\n				//说明这个块有26个字节
	aabb123654789zxcvasqwrgsz	//读完26个字节就开始准备下个块
	3\r\n				//第二个块有3个字节
	321				//读完第二个块，开始第三个
	0\r\n				//说明已经没了，事务结束

	    HTTP1.1的每个持久连接可能要按照请求的顺序去返回数据，否则就会把请求和响应的资源搞混，既然要
	保持顺序那每个持久连接就要用单线程了，这就是很多网站的资源时由上而下地一个个刷新出来的原因？
	    HTTP1.1可以用一个特殊的请求头“transfer-encoding”来指明字节流会分块发送

	状态码100：

	    客户端如果准备发送一个较大的资源给服务器，而不确定服务器是否会接受，如果直接发送，而服务器却
拒收时，可能会造成较大的浪费，因此客户端可以在向服务器发送请求体之前发送一个请求头：Expect: 100-continue
，若服务器确认可以接收并处理该请求，就会发送如下响应头：HTTP/1.1 100 Continue，注意返回的内容要加上CRLF字
符，客户端收到这个响应头之后就可以开始发送剩下的数据了，服务器只要继续读取输入流的内容就行了

Servlet容器：

	Tomcat中有4种类型的容器，分别是：Engine、Host、Context、Wrapper
	    Engine：表示整个Catalina servlet引擎
	    Host：表示包含有一个或多个Context容器的虚拟主机
	    Context：表示一个Seb应用程序，一个Context包含多个Wrapper
	    Wrapper：表示一个独立的servlet(可能同一个servlet有多个实例：STM servlet)
	    它们都用接口表示，都继承了Container接口

	它们的继承关系：
	    4个接口继承自Container接口，然后每个接口有一个Standard实现类比如Engine的实现类就是StandardEngine
	，由于它们有一个共同的接口Container，为了减少重复代码，就创建了一个ContainerBase抽象类，实现了Container
	接口的常用方法，这样4个Standard实现类只要继承ContainerBase类就不用重复写来自Container接口的方法了

	子容器：
	    每个容器可以有0个或多个低层级的子容器，一个Engine可以包含多个Host，一个Host可以包含多个Context
，一个Context可以包含多个Wrapper，Wrapper由于是最低级，因此它无法包含子容器
	可以通过Container接口的addChild(Container child)方法来添加子容器
	可以通过Container接口的removeChild(Container child)方法删除子容器
	可以通过findChild(String name)方法来查找子容器
	可以通过Container[] findChildren()方法来获取所有子容器	

	    容器可以包含一些支持的组件，如载入器、记录器、管理器、领域和资源等，这些组件Container都提供了
	get和set方法将这些组件与容器相关联

	    Container接口的设计可以在部署应用时，Tomcat管理员可以通过编辑配置(server.xml)文件来决定使用哪
	种容器。这是通过引入容器中的管道(pipeline)和阀(valve)的集合实现的。

Container接口：

	所有的servlet容器必须要实现Container接口，Catalina中一共有4种类型的setvlet容器接口，它们都继承了Container：
	    Engine：表示整个Catalina servlet引擎
	    Host：表示包含有一个或多个Context容器的虚拟主机
	    Context：表示一个Web引用，可以包含多个Wrapper
	    Wrapper：表示一个servlet
	这几个容器由上而下，每个上级都能包含多个下级，由于Wrapper是最底层的容器，它无法包含子容器

	每种容器都有一个标准实现类，比如Engine接口的实现类就是StandardEngine，其它几个的命名规则也一样，由于每个实
现类都间接实现了Container接口，因此Container接口由ContainerBase抽象类实现了，这样4种容器的实现类只要继承ContainerBase
类，就不用各自重复实现Container接口的方法了

	Container接口的几个常用方法：
	    adChild(Container child)：添加一个容器
	    removeChild(Container child)：删除一个容器
	    findChild(String name)：根据name查找某个容器
	    findChildren()：返回所有的容器

	容器可以包含一些支持的组件，如载入器、记录器、管理器、领域和资源等，这些组件Container接口都提供了get和set
方法让它们与容器相关联，比如setManager、getManager、setResources、getResources等，并且Tomcat管理员可以通过编辑配置
文件(server.xml)来决定使用哪种容器。通过引入容器中的管道(pipeline)和阀(valve)的集合实现

管道Pipeline与Valve阀：

	管道和阀适用于所有的servlet容器
	
	一个管道包含该servlet容器将要调用的任务，而阀则是管道在执行要调用的具体任务，一个管道中有多个阀，管道就像是
过滤器链，而阀就是一个个过滤器，管道调用第一个阀，阀则调用它的下一个阀，在servlet容器的管道中，有一个基础阀，基础阀
总是最后一个执行，基础阀与其他阀是分开的，管道可以添加任意个数量的阀，他们放在同一个集合，而基础阀则放在额外的属性

	在HttpProcessor，会调用一个Container.invoke(req, resp)方法，这一步就是调用该容器的管道，而管道会去调用第一
个阀，并把Request、Response和管道对象一起传过去，在第一个阀调用完之后，会调用它的下一个，其实就是用指针指向集合中
的某个下标，一但到达最后一个元素，再调用的话就会调用基础阀

	前面说过，几种容器都会继承ContainerBase类来减少来自Container接口的重复代码，如果调用这个类的invoke方法，它
就会执行pipeline的invoke方法，而pipeline = StandardPipeline(this)，而StandardPipeline类的invoke方法则是new 一个它的
内部类StandardPipelineValveContext，并执行它的invokeNext方法，这个方法就会调用它所属外部对象的valves属性的第一个valve
，然后执行valve的invoce方法，并且把自身传过去，这样每个valve执行结束后都调用它的invokeNext方法就会执行每一个阀了
	流程：创建一个Container，用它的addValve方法添加阀，当HttpProcessor执行container.invoke的时候就会执行该容器
pipeline对象的invoke方法，而这个方法会执行第一个阀的invoce，并把自身传过去，只要后面的valve每次都会调用它的invokeNext
方法，他就会执行valves集合中的每一个阀，并且在valves执行到最后一个元素之后执行基础阀basic对象的invoke方法

	管道(实现了Pipeline)是容器的属性，而阀(valve)又是管道的属性，而阀容器(ValveContext)也是管道里的对象，用来
实现每个阀调用的流程，上面那个StandardPipelineValveContext，就是一个阀容器，调用第一个，然后把自己穿进去，然后每个
阀再调用阀容器的invokeNext，让阀容器来保证执行顺序

	管道的几个相关接口：

	    Pipeline：
		管道接口，定义了一些管理阀的方法，比如阀的增删改查

	    Valve：
		阀接口，有getInfo()和invoke(Requser, Response, ValveContext)方法

	    ValveContext：
		阀上下文接口，是管道用来执行阀的具体逻辑实现类，有getInfo(返回的是管道的info)和invokeNext方法

	    Contained：
		该接口的实现类可以通过它的方法与某个servlet容器关联，可以在在容器添加Valve的时候，判断他如果是Contained
	的子类，就把当前的容器调用它的setContained方法传进去，它有getContainerd和setContainer方法	    

Mapper：
	Mapper是映射器接口，
	

Wrapper接口(容器)：
	每个Wrapper容器都包含一个Servlet对象

Request、Response:
	HttpRequestImpl继承了HttpRequestBase，而HttpRequestBase实现了ServletRequest、Request、HttpRequest、HttpServletRequest
等接口其中ServletRequest和Reques是RequestBase实现的，了HttpRequestBase只是及继承了RequestBase，目前服务器中的HttpConnector
类的createRequest方法只会创建HttpRequestImpl类的对象，Response也一样创建一个HttpResponseImpl类的对象，体系跟Request
一样，在Valve中的invoke方法传递的都是Request和Response类型

Context接口(容器)：
	Context容器可以包含多个Wrapper容器，也就是包含多个Servlet对象，在启动的时候把Wrapper容器加入Context容器的
集合中作为子容器，并且在添加的时候把Context容器加入Wrapper容器的父容器中，这些方法Container接口都提供了
	一个ServletContext会与一个Context容器相关联，相当于每个Context容器都有一个独立的ServletContext保存在它的context
变量中，它是ApplicationContext类型

Lifecycle接口：
	Lifecycle接口是Tomcat中代表生命周期的接口，主要方法有start和stop方法，新的版本加了init和destory和getState、
getStateName等方法，还有addLifecycleListener、findLifecycleListeners、removeLifecycleListener等侦听器方法，这些方法
主要是让生命周期对实现了LifecycleListener侦听器接口的组件进行事件通知，增删查方法通常是固定的，一般通过LefecycleSupport
类的对象来实现就可以了，直接在Lifecycle实现类中创建一个LefecycleSupport对象，在内部使用这个对象调用相关方法就行了

	相关的类有LifecycleListener、LifecycleEvent，LifecycleListener是侦听器接口，只要实现了这个接口的实例都可以
用容器的addLifecycleListener方法添加到容器中，容器发布事件的时候就会遍历所有的侦听器接口的lifecycleEvent方法，并把
发布的事件对象传进去，而LifecycleEvent类就是事件类，要发布事件就要创建LifecycleEvent对象，并把相关信息放进去，比如
事件类型、事件数据、发布事件的生命周期对象等

	而LefecycleSupport则实现了了Lefecycle与生命周期事件相关的几个常用方法

日志记录器：

	Logger接口：
	    Logger是Tomcat中的日志记录器接口

	Tomcat提供了3种日志记录器，分别是FileLogger、SystemErrorLogger、SysytemOutLogger，他们都继承了LoggerBase类
，而LoggerBase类实现了Logger接口，在Tomcat5中还实现了Lifecycle和MBeanRegistration接口，LoggerBase类有一个抽象方法log
没有实现，这个方法需要子类来实现

	verbosity：日志的等级，默认是ERROR，只有传入的日志等级的值小于当前日志等级才会执行对应方法，等级值越小错误
等级越高

SystemOutLogger：
	它重载的log方法就是使用System.out.prinln(msg)把传入的参数输出

SystemErrLogger：
	它重载的log方法就是使用System.err.prinln(msg)把传入的参数输出

FileLogger： 
	它重载的log方法每次打印日志都会获取最新的日期，如果date对象里保存的日期已经不是最新日期了，就关闭旧的文件流
，并更新date对象，打开新的流，新的文件流名称是prefix + date + suffix，boolean变量timestamp则是决定了是否在打印日志
时带上时间戳
	prefix和suffix属性，用来在生成文件日志时作为文件名的前后缀，date对象则记录了当前的日期，directory对象记录了
日志生成的文件夹
	它还实现了Lifecycle接口，并且针对PropertyChangeSupport对象，每次修改属性都会调用该属性侦听器的firePropertyChange
方法，把修改的属性名称、旧属性新属性传过去，并通知所有的到侦听器
	生命周期则在启动时把标志位started设置为true，并发布启动事件，在停止时发布停止事件，把标志位started设置为false
，关闭输出流
	使用方式，request和response对象可以获取到连接器，在创建连接器HttpRequestImpl对象时会调用它的setConnector方
法，而HttpProcessor对象也会通过构造器把连接器传进去，通过连接器可以获取到servlet容器，而容器里面就有getLogger方法
可以获取到日志记录器，可以通过这种方式使用日志记录器，不过如果给用户传一个HttpServletRequest对象，并且实际对象还是
个外观类，用户怎么获取到日志记录器就是个问题了


载入器：
	Java的类载入器：
	    java的类载入器有3种：
		引导类载入器：用于引导启动Java虚拟机，使用本地代码实现，调用javax.exe时就会启动引导类载入器，引导类
	    载入器从哪些库中搜索类取决于JVM和操作系统

		扩展类载入器：载入标准扩展目录中的类，只要将JAR文件复制到扩展目录中就能被扩展类载入器搜索到，扩展目
	    录依赖于JDK的供应商，Sun公司的JVM的标准扩展目录是/jdk/jrd/lib/ext

		系统类载入器：默认的类载入器，它会搜索环境变量CLASSPATH中指明的路径和JVR文件

		以上的载入器是父子继承关系，引导载入器-扩展载入器-系统载入器，系统载入器是最下层的

	JVM使用的载入器取决于类载入器的代理模型，代理模型会先调用系统类载入器，系统类载入器不会立即载入某个类，它会
把这个类交给父载入器载入，它的父载入器会继续把这个类给它的父载入器载入，直到最高级的引导类载入器，如果父载入器找到
了就用父载入器的，否则会回到下一层载入器去载入，一直往下，如果到最下级的载入器还是没找到这个类，就会抛出ClassNotFoundException
异常。这么做是为了解决类载入器过程中的安全性问题，比如安全管理器可以限制某个类对某个路径的访问，然而JVM是信任java.lang.Object
类的，它不会监视这个类的活动，允许它做任何事，如果恶意用户也编写了一个java.lang.Object类，并且被载入了，那么安全管
理就会被轻易绕过，而使用代理模型，这个类会被一直上交给引导类载入器去载入，而引导类载入器会搜索其核心库，找到标准的
java.lang.Object类，并将之实例化，这样自定义的java.lang.Object就不会被载入了

	因此如果有两个类的全类名一样，那么会使用哪个类取决于哪个类所在的类载入器级别更高，更高级别的载入器找到了一
个类，就不会去子载入器载入了

	可以通过继承抽象类java.lang.ClassLoader类编写自己的类载入器，而Tomcat要使用自定义类载入器的原因有以下几点：
	    1、为了在载入类中指定某些规则
	    2、为了缓存已经载入的类
	    3、为了实现类的预载入，方便使用

Loader接口：
	Loader接口一般跟一个Context容器配合，连接器会执行到Context容器invoke方法，直到调用管道的基础阀，Context容器
使用Mapper映射器找到Wrapper容器之后，执行Wrapper容器的invoke方法，Wrapper容器会执行它的管道，最后会执行它的基础阀，
这个基础阀会调用getLoader方法获取Loader对象，然后用Loader对象获得类加载器，获取的过程就是如果本容器的loader对象为空
就去父容器获取，一直往上。
	获取的类加载器其实是用它的loaderClass属性指定的类名创建一个对象， 目前是WebappClassLoader类，这个类是Tomcat
自定义的类加载器类，它继承了java.net.URLClassLoader类，并实现了Reloader和Lifecycle接口，这个类就是用来加载类的，而
Loader接口的实例，也就是WebappLoader类，它是直接被容器管理的一个Tomact加载器组件，它的声明周期start方法中做以下几
件事：
	1、发布启动事件
	2、设置启动标志位
	3、创建类加载器(就是内部真正加载类的classLoader对象)，并给其设置容器的resource和debug等相关属性
	4、把当前的所有已存在仓库加到classLoader中
	5、把容器的仓库(jar包和自己写的class文件)复制到servlet的仓库中
	6、保存所有类加载器(当前的和3个父的类加载器)的子路径字符串，并把这个字符串设置到servletContext的Attribute中
	7、如果使用了System.getSecurityManager()的话就设置访问权限，就是用classLoader对象设置某些路径的读写删权限
	    这样servlet使用这个classLoader就不能直接操作相关的资源了，只能访问指定的目录，比如/WEB-INF/classes/和/WEB-INF/lib/等
	8、调用classLoader的生命周期start方法
	9、如果开启了自动重新加载，也就是reloadable为true，就开一个线程就每隔checkInterval(本类一个属性)秒去调用类
	    加载器的modified方法检查一次path数组路径下的最后一次修改时间是否和保存起来的时间不一致，如果不一致就会
	    调用容器的reload方法进行冲加载

	classLoader会在每次找到资源的时候把它缓存起来，这样下次再去调用就会先去本地缓存找，如果没有就去上一层缓存找
如果都没有才调用系统的类载入器对类进行载入，在WebappClassLoder中会用resourceEntries对象保存类缓存，如果都没有找到
就会抛出ClassNotFoundException异常

Session管理组件：
	
Manager接口：
	这个接口表示Session管理器，Session管理器必须要与一个Context相关联，Session管理器负责创建、更新、销毁Session
对象，当有请求时，要会返回一个有效的Session对象

Session接口：
	每一个Session实例都代表一个Session，，Session接口在catalina中的标准实现类是StandardSession类，同样，Tomcat
不会直接把Session实例给Servlet实例使用，而是使用了一个StandardSessionFacade的外观类来给Servlet对象使用，他们都实现
了HttpSession接口，而StandardSession还实现了catalina的Session接口
	Session对象存在于Session管理器中，也就是Manager中，可以用setManager方法将Session实例和Session管理器相关联，
Session对象有一个唯一的标识符，可以通过setId和getId来访问Session 标识符，getLastAccessedTime方法用来判断一个Session
对象最后一次被访问的时间，通过这个时间判断其有效性，通过setValid和getValid访问有效性，每次访问Session实例都会调用
access方法修改Session对象的最后访问时间，getSession可以返回HttpSession对象，通过expire方法可以将Session对象设置为
过期
	StandardSession类的构造器必须要有一个Manager实例，因此Session对象必须与某个Manager实例关

	调用StandardSession的expire方法，会把这个Session对象的valid属性设置为flase也就是失效，然后把manage里的这个
session删掉，然后把这个session的属性清空，如果notify参数为true就会发布销毁事件，有自己的时间，还有给容器里的所有是
HttpSessionListener实例的侦听器发布Session销毁时间，并且把自己包装成HttpSessionEvent事件传进去，而expiring变量则说
明了这个Session是否正在销毁

	Manageer类的继承树：最上级的是Manager接口，它定义了对Session的创建销毁更新等抽象方法，下一级是ManagerBase抽
象类，它提供了很多通用的功能给子类使用，比如内部使用一个HashMap管理所有Session，提供了add、remove、findSessions等基
本实现，而BaseManagerBase下面则有两个子类，分别是StandardManage和PersistentManager，

	StandardManage会开一个线程定期的取检测所有过期的session，清除的间隔时间取决于它的maxInactiveInterval属性，
并调用已过期的session的expire方法进行过期处理,它会把Session保存在内存中

	PersistentManagerBase是所有持久化Session管理器的父类，它有两个子类，分别是PersistentManager和DistributedManage
，其中PersistentManager只是加了两个属性：name和info，并没有其它改动，DistributedManager则是可以用于集群的Session管
理器，多个不同Tomcat服务器上的DistributedManager可以互相复制session对象，它本身不提供接收和发送功能，而是通过catalina.cluster
包下的工具类来完成这些功能


存储器Store：

	存储器是org.apache.catalina.Store接口的实例，是为Session提供持久化的一个组件，它可以把传入的session删除，
它提供了类似Session管理器的功能，其中比较重要的两个方法是save和load，其中save是将传入的Session持久化到某个容器中，
load是将某个Session对象从持久化容器中载入到内存中，并返回，keys方法会以字符串数组的方式返回所有Session对象的标识符

StoreBase：
	Store有一个抽象子类StoreBase，这个类提供了一些基本功能；其实Tomcat中的结构基本都一样，一个接口，然后一个Base
子抽象类提供这个接口的基本功能，最后是由实现类提供剩下的不同功能，比如Manager-ManagerBase-StandardManage，而StoreBase
提供的就是：run方法周期性调用processExpires方法检测过期Session
	processExpires通过keys方法获取所有Session的标识符，然后挨个通过load方法用标识符获取StandardSession对象，然
后判断它最后一次使用的时间距离现在是否已经超过了maxInactiveInterval允许的范围属性，如果超过就对session对象执行清除
操作，如果是持久化Session管理器就进行回收，如果不是就进行过期，然后调用存储器的remove方法删除该Session

	在Tomcat5中，processExpires不会被StoreBase开线程调用了，而是ManagerBase的backgroundProcess方法周期性地对
processExpires进行调用

	StoreBase有两个子类，它们就是具体的实现类，分别是FileStore和JDBCStore

FileStore：
	FileStore类会将Session对象存储到某个文件中，文件名是session对象的标识符加上.session后缀，文件位于临时的工
作目录下，可以调用FileStore的setDirectory方法修改临时目录的位置，由于StoreBse中的save方法使用了ObjectOutPutStream
类对Session对象进行序列化，因此所有被储存的Session实例都必须实现Serizlizable序列化接口

JDBCStore：
	由于使用JDBC进行持久化，因此需要调用setDriverName和setConnectionURL方法来设置驱动和连接URL来连接数据库

安全性：

	领域Realm：
	    领域对象是用来对用户进行身份验证的组件，它会对用户输入的用户名和密码进行有效性判断。领域通常与一个Context
	容器相关联，一个Context只能关联一个领域对象。
	    领域对象保存了所有有效的用户名和密码，这些数据在Tomcat中默认存储在tomcat-user.xml文件中，也可以用其它领
	域对象的实现来使用其它资源验证用户身份，例如使用关系型数据库
	    在Catalina中，领域对象是Realm接口的实例有几个重载的authenticate方法用来验证身份，还有Container的set和get
	，hasRole等方法，Reaml接口的基本实现是RealmBase抽象类

	    Tomcat会使用一个验证阀来调用Realm接口的authenticate方法进行验证，如果验证不通过，这个阀就不会调用后续的
	阀，realm包提供了4个实现，分别是MemoryRealm、JDBCRealm、JNDIRealm、UserDatabaseRealm，默认使用的是MemoryRealm
	，它会在第一次被调用时去读取tomcat-user.xml中的内容


	主体Principal：
	    主体在Catalina中的实现是GenericPrincipal类，这个类必须和一个领域对象相关联，并且必须拥有用户名和密码，
	还有一个可选的角色列表，可以调用hasRole方法传入一个字符串来检查该主体是否拥有指定角色，主体就是一个用户


	登陆配置LoginConfig：
	    登陆的配置信息放在LoginConfig里面，它是一个final类，其中包含一个领域对象的名字，还有验证方法的名字，这
	决定了使用哪个领域对象的哪个验证方法进行验证，验证方法必须是BASIC、DIGEST、FORM、CLIENT-CERT之一，这和验证
	器的几个实现一一对应，在实际部署中，Tomcat会读取web.xml文件中login-config标签的内容创建一个LoginConfig对象，
	在它的loginPage和errorPage属性中还分别存储了登录页面和错误页面的URL

	Authenticator验证器：
	    验证器是Authenticator接口的实例，Authenticator接口本身没有声明方法，只是起到了一个标记的作用，这样其它
	组件就可以使用instanceof关键字检查某个组件是不是一个验证器
	    Catalina提供了一个验证器的基本实现：AuthenticatorBase类，除了实现验证器接口，它还继承了ValveBase类，也
	就是说AuthenticatorBase类还是一个阀。
	    在catalina.authenticator包下还有很多实现类，包括：
		BasicAuthenticator类：支持基本的身份验证
		FormAuthenticator类：基于表单的身份验证
		DigestAuthenticator类：基于信息摘要的身份验证
		SSLAuthenticator，对于SSL进行身份验证
		NonLoginAuthenticator类：Tomcat用户没有指定验证方法时，使用这个类进行身份验证，它只检查安全限制

	    验证器的工作主要是对用户进行身份验证，AuthenticatorBase类的invoke方法会调用领域的authenticate的抽象方
	法，具体的实现依赖Realm的子类
	    StandardContext类使用一个ContextConfig类来对StandardContext实例进行设置，这些设置包括一个验证器类
	
	    在启动context容器的时候把realm对象关联到容器中，然后连接每次被访问的时候都会调用领域对象的authenticate
	方法进行校验，realm对象内部具体的实现逻辑交给用户，可以从数据库中或者配置文件中读取用户，如果访问
	这个方法校验成功，就会把找到的用户与其角色信息封装成一个Principal对象返回去，否则返回null

StandardWrapper：

	Tomcat中的servlet的调用流程：
	    1、连接器接收到新连接
	    2、连接器创建request和response对象
	    3、连接器调用StandardContext实例的invoke()方法
	    4、StandardContext实例调用自己管道的invoke()方法，StandardContext实例管道的基础阀是
		StandardContextValve，因此会调用StandardContextValve实例的invoke()方法
	    5、StandardContextValve实例的invoke()方法通过映射器Mapper获取相应Wrapper实例，并调用它的
		invoke()方法
	    6、Wrapper的实现类一般是StandardWrapper，它的invoke()方法会调用其管道的invoce()方法
	    7、StandardWrapper实例调用自己管道的invoke()方法，StandardContext实例管道的基础阀是
		StandardWrapperValve，因此会调用StandardWrapperValve实例的invoke()方法
	    8、StandardWrapperValve实例的invoke()方法调用allocate()方法获取servlet实例
	    9、allocate()调用laod()方法载入相应servlet类，如果已经载入则无需重复载入
	    10、load()方法调用servlet实例的init方法
	    11、StandardWrapperValve用反射创建servlet实例，并并调用它的service()方法
	    
	StandardContext和StandardWrapper的基础阀都是在创建对象的时候在构造器里面添加的

	SingleThreadModel：
	    
	    servlet类可以实现javax.servlet.SingleThreadModel接口，这样的servlet类也称为SingleThreadModel
	(STM)servlet类，根据Servlet规范，实现此接口的目的是保证servlet实例一次只处理一个请求

	    如果Servlet类实现了这个接口，则可以保证不会有两个线程同时执行该Servlet实例的service()方法，这
	一点由Servlet容器通过控制对单一servlet实例的同步访问实现，为了提高执行性能，servlet容器会创建多个
	STM servlet实例，如果servlet实例需要访问静态变量或类之外的其它共享资源的话，还是有可能发生同步问题

	    由于SingleThreadModel会使servlet程序员误以为实现了该接口的servlet就是多线程安全你的，因此这个
	接口已经弃用了，但是还会提供支持

	    对于没有实现SingleThreadModel接口的servlet类，StandardWrapper只会载入该servlet一次，并对之后
	对这个servlet的请求都返回同一个实例，因为它假设该servlet类的service()方法在多线程环境中是线程安全
	的，如果有必要，由servlet程序员来负责处理同步的问题

	    而对于STM servlet类，StandardWrapper实例必须保证每个时刻只能有一个线程在执行STM servlet类的
	service()方法，如果只有一个STM servlet实例，那么每个servlet将同时只能处理一个请求，为了更好的性能
	，StandardWrapper实例会维护一个STM servlet实例池，其实就是一个Stack

	    获取非STM servlet的步骤：
		1、判断该servlet是否STM类
		2、如果不是STM类则判断StandardWrapper的instance属性是否为null
		3、如果不为null就返回instance
		4、如果为null就实例化一个servlet，然后放进instance属性中
		5、第4步使用单实例同步懒加载的方式，外面判断，然后用this加锁，里面再判断
		
	    获取STM servlet的步骤：
		1、如果上面的没有发生return就说明这是一个STM servlet
		2、如果当前总servlet数量少于正在使用的数量，就一直进行分配，如果总servlet数量已经达到maxInstances
		    了，那就进行阻塞，直到有某个servlet执行完毕进行回收才会唤醒，继续分配，如果确定有空闲
		    servlet，就从instancePool中pop出一个servlet返回
		3、所有的servlet都保存在Stack类型的instancePool属性中，里面的所有servlet都是空闲的
		4、每创建一个新的servlet，StandardWrapper对象的nInstances属性就+1
		5、每分配出一个servlet，countAllocated都会+1
		    总的STM servlet部分的逻辑就是，如果当前没有可用servlet就一直创建，如果已经到了可创建
		的最大数目，则阻塞，等待有servlet回收，一旦有可用的就出栈返回，判断可不可用的标准就是当前名
		总servlet数目是否比正在使用的servlet大

	创建servlet实例的步骤：
	    1、如果当前类的actualClass(目标servlet全类名)为空，并且jspFile不为空，那就去父容器(Context)中
		找到一个名称为jsp的Wrapper子容器,获取它的servletClass，否则就用当前Wrapper的servletClass
	    2、如果isContainerProvidedServlet(actualClass)返回true，就是用容器的ClassLoader，这样就能访问
		Catalina的内部数据了
	    3、实例化该servlet类
	    4、同isServletAllowed(servlet)判断该servlet是否可允许载入，这个方法判断，如果这个servlet类是
		ContainerServlet类的子类，那就必须是catalina的InvokerServlet类或者Context容器的getPrivileged
		返回true，如果满足就返回true，否则返回false,返回false就抛异常
	    5、如果这个servlet是catalina包中的servlet，那么会把当前的StandardWrapper放进servlet的wrapper
		属性中
	    6、然后就发布servlet初始化事件，然后调用servlet的init(servletConfig)方法，如果该servlet的jspFile
		为true，就会直接调用它的service()方法
	    7、如果该servlet是一个STM servlet，则判断servletPool是否为空，如果为空则为它创建一个Stack
	    8、记录日志
	    9、返回servlet实例

	ServletConfig：
	    servlet的init方法需要传入一个ServletConfig实例，这个ServletConfig其实就是StandardConfig本身，
	它同时实现了ServletConfig接口、Wrapper接口、Container接口、Lifecycle接口和Pipeline接口，不过后面
	3个接口都是通过继承ContainerBase抽象类来实现的，并且ContainerBase已经实现了除了getInfo之外的所有
	方法，StandardWrapper不会直接将自身传给init()方法，而是将用StandardWrapperFacade包装过的对象给init()

	    getServletContext()：
		它会返回StandardWrapper的父容器的servletContext属性，如果StandardWrapper没有父容器就返null

	    getServletName()：
		返回servlet类的名字

	    getInitParameter(String name)
		WtandardWrapper的初始化参数存储在一个HashMap类型的parameters属性中，这个方法就是从这个变
	    量中get一个值

	    getInitParameterNames()
		返回parameters的keys，包装成一个枚举类型Enumeration类，这个类就两个方法hasMoreElements和
	    nextElement
	
	    StandardWrapper类的父容器必须是Context的实现类，因为它的setParent会判断如果传入的Container不
	是Context的子类就会抛出异常

	StandardWrapperFacade：
	    由于StandardWrapper实例会调用servlet类的init方法，而它又想隐藏自己的大部分公开方法，因此使用
	这个类进行隐藏，StandardWrapperFacade也实现了ServletConfig接口，它的构造器需要一个StandardWrapper
	实例，然后每个实现都会使用StandardWrapper实例调用对应的方法
	    除了getServletContext()方法，这个方法会判断如果ServletContext是catalina包下的ApplicationContext
	类的实例的话，就会返回一个ApplicationContextFacade外观类

	StandardWrapperValve：
	    它的invoke()方法会去创建过滤器链：
	createFilterChain：
	    1、创建一个ApplicationFilterChain对象
	    2、获取Context容器中所有的FilterMap
	    3、使用请求的url去匹配所有的FilterMap，把所有能匹配上的FilterConfig都加入filterChain中
	        1、url为null直接返回false
	        2、filter的URLPattern为null也返回false
	        3、如果url.equals(URLPattern)为true就返回true
	        4、如果URLPattern等于/*就直接返回true
	        5、如果URLPattern以/*结尾，就用url的每个/前的路径加/*去用equals匹配，如果某次相等就返回true
	        6、如果URLPattern是以*.开头，就用*.加url最后一个.之后的字符用equals匹配，如果成功就返回true
	        7、否则返回false
	    4、用servletName去匹配所有的filterMap，如果filterMap的servletName属性等于当前这个StandardWrapper的servletName
	        就把这个filterConfig也加入到filterChain中
	    5、返回filterChain

	然后调用过滤器链和service()方法：
	    如果servlet和filterChain都不为null,就执行filterChain的doFilter方法，这个方法会用迭代器调用filterChain里
	每一个filterConfig，然后获取到filterConfig里的filter对象，再调用这个对象的doFilter方法，会把req和
	resp跟filterChain传进去，然后filter每次调用filterChain对象的doFilter方法都会持续的让它的filterConfig
	迭代器一直迭代下一个filter，直到所有的filterConfig都迭代完，如果继续调用就会调用servlet的service
	方法

	执行完所有的doFilter()和service()方法之后，就调用filterChain.release()方法对filterChain里的属性进行清除
	
	再然后就是StandardWrapper对servlet进行回收了，如果是普通的servlet，就直接把总分配servle数目-1就行了，如果
是STM servlet，除了对总分配servle数目-1，还要把servlet放回servlet池instancePool属性中，并唤醒线程，以便让没有分配
到servlet的请求继续获取servlet

	StandardContex只能添加FilterDef对象，这个对象定义了filter的类，和名称等信息，在StandardContext启动和reload
的时候，它会把这些FilterDef实例化成ApplicationFilterConfig对象，这个对象只需要一个Context容器和一个FilterDef对象就
能实例化，并且在实例化时会把FilterDef里的filter类实例化出来

	而FilterMap则是表示了在配置文件中对于Filter标签的定义，包含了filterClass、servletClass、urlPattern等属性

	FilterMap转成FilterDef再转成ApplicationFilterConfig

StandardContext：
	
	StandardContext的配置是在发布开始事件的时候由侦听器进行配置的，侦听器在配置好StandardContext之后，会把它的
	configured属性设置为true，在tomcat9中，又ContextConfig对Context进行配置，如果检测到启动时间是配置
开始，就会对Context进行配置

	下面是Context容器发布configure_start事件后ContextConfig会执行的代码片段：
	for (FilterDef filter : webxml.getFilters().values()) {
            if (filter.getAsyncSupported() == null) {
                filter.setAsyncSupported("false");
            }
            context.addFilterDef(filter);
        }

	StandardContext构造器：
	    添加基础阀StandardContextValve，并把自身传入到nameingResources的container中

	start()：
	    1、发布启动前事件
	    2、如果resources为null，则设置默认的resources：由docBase后缀决定FileDirContext或WARDirContext
	    3、如果loader为null，则这只默认的loader：WebappLoader
	    4、如果manager为null，则设置默认的manager：StandardManager
	    5、如果useNaming为true，就增加一个NamingContextListener侦听器
	    6、增加默认的servlet映射器：org.apache.catalina.core.StandardContextMapper
	    7、如果本类的组件实现了生命周期接口，就调用它们的start()方法
	    8、为所有实现了生命周期的Mapper调用start()方法，每个协议版本都有不同的Mapper
	    9、为所有实现了生命周期接口的子容器调用start方法
	    10、如果管道实现了生命周期接口，就调用它的start()方法
	    11、发布启动事件（监听器会执行一些配置操作）
	    12、如果session管理器实现了生命周期接口，就调用它的start()方法
	    13、实例化所有的侦听器
	    14、实例化所有的过滤器
	    15、根据wrapper容器的loadOnStartup属性的顺序，然后调用wrapper的load()方法，这个方法会载入servlet类和对象
	    15、发布启动后事件

	invoke()：
	    1、一直循环判断paused属性是否为true，如果为true就说明应用程序在重载，知道为false才跳出循环
	    2、执行管道的invoke()方法
	    3、tomcat5中将1放到了ContainerBase中执行了
	在新版本的tomcat中，不会再调用contarner的invoke()方法了，而是直接调用连接器-容器-管道-第一个阀(有其它阀就
返回其它阀，没有就返回基础阀)-invoke()方法，也就是直接调用连接器里的容器的阀的invoke()方法

	StandardContextMapper：
	    StandardContextMapper是StandardContextValve用来匹配Wrapper容器的映射组件

	StandardContextMapper：
	    StandardContextMapper是tomcat4中用来匹配请求和wrapper容器的，在ContainerBase的start()中会调用addDefaultMapper()
	方法，它会调用子类的这个方法，子类指定了mapper类是StandardContextMapper，然后这个context容器的映射器就会实
	例化为这个类，在后面匹配servlet的时候就会使用这个类的map方法，它会用请求的url去匹配servlet名称对应的映射，
	一但匹配到某个映射，就会去找这个映射对应的servlet名称(也是wrapper容器名称)，然后用这个名称去返回对应的wrapper
	容器，如果没匹配到就返回null

	新版本的映射组件是使用org.apache.catalina.mapper.Mapper类的public void map(Context context
, MessageBytes uri,MappingData mappingData)方法来进行匹配的，会把匹配到的wrapper放进mappingData的wrapper属性中,这个
方法有多个重载，分别对应了除了wrapper之外的所有容器

	重载：
	    StandardContext使用了reloadable属性来指明该应用程序是否启用重载功能，当启用了重载功能后，，当
	web.xml文件发生变化或者WEB-INF/classes目录下的文件被重新编译后，应用程序就会重载

	    StandardContext的重载功能是通过它的载入器实现的，它的载入器实现类是WebappLoader，这个类实现了
	Loader接口，它的setContainer()方法将WebappLoader对象与StandardContext类关联，这个方法会把Context
	容器的reloader属性传给它的reloader属性，因此它的这个属性是和容器一样的，如果启动了重载，它会用另
	外一个线程检查WEB-INF目录中的所有类和JAR文件的时间戳，如果与最后一次修改的时间不一致就会重新加载

	    在tomcat4中setContainer()方法会顺便判断传入的容器是不是Context容器，如果是，并且reloader属性
	为true就启动重载线程，如果reloader属性为false就打断线程；如果旧的reloader属性和新的一致，就啥也
	不用做，在这期间还有属性侦听器事件发布，在9.0.21版本setContext()方法不会再启动或打断线程了

	backgroundProcess()：
	    在Tomcat4中，Context容器运行需要其它组件的支持，比如Session管理器，Loader载入器，这些组件都会
	自己启动一个线程执行一些后台任务，比如Session管理器的Session对象过期时间，Loader的自动重载等功能
	，为了节省资源，在Tomcat5中，所有的后台处理共享同一个线程，若某个组件或者servlet容器需要周期性执
	行一个操作，只需要将代码写到其backgroundProcess()方法中就行了，在StandardContext的backgroundProcess()
	方法会调用所有组件的backgroundProcess()方法

	    9.0.21版本的tomcat中，这个方法会在Context容器的start()方法被调用时，启动一个线程不断地调用该
	容器与其子容器的backgroundProcess()，然后被调用的容器再调用自己组件的backgroundProcess()方法，该
	线程使用java的任务调度类ScheduledExecutorService不断调用ContainerBase的内部类ContainerBackgroundProcessor
	的run方法来执行

	    然后在WebappLoader的backgroundProcess()方法里，会判断如果reloader && modify()，如果返回true就
	调用重载方法reload()

Host容器：
	如果想在同一个Tomcat上部署多个Context容器的话，就需要使用Host容器了

	我觉得Eclipse里用的Tomcat用的就是Host容器，它会为每一个web应用配置一个路径，每一个web应用都是一个Context容
器，根据第一级路径找到对应的Context容器，再用后面的路径找Wrapper容器，它也有一个map方法传入uri去返回一个Context容
器，不过在新版本的Tomcat中，这些工作统一交给Mapper类去做了，会在传入的容器中找到匹配的子容器，把他们放到传入的mappingData
中去，这个对象可以存储除了Engine之外的所有容器，因为Engine是最高级别的容器，不会被其它容器所映射

	在StandardHost中，除了会在构造器中添加一个StandardHostValve基础阀之外，还会在start()方法中添加连个阀，分别
是ErrorDispatcherValue和ErrorReportValve，它们都会直接把管道链放过去，然后在管道执行完之后，会判断是否有异常信息，
如果有的话，并且isCommited返回false，就用response输出一些异常信息

	StandardHostMapper：
	    ContainerBase类会调用addDefaultMapper方法，这个方法会获取mapperClass变量来创建一个映射器，由于StandardHost
	类指定了mapperClass属性为StandardHostMapper，因此这个容器的映射器就是StandardHostMapper，这个映射器的map方
	法会调用host容器的map()方法，host容器的map()方法就是不断去掉最后一个/之后的内容，然后匹配子容器id，如果匹配
	到了就返回匹配到的Context容器

	StandardHostValve：
	    StandardHost的基础阀，它的invoke()方法会调用host容器的map取匹配请求的uri，如果没匹配到就直接返回，匹配
	到了就保存这个Context容器，然后尝试获取这个请求的sessionId，如果获取到了就去session管理器中找这个session,
	如果存在就并可用就更新它的状态，分别会更新isNew=false(这说明了这个session不是这一次新创建的）、上一次访问时
	间和最后一次访问时间，最后会执行找到的context容器的invoke()方法

	上面说的host容器的map方法需要传两个参数：request和update，这个方法定义在ContainerBase中，然后在这个map()中
又会去调用容器的Mapper组件的map()方法，这Mapper组件里面又会去调用与它关联的host容器的map()实现，这个map()就只需要
一个uri字符串就可以了

	Tomcat4必须要有一个Host容器，因为在ContextConfig类使用ApplicationContext解析web.xml的时候会获取Context容器
的父容器的信息，如果Context没有父容器就会出现异常，否则除非自己实现一个ContextConfig类，不过在新版本中没发现这样的
代码，甚至在ContextConfig类都没发现对ApplicationConfig的直接引用

Engine容器：
	
	StandardEngine：
	    StandardEngine同样会在构造器加一个基础阀：StandardEngineValve，它的addChild()方法只能添加Host容器，如果
	是非Host容器会抛异常，而它的setParent()方法调用直接会抛异常，以为它已经是最顶级的容器了

	StandardEngineValve：
	    它会调用StandardEngine容器的map()方法返回一个Host容器，然后调用Host容器的invoke()方法

服务器组件和服务组件：

	服务器组件：org.apache.catalina.Server接口
	    Server接口的实例表示Catalina的整个servlet引擎，囊括了所有的组件，它使用了一种统一的方法来启动
	和关闭整个系统，而不用分别对连接器和容器启动和关闭了

	    使用服务器组件时，它会启动其中所有的组件，然后就无期限的等待关闭命令，如果连接进来的socket发
	送了SHUTDOWN字符串，他就会关闭服务器并关闭所有组件，不过我看StandardServer的代码在停止后似乎没有
	关闭其他组件

	    shutdown属性保存了发送给Server实例关闭系统的命令，port属性定义了服务器组件会从哪个端口获取关
	闭命令，addService()方法为服务器添加组件，removeService()方法删除服务组件，findServices()返回所有
	服务器组件，initialize()方法包含在系统启动前执行的代码，所以服务器组件是启动一个单独的服务器来获
	取关闭指令的，默认端口号是8005

	StandardServer：
	    StandardServer是Server接口的标准实现，该类中的许多方法都与server.xml文件中的服务器配置有关
	
	    它有4个与生命周期有关的方法，分别是initialize()、start()、stop()、await()
		initialize()：
		    这个方法就是执行所有服务组件的initailize()方法，它有一个initailized属性来防止服务器组
		件被初始化两次，如果initailized属性等于true就会抛出异常
	
		start()：
		    跟initialize()方法类似，调用所有服务组件的start()方法，并且用一个started属性保证不会
		多次启动

		stop()：
		    也一样，调用所有服务组件的stop()方法，并且用一个started属性保证不会多次关闭

		await()：
		    await()会创建一个ServerSocket对象，监听8005端口，并在while循环中调用它的accept()方法
		，当在指定端口上接受到消息时，会比较收到的消息是否和关闭命令一样，如果一样跳出whilt循环，
		并关闭ServerSocket

	Service接口：
	    Service接口代表服务组件

	StandardService：
	    StandardService是Service接口的标准实现，它的initialize()方法用于初始化添加到其中的所有连接器，
	此外它的start()方法也可以启动连接器和容器，而stop()则停止所有连接器和容器
	    在Tomcat9中，它的initialize()和start()方法放在了ContainerBase类中，这个类会调用子类的initInternal()
	和startInternal()方法，它会在两个方法中启动和初始化容器、执行器、映射侦听器、连接器，而stopInternal()
	则会停止这些组件

	    StandardService有连接器和servlet容器，其中servlet容器只有一个，连接器则可以有多个，多个连接器
	可以为多种不同请求协议提供服务，比如分别处理HTTP和HTTPS请求，而Tomcat9中还加了映射器、执行器，并
	且限定了容器必须是Engine容器

	    setContainer()方法会关闭旧容器，启动新容器，然后发布属性改变事件，不过旧的版本考虑到改变新容
	器后，Service里连接器的关联连接器就不匹配了，会把所有连接器的容器重新设置，而新版本没有这一步，新
	版的连接器不关联容器了，直接关联一个Service对象，通过Service来关联实例，只要修改Service对象的容器
	就等于修改连接器的容器


	    addConnerctor()方法会添加一个连接器，并调用它的init()和start()方法，Tomcat9中就只调用start()
	方法了

	    removeConnerctor()方法跟addConnerctor()类似，不过调用的方法变成了stop()方法
	
	它有3个与生命周期有关的方法，分别是start()、stop()、initialize()，这三个方法在上面介绍过了
	    
	    使用了Server和Service之后，容器和连接器的启动停止就交给Server来做了，在Server的ServerSocket接
	收到停止命令之后，就会关闭ServerSocket，并在Bootstrap调用Server的stop()方法

	    SpringBoot使用Tomcat类的getServer()方法获取一个StandardServer，这个方法会把Server的port设置为
	-1，因此这个停止服务器不会启动

Digester库：
	
	Digester是一个开源库，它可以将XML文档中的元素转换成Java对象

	    Digester调用一些add方法都是添加一些规则，这些规则都是Rule接口的实现类，Digester会在遇到一些标签时，按
	照顺序调用这些标签的所有规则，比如如果先addObjectCreate，然后再addSetProperties，就会先创建对象，然后设置
	属性
	

	Digester有4个重载方法可以定义标签和类的映射关系，分别是：
	    addObjectCreate(String pattern, Class class)
		把pattern标签和class相关联
	    addObjectCreate(String pattern, String className)
		把pattern标签和className指定的全类名对应的类相关联
	    addObjectCreate(String pattern, String className, String attributeName)
		把pattern标签和它的attributeName属性指定的类相关联，如果这个属性不存在，则使用className，className
	    可以为null，这个属性是一个默认值

	addSetProperties(String pattern)：
	    这个方法可以指定为某个模式注入属性，比如addSetProperties(pattern)，如果碰到了这个标签，就会把这个标签
	的属性用set方法注入到java对象中，如果属性不存在则报错

	addCallMethod(String pattern, String methodName)：
	    这个方法会使遇到与该规则相关联的模式时调用内部栈最顶端对象的某个方法，注意，这里调用的是模式对应的对象
	，不是规则，如果有多个标签，也就是多个对象，则用最顶端的一个对象

	    虽然书上一直在说有一个栈保存所有规则，不过在添加规则的时候我只看到了一个HashMap和一个ArrayList，HashMap
	的key是pattern，value是一个Rule集合，也就是一个标签可以有多个规则，还有一个rules，保存了所有规则，必过在
	Digester确实有一个ArrayStack<Object> stack属性的栈，在调用Rule的begin和end方法时才会使用，应该是用来保存标
	签层级信息的
	
	addSetNext(String pattern, String method)
	    这个方法会指定，这个标签对应的对象会调用父对象的哪个方法把自己加进父对象中，将它们关联起来，比如是a/b
	，代表了a标签下的b标签，然后addB代表了a标签的addB方法，然后就会调用a.addB(b)把他们关联起来，这里的a和b标签
	会转成他们前面addObjectCreate()方法所指定的类的实例

	validating：
	    这个属性指明了是否要对XML文档进行有效性验证，默认值为false

	    最后调用Digester的parse方法，传入一个File，就能返回一个第一个addObjectCreate()的对象了,需要注意的是，
	调用子标签需要父标签/子标签，如果是子子标签，就是：父标签/子标签/子子标签

	Rule：
	    那几个add方法最终都会调用addRule()方法，将所有的模式与规则的关系保存起来

	RuleSet：
	    RuleSet可以封装Digester那一堆add、set方法，只要某个类继承了RuleSet类。其实继承RuleSetBase就行了，因为
	这个类有个getNamespaceURI()方法默认实现了，剩下的addRuleInstances()方法会把Digester对象传进来，然后把那一
	堆add、set放在这里就能封装起来了，只需要使用digester.addRuleSet()方法，在这里面就会调用addRuleInstances(this)
	方法，最终效果也一样，不过把复杂的映射封装在了RuleSet实现类中，接着digester.parse()就能返回对象了
	
	ContextConfig：
	    对于StandardContext容器，必须有一个监听器负责帮它设置configured变量为true，否则它无法启动，因为它在start()
	方法中发布配置开始事件后，会判断configured是否为true，如果不是则抛异常

	start()：
	    在ContextConfig收到启动事件时执行start()方法，start方法会执行两个类：
		defaultConfig()：
		    它会取到System.getProperty("catalina.base")路径下的conf/web.xml文件的输入流，然后用Digester.push
		把Context容器传进去，接着调用Digester的parse()方法把输入流传进去，就完成了解析，虽然会返回一个对象
		，不过由于它注入属性的是自己传入的Context，因此已经持有这个对象了
	
		applicationConfig()：
		    这个方法与defaultConfig类似，不过它读取的文件是ServletContext资源路径下的/WEB-INF/web.xml文件，
		也就是说，如果这个资源存在，就会覆盖前面conf/web.xml的配置

	    上面的两个配置程序都是用了由createDigester()方法创建的Digester对象，这个方法会在Digester创建好后用addRuleSet
	方法添加一个Tomcat定义好的WebRuleSet实例，这个类的addRuleInstances()方法定义了整个Context容器所需的标签和属
	性映射规则

	Tomcat8.5.31：
	    webConfig：
		它有两个xml文件需要配置：
		    globalWebXml：
			如果StandardContext.getDefaultWebXml()为空的话就使用：conf/web.xml,而路径则是它的getCatalinaBase()
		    方法返回的文件对象路径
		    hostWebXml
			如果Context容器的父容器不为空并且是Host的话，就调用Host.getConfigBaseFile()方法，然后获取
		    它的路径，和web.xml.default一起创建一个文件对象，如果为空就返回null

		上面两个配置都有缓存它们的修改时间，如果上次配置时的修改时间跟这次一样，就不会重新解析配置，而是直
	    接返回

			不过最终进行配置的还是通过getContextWebXmlSource()方法获取的ServletContext下的资源/WEB-INF/web.xml
		    文件，解析后会把所有属性都放到WebXml实例中，然后使用configureContext(WebXml webXml)方法一项项
		    地去设置Context容器的属性

	    如果Context容器的getIgnoreAnnotations()方法返回false的话，就执行下面的配置方法
		applicationAnnotationsConfig：
		    这个方法简单粗暴，直接WebAnnotationSet.loadApplicationAnnotations(context)，然后这个里面是3行
			loadApplicationListenerAnnotations(context);
			loadApplicationFilterAnnotations(context);
			loadApplicationServletAnnotations(context);
		    这几个方法分别会对Context容器里面定义的侦听器、过滤器和Servlet进行注解解析，每个类只要能被类加
		载器加载，都会调用以下几个方法：
		    loadClassAnnotation(context, clazz);
		    loadFieldsAnnotation(context, clazz);
		    loadMethodsAnnotation(context, clazz);
		    这几个方法的作用就是判断这个类、类的字段、类的方法上面有没有Servlet相关的注解，如果有的话，比如
		是Resource注解，就把它的value值挨个添加进context.getNamingResources()属性里面，它的value属性是个数
		组，所以会循环添加，会判断如果是基础数据类型就包装后放进addEnvironment()方法，如果是javax.xml.rpc.Service
		类型，就放进addService()方法，如果是javax.jms.Queue或javax.jms.Topic就放进addMessageDestinationRef()
		如果都不是就放进addResourceEnvRef()，这里只列举了部分注解，感兴趣可以去看WebAnnotationSet.addResource

关闭钩子：
	
	很多应用需要在用户关闭应用程序时做一些清理工作，但是用户有时不会按照推荐的方法关闭应用程序，比如
Tomcat的Server对象启动时，调用start()方法，然后逐个调用各个组件的start()方法，停止时也需要这样调用stop()
方法，如果直接在运行过程中关闭控制台，可能会发生一些意想不到的事

	Java提供了一种优雅的方法可以在关闭过程，这样就能在关闭过程执行一些代码了
	
	在java中虚拟机会对两类事件进行相应，然后执行关闭操作：
	    调用System.exit()方法或者最后一个非守护进程线程退出时，程序正常退出
	    用户突然强制虚拟机中断运行，例如按CTRL+C或者直接关闭Java程序

	在虚拟机执行关闭操作时，会经过以下两个阶段：
	    1、虚拟机启动所有已注册的关闭钩子，关闭钩子是先前通过Runtime类注册的线程，所有关闭钩子会并发执行
	    2、虚拟机调用所有没有被调用过的终结器(finalizer)

	创建关闭钩子：
	    1、创建一个Thread实现类
	    2、实现run()方法，虚拟机会调用这个方法
	    3、实例化关闭钩子类
	    4、使用Runtime类的getRuntime().addShutdownHook()方法注册关闭钩子
	总的来说救赎把线程实现类传进addShutdownHook()方法，虚拟机关闭时会并行调用所有被加进去的线程的run方法

	    需要注意的是，在Eclipse中，如果直接点击停止按钮或者在任务管理器中停掉程序，是无法触发关闭钩子的，必须
	使用System.exit()，或者程序自己结束才可以触发

	    在Tomcat中，在Catalina类的start()方法中，如果useShutdownHook属性为true则会注册一个CatalinaShutdownHook
	内部类进ShutdownHook中，这个类的run()方法会执行Server的stop()方法和destroy()方法，并且在触发关闭勾子后把自
	己注册钩子删掉

Tomcat启动：
	Catalina简介：
	    Catalina类用于启动或关闭Server对象，并负责解析Tomcat配置文件：server.xml

	Bootstrap简介：
	    Bootstrap类是一个入口点，负责创建Catalina实例，并调用其process()方法

	    这两个类理论上可以合并为一个，但为了支持Tomcat的多种运行模式而提供了多启动类，比如Bootstrap、BootstrapService
	，BootstrapService可以使Tomcat作为一个Windows NT服务来运行

	   为了让用户方便，Tomcat附带了批处理文件和Shell脚本，可以方便地启动或关闭servlet容器，在这些文件的帮助下，
	用户只需要运行相应的文件即可，批处理是给Windows用的，Shell是给linux用的

	Catalina：
	    Catalina是启动类，它包含一个Digester对象，用于解析位于%CATALINE_HOME%conf目录下的server.xml文件
	    
	    它的process(String args[])方法可以用参数来启动Tomcat，，在新版本中变成了load(String args[])方法

	    start()：
		调用load()从配置文件中解析出一个Server对象并初始化，然后调用这个server的start()、await()等方法
	    stop()：
		调用start()方法创建的server实例的stop()、destroy()方法
	    stopServer()：
		使用start()方法创建的server实例的属性创建一个Socket，然后发送server实例的下机命令

	Bootstrap：
	    它的main()方法会创建几个类加载器，然后把级别最高的类加载器用反射传入Catalina.setParentClassLoad()中，
	然后用反射调用有参数版Catalina.load()方法，并把自己main()方法传进来的的args[]传过去，最后调用start()方法

	    在它的静态初始化块中，如果catalina.base和catalina..home为null，就使用user.dir作为它们的路径，
	并创建相应的catalinaBaseFile和catalinaHomeFile，然后反把系统变量的那两个变量设置为user.dir，如果
	不为空就使用指定的

	批处理：
	    批处理文件的后缀名必须为.bat，
	
	命令：
	    rem：
		用于注释
	    pause：
		用于暂停，并提示用户按某个键，程序就会继续运行
	    echo：
		用于在DOC控制台显示一段文本，比如echo Hello World
	    环境变量：
		如果要使用环境变量，就在环境变量前后加上%，比如echo %OS%输出操作系统的名字
	    echo off：
		防止将批处理文件中的具体命令输出，不过echo off本身还是会输出
	    @echo off：
		和echo off类似，不过连echo off本身都会隐藏
	    set：
		设置用户定义的环境变量，在批处理中设置的环境变量是临时的，在批处理执行结束就会摧毁，使用：
	        set THE_VAR=hello，echo %THE_VAR%
	    label：
		使用冒号设置一个标签，然后将标签传递给goto命令，这样就会跳转到标签指定的位置比如：:start
	    goto;
		强制批处理跳转到指定标签所在的位置执行：
		echo start
		goto end
		echo runing
		:end
		echo end
		上面的例子就会跳过runing的部分，直接start就到end了
	    if：
		执行条件测试：
		if %myVar%==3 echo hello：如果%myVar%等于3，就输出hello
		exist：if exist c:\temp\myFile.txt goto start：如果myFile.txt存在，就跳转到start标签
		not：not可以对条件取反，比如if not %myVar%==3 echo hello就是%myVar%不等于3条件才成立
	    接收参数：
		可以给批处理传递参数，批处理文件中用%1、%2来决定引用第几个参数，比如批处理文件名是test.bat
		，使用test hello调用它，那么echo %1就会输出hello
	    检测是否附带参数：
		使用if "%1"==""，这样如果没有参数的话条件就会成立
	    shift：
		将参数向后移动一位，会将%2的参数给%1，%3的参数给%2，%1的参数给%0，现在%3的参数就失效了
	    call：
		用来调用另一条命令：call goto end
	    setLocal：
		修改环境变量的值，只在当前脚本中有效
	    endLocal：
		将setLocal修改的值改回原来的
	    start：
		打开一个新控制台，比如start "title" goto start，为新控制台指定一个名字，并传入一条要控制
		台执行的命令










注意：

	写服务器遇到的深坑：
	
	1、在header里写Content-Lenght的时候，可以写少，可以不写，但是不能写多，如果写多了，浏览器就会认为
数据没有读完，一直读，导致内容无法展示，而写少了会有什么影响还不知道，目前少了数据写少了也能完全展示，可
能是因为目前的数据一次性就读出来了，如果一次读不出来，而浏览器根据Content-Lenght认为已经读完了，可能就不
会再读了，造成数据缺失

	2、超级坑，由于socket在close之后read才会返回-1，因此这里会一直阻塞，直到刷新页面才会继续，因此前
面第二次刷新才会打印数据，因为客户端主动关闭了连接，因此也会返回-1；而并且不会输出数据是因为，客户端在刷
新页面后跳出了read循环，可是连接都关闭了这时候服务器在输出客户端也收不到，因此不会有输出。书上贼的很，就
读了一次1024字节的数据，而我根据以往的读取经验直接写了个循环一直读，自己坑自己。
	解决途径：1、约定结束标识
		  2、设置超时时长
		  3、在request的header中标注好数据长度，按照这个长度来读

	CRLF是回车换行的意思

    Connector类有个protocolHandler属性，这个属性的默认类是在protocolHandlerClassName中定义了，在Connector
执行startInternal()方法时就会执行它的start()方法，它的start()方法又会执行endpoint.start()，这个endpoint在
protocolHandler实例的构造器会传给父类构造器，也就是说endpoint是什么由protocolHandlerClassName来决定，然后
endpoint的start()方法又会执行bind()方法和startInternal()方法，其中bind()方法会创建服务器绑定地址等，
startInternal()方法会让服务器开始工作
    然后就是用线程池去等待连接进来执行了，比如Nio2Endpoint就会创建多个它的内部类Acceptor实例，每个实例都开
个线程去执行，实例的数量取决于它父类的acceptorThreadCount属性























