
对于每个请求，servlet会为其完成以下3个操作：

	1、创建一个request对象，servlet会把有可能用到的信息填充到request对象，如参数、头、cookie、查询字
符串、URI等，request对象是javax.servle.ServletRequest接口的示例

	2、创建一个response对象，response对象是javax.servlet.ServletResponse接口的实例
	
	3、调用Servlet的service()方法，将request和response对象作为参数传入


JavaWeb服务器的运行：

	Web服务器也成为超文本传输协议(HTTP)服务器，基于Java的Web服务器会使用两个重要的类：java.net.Socket
和java.net.ServerSocket类，并通过发送HTTP消息进行通信

	HTTP：
		HTTP是一种基于“请求-响应”的协议

	一个HTTP请求包含以下三个部分：

		1、请求方法 统一资源标识符(URI) 协议/版本
		    示例：POST /examples/default.jsp HTTP/1.0
		    请求方法会出现在请求的第一行
		    HTTP/1.1支持7种请求方法：GET、POST、HEAD、OPTIONS、PUT、DELETE、TRACE

		    URI指定Internet资源的完整路径，URI通常会被解释为相对于服务器根目录的相对路径，
		因此它总是以“/”开头，统一资源定位符(URL)实际上是URI的一种类型

		    URL和URI的区别，URI是唯一地标识了一个资源，而URL是为资源给定了一个唯一的定位，比如
		https://www.jianshu.com/index.html就是标志了index.html的定位，所以它是一个URL，而URL是URI
		的一种类型，因此它也算一个URI，因为通过这个定位也能唯一的标识这个资源，总结：URI就是能唯
		一地标识资源，不管用什么方式，能做到就是一个URI，而URL是一种实现，用定位的方式做到了唯一
		的标识资源

		    协议版本指明了当前请求使用的HTTP版本
				
		2、请求头

		    请求头包含的信息类似于key:value的方式，示例：
			Connection: Keep-Alive
			Host: localhost
			Conten-Length: 33
			Accept: text/plain; text/html
			User-Agent: Mozilla/4.0 (compatible; MSIE 4.01; Windows 98)
		    请求头包含客户端环境和请求体相关的信息。例如浏览器语言、请求体长度等，多个请求体直接
		用换行符隔开

		3、请求体
	
		    示例：agsnkjbdjkbk什么乱七八糟的都可以有
		    请求头和请求体之间有一个空行，这个空行告诉HTTP服务器请求体从哪里开始

	一个HTTP响应也分为三个部分：

		1、协议 状态码 描述
		    示例： HTTP/1.1 200 OK
		    
		2、响应头

		    也和请求类似示例：
			Server: Microsoft-IIS/4.0
			Date: Mon, 5 Jan 2004 13:13:33 GMT
			Content-Type: text/html
			Content-Length: 112

		3、响应体
		    示例：<html><body>hello world</body></html>
	
	把自己写的Request和Response实现ServletRequest和ServletResponse接口，然后在调用Servlet的service方
法的时候传进去，这样有个风险，因为传入的对象可以向下转型成Request和Response，而这两个对象中有一些方法并
不想让其它人调用，如parse和sendStaticResource方法，这时候用了外观模式，新建两个类RequestFacade和ResponseFacade
，他们也分别实现了ServletRequest和ServletResponse接口，并且它们的构造器需要一个参数，分别是ServletRequest
和ServletResponse接口的对象，其实传入的就是Request和Response对象，并把这个对象设为私有，他们只有ServletRequest
和ServletResponse接口的方法，外部每次调用它们的方法它们都会去用内部保存的那个变量去调用相关的方法，这样就
能做到保护parse和sendStaticResource方法了，外部无法调用，向下转型也只能转成Facade类

StringManage：

	Tomcat处理错误消息的方法是将错误消息存储在一个个properties文件中，并在程序出现错误的时候调用对应
的属性，这样把错误的提示信息放在properties文件中，方便管理，并且这些properties还是分包存储的，对应类的错
误文件都放在它的包下面，可以看到Tomcat很多包下面都有LocalStrings.properties文件，这就是它的错误消息文件了
，并且还可以在调用的时候传参数来达到动态消息的目的，示例代码：

	//获取HTTPServer.class包下的LocalStrings.properties文件，当然还可以通过传包名来获取，还可以根据语
	//言分不同文件，在文件名后面加"_"再加上语言名称，StringManager会用本地的默认语言去获取该文件，StringManager
	//对象是单例的，只有第一次获取在缓存中找不到才会去创建新的对象，缓存结构是一个HashTable
	StringManager manager = StringManager.getManager(HTTPServer.class);

	//第一个参数是要在该文件中获取的属性，后面的是可变参数，可以通过{0}、{1}...这种方式来插入参数，这
	//种动态参数是StringManager来处理的，把原始数据取出来，再自己根据参数进行格式化
	//比如：dataSourceLinkFactory.badWrapper=Not a wrapper for type {0}，结果就是Not a wrapper for type aaa
	manager.getString("dataSourceLinkFactory.badWrapper", "aaa");

	关于不同多语言的LocalStrings.properties，由于StringManager会通过Locale.getDefault去获取默认的语言
环境，比如是中国，就会去找LocalStrings_zh_ch.properties，找不到就去找通用的LocalStrings.properties，会优
先使用符合环境的，如果需要切换环境，就用Locale类的静态方法setDefault就可以了，通过这种方式实现多语言的错
误提示

	Tomcat通过这种方式进行提示信息的统一处理，并通过StringManager对象对这些信息进行操作

第三章简单服务器的执行流程：
	Bootstrap调用Connector，然后每一个Connector进来都调用Processor去创建Request和Response对象，并且从
InputStream中解析各种资源填充进对象里，如果请求的是Servlet，Processor就创建Servlet对象去调用service方法，
静态资源就直接返回

HTTP1.1的3个新特性：

	持久连接：

	    在HTTP1.1之前，无论浏览器何时连接到Web服务器，当服务器将请求的资源返回后，就会断开与浏览器的
连接。但是网页通常包含一些其它资源，比如图片、文件、applet等。因此，当请求一个页面时，浏览器还要下载这些
资源，如果每个不同的资源文件都用不同的连接进行下载的话，处理过程会很慢。这就是HTTP1.1引入持久连接的原因，
使用持久连接后，当下载了页面后，服务器不会立即关闭连接，它会等待Web客户端请求被该页面所引用的所有资源，这
样一来，页面和页面所引用的资源都会使用同一个连接来下载，考虑到建立/关闭HTTP连接是一个系统开销很大的操作，
使用同一个连接来下载会为Web服务器、客户端和网络节省很多时间和工作量
	如果使用HTTP1.1，就会默认使用持久连接。也可以在请求头中加显式地指定使用：connection: keep-alive

	块编码：

	    由于要使用一个连接发送多个资源，而客户端不知道每个资源从哪里开始到哪里结束，因此HTTP1.1使用了
块编码，来指明字节码会分块发送，对于每个块，最前面是块的长度，以16进制表示，然后是一个\r\n字符，然后是块
的内容，客户端不用管这个块的内容有多少，只要按照给定的长度读，读完之后就开始第二个块的长度读取，然后再读
\r\n，接着一直读完第二个块的长度，如果读到某个块的长度是0，那就说明这个事务已经完成，举个例子：

	1A\r\n				//说明这个块有26个字节
	aabb123654789zxcvasqwrgsz	//读完26个字节就开始准备下个块
	3\r\n				//第二个块有3个字节
	321				//读完第二个块，开始第三个
	0\r\n				//说明已经没了，事务结束

	    HTTP1.1的每个持久连接可能要按照请求的顺序去返回数据，否则就会把请求和响应的资源搞混，既然要
	保持顺序那每个持久连接就要用单线程了，这就是很多网站的资源时由上而下地一个个刷新出来的原因？
	    HTTP1.1可以用一个特殊的请求头“transfer-encoding”来指明字节流会分块发送

	状态码100：

	    客户端如果准备发送一个较大的资源给服务器，而不确定服务器是否会接受，如果直接发送，而服务器却
拒收时，可能会造成较大的浪费，因此客户端可以在向服务器发送请求体之前发送一个请求头：Expect: 100-continue
，若服务器确认可以接收并处理该请求，就会发送如下响应头：HTTP/1.1 100 Continue，注意返回的内容要加上CRLF字
符，客户端收到这个响应头之后就可以开始发送剩下的数据了，服务器只要继续读取输入流的内容就行了

Servlet容器：

	Tomcat中有4种类型的容器，分别是：Engine、Host、Context、Wrapper
	    Engine：表示整个Catalina servlet引擎
	    Host：表示包含有一个或多个Context容器的虚拟主机
	    Context：表示一个Seb应用程序，一个Context包含多个Wrapper
	    Wrapper：表示一个独立的servlet(可能同一个servlet有多个实例：STM servlet)
	    它们都用接口表示，都继承了Container接口

	它们的继承关系：
	    4个接口继承自Container接口，然后每个接口有一个Standard实现类比如Engine的实现类就是StandardEngine
	，由于它们有一个共同的接口Container，为了减少重复代码，就创建了一个ContainerBase抽象类，实现了Container
	接口的常用方法，这样4个Standard实现类只要继承ContainerBase类就不用重复写来自Container接口的方法了

	子容器：
	    每个容器可以有0个或多个低层级的子容器，一个Engine可以包含多个Host，一个Host可以包含多个Context
，一个Context可以包含多个Wrapper，Wrapper由于是最低级，因此它无法包含子容器
	可以通过Container接口的addChild(Container child)方法来添加子容器
	可以通过Container接口的removeChild(Container child)方法删除子容器
	可以通过findChild(String name)方法来查找子容器
	可以通过Container[] findChildren()方法来获取所有子容器	

	    容器可以包含一些支持的组件，如载入器、记录器、管理器、领域和资源等，这些组件Container都提供了
	get和set方法将这些组件与容器相关联

	    Container接口的设计可以在部署应用时，Tomcat管理员可以通过编辑配置(server.xml)文件来决定使用哪
	种容器。这是通过引入容器中的管道(pipeline)和阀(valve)的集合实现的。

Container接口：

	所有的servlet容器必须要实现Container接口，Catalina中一共有4种类型的setvlet容器接口，它们都继承了Container：
	    Engine：表示整个Catalina servlet引擎
	    Host：表示包含有一个或多个Context容器的虚拟主机
	    Context：表示一个Web引用，可以包含多个Wrapper
	    Wrapper：表示一个servlet
	这几个容器由上而下，每个上级都能包含多个下级，由于Wrapper是最底层的容器，它无法包含子容器

	每种容器都有一个标准实现类，比如Engine接口的实现类就是StandardEngine，其它几个的命名规则也一样，由于每个实
现类都间接实现了Container接口，因此Container接口由ContainerBase抽象类实现了，这样4种容器的实现类只要继承ContainerBase
类，就不用各自重复实现Container接口的方法了

	Container接口的几个常用方法：
	    adChild(Container child)：添加一个容器
	    removeChild(Container child)：删除一个容器
	    findChild(String name)：根据name查找某个容器
	    findChildren()：返回所有的容器

	容器可以包含一些支持的组件，如载入器、记录器、管理器、领域和资源等，这些组件Container接口都提供了get和set
方法让它们与容器相关联，比如setManager、getManager、setResources、getResources等，并且Tomcat管理员可以通过编辑配置
文件(server.xml)来决定使用哪种容器。通过引入容器中的管道(pipeline)和阀(valve)的集合实现

管道Pipeline与Valve阀：

	管道和阀适用于所有的servlet容器
	
	一个管道包含该servlet容器将要调用的任务，而阀则是管道在执行要调用的具体任务，一个管道中有多个阀，管道就像是
过滤器链，而阀就是一个个过滤器，管道调用第一个阀，阀则调用它的下一个阀，在servlet容器的管道中，有一个基础阀，基础阀
总是最后一个执行，基础阀与其他阀是分开的，管道可以添加任意个数量的阀，他们放在同一个集合，而基础阀则放在额外的属性

	在HttpProcessor，会调用一个Container.invoke(req, resp)方法，这一步就是调用该容器的管道，而管道会去调用第一
个阀，并把Request、Response和管道对象一起传过去，在第一个阀调用完之后，会调用它的下一个，其实就是用指针指向集合中
的某个下标，一但到达最后一个元素，再调用的话就会调用基础阀

	前面说过，几种容器都会继承ContainerBase类来减少来自Container接口的重复代码，如果调用这个类的invoke方法，它
就会执行pipeline的invoke方法，而pipeline = StandardPipeline(this)，而StandardPipeline类的invoke方法则是new 一个它的
内部类StandardPipelineValveContext，并执行它的invokeNext方法，这个方法就会调用它所属外部对象的valves属性的第一个valve
，然后执行valve的invoce方法，并且把自身传过去，这样每个valve执行结束后都调用它的invokeNext方法就会执行每一个阀了
	流程：创建一个Container，用它的addValve方法添加阀，当HttpProcessor执行container.invoke的时候就会执行该容器
pipeline对象的invoke方法，而这个方法会执行第一个阀的invoce，并把自身传过去，只要后面的valve每次都会调用它的invokeNext
方法，他就会执行valves集合中的每一个阀，并且在valves执行到最后一个元素之后执行基础阀basic对象的invoke方法

	管道(实现了Pipeline)是容器的属性，而阀(valve)又是管道的属性，而阀容器(ValveContext)也是管道里的对象，用来
实现每个阀调用的流程，上面那个StandardPipelineValveContext，就是一个阀容器，调用第一个，然后把自己穿进去，然后每个
阀再调用阀容器的invokeNext，让阀容器来保证执行顺序

	管道的几个相关接口：

	    Pipeline：
		管道接口，定义了一些管理阀的方法，比如阀的增删改查

	    Valve：
		阀接口，有getInfo()和invoke(Requser, Response, ValveContext)方法

	    ValveContext：
		阀上下文接口，是管道用来执行阀的具体逻辑实现类，有getInfo(返回的是管道的info)和invokeNext方法

	    Contained：
		该接口的实现类可以通过它的方法与某个servlet容器关联，可以在在容器添加Valve的时候，判断他如果是Contained
	的子类，就把当前的容器调用它的setContained方法传进去，它有getContainerd和setContainer方法	    

Mapper：
	Mapper是映射器接口，
	

Wrapper接口(容器)：
	每个Wrapper容器都包含一个Servlet对象

Request、Response:
	HttpRequestImpl继承了HttpRequestBase，而HttpRequestBase实现了ServletRequest、Request、HttpRequest、HttpServletRequest
等接口其中ServletRequest和Reques是RequestBase实现的，了HttpRequestBase只是及继承了RequestBase，目前服务器中的HttpConnector
类的createRequest方法只会创建HttpRequestImpl类的对象，Response也一样创建一个HttpResponseImpl类的对象，体系跟Request
一样，在Valve中的invoke方法传递的都是Request和Response类型

Context接口(容器)：
	Context容器可以包含多个Wrapper容器，也就是包含多个Servlet对象，在启动的时候把Wrapper容器加入Context容器的
集合中作为子容器，并且在添加的时候把Context容器加入Wrapper容器的父容器中，这些方法Container接口都提供了

Lifecycle接口：
	Lifecycle接口是Tomcat中代表生命周期的接口，主要方法有start和stop方法，新的版本加了init和destory和getState、
getStateName等方法，还有addLifecycleListener、findLifecycleListeners、removeLifecycleListener等侦听器方法，这些方法
主要是让生命周期对实现了LifecycleListener侦听器接口的组件进行事件通知，增删查方法通常是固定的，一般通过LefecycleSupport
类的对象来实现就可以了，直接在Lifecycle实现类中创建一个LefecycleSupport对象，在内部使用这个对象调用相关方法就行了

	相关的类有LifecycleListener、LifecycleEvent，LifecycleListener是侦听器接口，只要实现了这个接口的实例都可以
用容器的addLifecycleListener方法添加到容器中，容器发布事件的时候就会遍历所有的侦听器接口的lifecycleEvent方法，并把
发布的事件对象传进去，而LifecycleEvent类就是事件类，要发布事件就要创建LifecycleEvent对象，并把相关信息放进去，比如
事件类型、事件数据、发布事件的生命周期对象等

	而LefecycleSupport则实现了了Lefecycle与生命周期事件相关的几个常用方法

日志记录器：

	Logger接口：
	    Logger是Tomcat中的日志记录器接口

	Tomcat提供了3种日志记录器，分别是FileLogger、SystemErrorLogger、SysytemOutLogger，他们都继承了LoggerBase类
，而LoggerBase类实现了Logger接口，在Tomcat5中还实现了Lifecycle和MBeanRegistration接口，LoggerBase类有一个抽象方法log
没有实现，这个方法需要子类来实现

	verbosity：日志的等级，默认是ERROR，只有传入的日志等级的值小于当前日志等级才会执行对应方法，等级值越小错误
等级越高

SystemOutLogger：
	它重载的log方法就是使用System.out.prinln(msg)把传入的参数输出

SystemErrLogger：
	它重载的log方法就是使用System.err.prinln(msg)把传入的参数输出

FileLogger： 
	它重载的log方法每次打印日志都会获取最新的日期，如果date对象里保存的日期已经不是最新日期了，就关闭旧的文件流
，并更新date对象，打开新的流，新的文件流名称是prefix + date + suffix，boolean变量timestamp则是决定了是否在打印日志
时带上时间戳
	prefix和suffix属性，用来在生成文件日志时作为文件名的前后缀，date对象则记录了当前的日期，directory对象记录了
日志生成的文件夹
	它还实现了Lifecycle接口，并且针对PropertyChangeSupport对象，每次修改属性都会调用该属性侦听器的firePropertyChange
方法，把修改的属性名称、旧属性新属性传过去，并通知所有的到侦听器
	生命周期则在启动时把标志位started设置为true，并发布启动事件，在停止时发布停止事件，把标志位started设置为false
，关闭输出流
	使用方式，request和response对象可以获取到连接器，在创建连接器HttpRequestImpl对象时会调用它的setConnector方
法，而HttpProcessor对象也会通过构造器把连接器传进去，通过连接器可以获取到servlet容器，而容器里面就有getLogger方法
可以获取到日志记录器，可以通过这种方式使用日志记录器，不过如果给用户传一个HttpServletRequest对象，并且实际对象还是
个外观类，用户怎么获取到日志记录器就是个问题了


载入器：
	Java的类载入器：
	    java的类载入器有3种：
		引导类载入器：用于引导启动Java虚拟机，使用本地代码实现，调用javax.exe时就会启动引导类载入器，引导类
	    载入器从哪些库中搜索类取决于JVM和操作系统

		扩展类载入器：载入标准扩展目录中的类，只要将JAR文件复制到扩展目录中就能被扩展类载入器搜索到，扩展目
	    录依赖于JDK的供应商，Sun公司的JVM的标准扩展目录是/jdk/jrd/lib/ext

		系统类载入器：默认的类载入器，它会搜索环境变量CLASSPATH中指明的路径和JVR文件

		以上的载入器是父子继承关系，引导载入器-扩展载入器-系统载入器，系统载入器是最下层的

	JVM使用的载入器取决于类载入器的代理模型，代理模型会先调用系统类载入器，系统类载入器不会立即载入某个类，它会
把这个类交给父载入器载入，它的父载入器会继续把这个类给它的父载入器载入，直到最高级的引导类载入器，如果父载入器找到
了就用父载入器的，否则会回到下一层载入器去载入，一直往下，如果到最下级的载入器还是没找到这个类，就会抛出ClassNotFoundException
异常。这么做是为了解决类载入器过程中的安全性问题，比如安全管理器可以限制某个类对某个路径的访问，然而JVM是信任java.lang.Object
类的，它不会监视这个类的活动，允许它做任何事，如果恶意用户也编写了一个java.lang.Object类，并且被载入了，那么安全管
理就会被轻易绕过，而使用代理模型，这个类会被一直上交给引导类载入器去载入，而引导类载入器会搜索其核心库，找到标准的
java.lang.Object类，并将之实例化，这样自定义的java.lang.Object就不会被载入了

	因此如果有两个类的全类名一样，那么会使用哪个类取决于哪个类所在的类载入器级别更高，更高级别的载入器找到了一
个类，就不会去子载入器载入了

	可以通过继承抽象类java.lang.ClassLoader类编写自己的类载入器，而Tomcat要使用自定义类载入器的原因有以下几点：
	    1、为了在载入类中指定某些规则
	    2、为了缓存已经载入的类
	    3、为了实现类的预载入，方便使用

Loader接口：
	Loader接口一般跟一个Context容器配合，连接器会执行到Context容器invoke方法，直到调用管道的基础阀，Context容器
使用Mapper映射器找到Wrapper容器之后，执行Wrapper容器的invoke方法，Wrapper容器会执行它的管道，最后会执行它的基础阀，
这个基础阀会调用getLoader方法获取Loader对象，然后用Loader对象获得类加载器，获取的过程就是如果本容器的loader对象为空
就去父容器获取，一直往上。
	获取的类加载器其实是用它的loaderClass属性指定的类名创建一个对象， 目前是WebappClassLoader类，这个类是Tomcat
自定义的类加载器类，它继承了java.net.URLClassLoader类，并实现了Reloader和Lifecycle接口，这个类就是用来加载类的，而
Loader接口的实例，也就是WebappLoader类，它是直接被容器管理的一个Tomact加载器组件，它的声明周期start方法中做以下几
件事：
	1、发布启动事件
	2、设置启动标志位
	3、创建类加载器(就是内部真正加载类的classLoader对象)，并给其设置容器的resource和debug等相关属性
	4、把当前的所有已存在仓库加到classLoader中
	5、把容器的仓库(jar包和自己写的class文件)复制到servlet的仓库中
	6、保存所有类加载器(当前的和3个父的类加载器)的子路径字符串，并把这个字符串设置到servletContext的Attribute中
	7、如果使用了System.getSecurityManager()的话就设置访问权限，就是用classLoader对象设置某些路径的读写删权限
	    这样servlet使用这个classLoader就不能直接操作相关的资源了，只能访问指定的目录，比如/WEB-INF/classes/和/WEB-INF/lib/等
	8、调用classLoader的生命周期start方法
	9、如果开启了自动重新加载，也就是reloadable为true，就开一个线程就每隔checkInterval(本类一个属性)秒去调用类
	    加载器的modified方法检查一次path数组路径下的最后一次修改时间是否和保存起来的时间不一致，如果不一致就会
	    调用容器的reload方法进行冲加载

	classLoader会在每次找到资源的时候把它缓存起来，这样下次再去调用就会先去本地缓存找，如果没有就去上一层缓存找
如果都没有才调用系统的类载入器对类进行载入，在WebappClassLoder中会用resourceEntries对象保存类缓存，如果都没有找到
就会抛出ClassNotFoundException异常

Session管理组件：
	
Manager接口：
	这个接口表示Session管理器，Session管理器必须要与一个Context相关联，Session管理器负责创建、更新、销毁Session
对象，当有请求时，要会返回一个有效的Session对象

Session接口：
	每一个Session实例都代表一个Session，，Session接口在catalina中的标准实现类是StandardSession类，同样，Tomcat
不会直接把Session实例给Servlet实例使用，而是使用了一个StandardSessionFacade的外观类来给Servlet对象使用，他们都实现
了HttpSession接口，而StandardSession还实现了catalina的Session接口
	Session对象存在于Session管理器中，也就是Manager中，可以用setManager方法将Session实例和Session管理器相关联，
Session对象有一个唯一的标识符，可以通过setId和getId来访问Session 标识符，getLastAccessedTime方法用来判断一个Session
对象最后一次被访问的时间，通过这个时间判断其有效性，通过setValid和getValid访问有效性，每次访问Session实例都会调用
access方法修改Session对象的最后访问时间，getSession可以返回HttpSession对象，通过expire方法可以将Session对象设置为
过期
	StandardSession类的构造器必须要有一个Manager实例，因此Session对象必须与某个Manager实例关

	调用StandardSession的expire方法，会把这个Session对象的valid属性设置为flase也就是失效，然后把manage里的这个
session删掉，然后把这个session的属性清空，如果notify参数为true就会发布销毁事件，有自己的时间，还有给容器里的所有是
HttpSessionListener实例的侦听器发布Session销毁时间，并且把自己包装成HttpSessionEvent事件传进去，而expiring变量则说
明了这个Session是否正在销毁

	Manageer类的继承树：最上级的是Manager接口，它定义了对Session的创建销毁更新等抽象方法，下一级是ManagerBase抽
象类，它提供了很多通用的功能给子类使用，比如内部使用一个HashMap管理所有Session，提供了add、remove、findSessions等基
本实现，而BaseManagerBase下面则有两个子类，分别是StandardManage和PersistentManager，

	StandardManage会开一个线程定期的取检测所有过期的session，清除的间隔时间取决于它的maxInactiveInterval属性，
并调用已过期的session的expire方法进行过期处理,它会把Session保存在内存中

	PersistentManagerBase是所有持久化Session管理器的父类，它有两个子类，分别是PersistentManager和DistributedManage
，其中PersistentManager只是加了两个属性：name和info，并没有其它改动，DistributedManager则是可以用于集群的Session管
理器，多个不同Tomcat服务器上的DistributedManager可以互相复制session对象，它本身不提供接收和发送功能，而是通过catalina.cluster
包下的工具类来完成这些功能


存储器Store：

	存储器是org.apache.catalina.Store接口的实例，是为Session提供持久化的一个组件，它可以把传入的session删除，
它提供了类似Session管理器的功能，其中比较重要的两个方法是save和load，其中save是将传入的Session持久化到某个容器中，
load是将某个Session对象从持久化容器中载入到内存中，并返回，keys方法会以字符串数组的方式返回所有Session对象的标识符

StoreBase：
	Store有一个抽象子类StoreBase，这个类提供了一些基本功能；其实Tomcat中的结构基本都一样，一个接口，然后一个Base
子抽象类提供这个接口的基本功能，最后是由实现类提供剩下的不同功能，比如Manager-ManagerBase-StandardManage，而StoreBase
提供的就是：run方法周期性调用processExpires方法检测过期Session
	processExpires通过keys方法获取所有Session的标识符，然后挨个通过load方法用标识符获取StandardSession对象，然
后判断它最后一次使用的时间距离现在是否已经超过了maxInactiveInterval允许的范围属性，如果超过就对session对象执行清除
操作，如果是持久化Session管理器就进行回收，如果不是就进行过期，然后调用存储器的remove方法删除该Session

	在Tomcat5中，processExpires不会被StoreBase开线程调用了，而是ManagerBase的backgroundProcess方法周期性地对
processExpires进行调用

	StoreBase有两个子类，它们就是具体的实现类，分别是FileStore和JDBCStore

FileStore：
	FileStore类会将Session对象存储到某个文件中，文件名是session对象的标识符加上.session后缀，文件位于临时的工
作目录下，可以调用FileStore的setDirectory方法修改临时目录的位置，由于StoreBse中的save方法使用了ObjectOutPutStream
类对Session对象进行序列化，因此所有被储存的Session实例都必须实现Serizlizable序列化接口

JDBCStore：
	由于使用JDBC进行持久化，因此需要调用setDriverName和setConnectionURL方法来设置驱动和连接URL来连接数据库

安全性：

	领域Realm：
	    领域对象是用来对用户进行身份验证的组件，它会对用户输入的用户名和密码进行有效性判断。领域通常与一个Context
	容器相关联，一个Context只能关联一个领域对象。
	    领域对象保存了所有有效的用户名和密码，这些数据在Tomcat中默认存储在tomcat-user.xml文件中，也可以用其它领
	域对象的实现来使用其它资源验证用户身份，例如使用关系型数据库
	    在Catalina中，领域对象是Realm接口的实例有几个重载的authenticate方法用来验证身份，还有Container的set和get
	，hasRole等方法，Reaml接口的基本实现是RealmBase抽象类

	    Tomcat会使用一个验证阀来调用Realm接口的authenticate方法进行验证，如果验证不通过，这个阀就不会调用后续的
	阀，realm包提供了4个实现，分别是MemoryRealm、JDBCRealm、JNDIRealm、UserDatabaseRealm，默认使用的是MemoryRealm
	，它会在第一次被调用时去读取tomcat-user.xml中的内容


	主体Principal：
	    主体在Catalina中的实现是GenericPrincipal类，这个类必须和一个领域对象相关联，并且必须拥有用户名和密码，
	还有一个可选的角色列表，可以调用hasRole方法传入一个字符串来检查该主体是否拥有指定角色，主体就是一个用户


	登陆配置LoginConfig：
	    登陆的配置信息放在LoginConfig里面，它是一个final类，其中包含一个领域对象的名字，还有验证方法的名字，这
	决定了使用哪个领域对象的哪个验证方法进行验证，验证方法必须是BASIC、DIGEST、FORM、CLIENT-CERT之一，这和验证
	器的几个实现一一对应，在实际部署中，Tomcat会读取web.xml文件中login-config标签的内容创建一个LoginConfig对象，
	在它的loginPage和errorPage属性中还分别存储了登录页面和错误页面的URL

	Authenticator验证器：
	    验证器是Authenticator接口的实例，Authenticator接口本身没有声明方法，只是起到了一个标记的作用，这样其它
	组件就可以使用instanceof关键字检查某个组件是不是一个验证器
	    Catalina提供了一个验证器的基本实现：AuthenticatorBase类，除了实现验证器接口，它还继承了ValveBase类，也
	就是说AuthenticatorBase类还是一个阀。
	    在catalina.authenticator包下还有很多实现类，包括：
		BasicAuthenticator类：支持基本的身份验证
		FormAuthenticator类：基于表单的身份验证
		DigestAuthenticator类：基于信息摘要的身份验证
		SSLAuthenticator，对于SSL进行身份验证
		NonLoginAuthenticator类：Tomcat用户没有指定验证方法时，使用这个类进行身份验证，它只检查安全限制

	    验证器的工作主要是对用户进行身份验证，AuthenticatorBase类的invoke方法会调用领域的authenticate的抽象方
	法，具体的实现依赖Realm的子类
	    StandardContext类使用一个ContextConfig类来对StandardContext实例进行设置，这些设置包括一个验证器类
	
	    在启动context容器的时候把realm对象关联到容器中，然后连接每次被访问的时候都会调用领域对象的authenticate
	方法进行校验，realm对象内部具体的实现逻辑交给用户，可以从数据库中或者配置文件中读取用户，如果访问
	这个方法校验成功，就会把找到的用户与其角色信息封装成一个Principal对象返回去，否则返回null

StandardWrapper：

	Tomcat中的servlet的调用流程：
	    1、连接器接收到新连接
	    2、连接器创建request和response对象
	    3、连接器调用StandardContext实例的invoke()方法
	    4、StandardContext实例调用自己管道的invoke()方法，StandardContext实例管道的基础阀是
		StandardContextValve，因此会调用StandardContextValve实例的invoke()方法
	    5、StandardContextValve实例的invoke()方法通过映射器Mapper获取相应Wrapper实例，并调用它的
		invoke()方法
	    6、Wrapper的实现类一般是StandardWrapper，它的invoke()方法会调用其管道的invoce()方法
	    7、StandardWrapper实例调用自己管道的invoke()方法，StandardContext实例管道的基础阀是
		StandardWrapperValve，因此会调用StandardWrapperValve实例的invoke()方法
	    8、StandardWrapperValve实例的invoke()方法调用allocate()方法获取servlet实例
	    9、allocate()调用laod()方法载入相应servlet类，如果已经载入则无需重复载入
	    10、load()方法调用servlet实例的init方法
	    11、StandardWrapperValve用反射创建servlet实例，并并调用它的service()方法
	    
	StandardContext和StandardWrapper的基础阀都是在创建对象的时候在构造器里面添加的

	SingleThreadModel：
	    
	    servlet类可以实现javax.servlet.SingleThreadModel接口，这样的servlet类也称为SingleThreadModel
	(STM)servlet类，根据Servlet规范，实现此接口的目的是保证servlet实例一次只处理一个请求

	    如果Servlet类实现了这个接口，则可以保证不会有两个线程同时执行该Servlet实例的service()方法，这
	一点由Servlet容器通过控制对单一servlet实例的同步访问实现，为了提高执行性能，servlet容器会创建多个
	STM servlet实例，如果servlet实例需要访问静态变量或类之外的其它共享资源的话，还是有可能发生同步问题

	    由于SingleThreadModel会使servlet程序员误以为实现了该接口的servlet就是多线程安全你的，因此这个
	接口已经弃用了，但是还会提供支持

	    对于没有实现SingleThreadModel接口的servlet类，StandardWrapper只会载入该servlet一次，并对之后
	对这个servlet的请求都返回同一个实例，因为它假设该servlet类的service()方法在多线程环境中是线程安全
	的，如果有必要，由servlet程序员来负责处理同步的问题

	    而对于STM servlet类，StandardWrapper实例必须保证每个时刻只能有一个线程在执行STM servlet类的
	service()方法，如果只有一个STM servlet实例，那么每个servlet将同时只能处理一个请求，为了更好的性能
	，StandardWrapper实例会维护一个STM servlet实例池，其实就是一个Stack

	    获取非STM servlet的步骤：
		1、判断该servlet是否STM类
		2、如果不是STM类则判断StandardWrapper的instance属性是否为null
		3、如果不为null就返回instance
		4、如果为null就实例化一个servlet，然后放进instance属性中
		5、第4步使用单实例同步懒加载的方式，外面判断，然后用this加锁，里面再判断
		
	    获取STM servlet的步骤：
		1、如果上面的没有发生return就说明这是一个STM servlet
		2、如果当前总servlet数量少于正在使用的数量，就一直进行分配，如果总servlet数量已经达到maxInstances
		    了，那就进行阻塞，直到有某个servlet执行完毕进行回收才会唤醒，继续分配，如果确定有空闲
		    servlet，就从instancePool中pop出一个servlet返回
		3、所有的servlet都保存在Stack类型的instancePool属性中，里面的所有servlet都是空闲的
		4、每创建一个新的servlet，StandardWrapper对象的nInstances属性就+1
		5、每分配出一个servlet，countAllocated都会+1
		    总的STM servlet部分的逻辑就是，如果当前没有可用servlet就一直创建，如果已经到了可创建
		的最大数目，则阻塞，等待有servlet回收，一旦有可用的就出栈返回，判断可不可用的标准就是当前名
		总servlet数目是否比正在使用的servlet大

	创建servlet实例的步骤：
	    1、如果当前类的actualClass(目标servlet全类名)为空，并且jspFile不为空，那就去父容器(Context)中
		找到一个名称为jsp的Wrapper子容器,获取它的servletClass，否则就用当前Wrapper的servletClass
	    2、如果isContainerProvidedServlet(actualClass)返回true，就是用容器的ClassLoader，这样就能访问
		Catalina的内部数据了
	    3、实例化该servlet类
	    4、同isServletAllowed(servlet)判断该servlet是否可允许载入，这个方法判断，如果这个servlet类是
		ContainerServlet类的子类，那就必须是catalina的InvokerServlet类或者Context容器的getPrivileged
		返回true，如果满足就返回true，否则返回false,返回false就抛异常
	    5、如果这个servlet是catalina包中的servlet，那么会把当前的StandardWrapper放进servlet的wrapper
		属性中
	    6、然后就发布servlet初始化事件，然后调用servlet的init(servletConfig)方法，如果该servlet的jspFile
		为true，就会直接调用它的service()方法
	    7、如果该servlet是一个STM servlet，则判断servletPool是否为空，如果为空则为它创建一个Stack
	    8、记录日志
	    9、返回servlet实例

	ServletConfig：
	    servlet的init方法需要传入一个ServletConfig实例，这个ServletConfig其实就是StandardConfig本身，
	它同时实现了ServletConfig接口、Wrapper接口、Container接口、Lifecycle接口和Pipeline接口，不过后面
	3个接口都是通过继承ContainerBase抽象类来实现的，并且ContainerBase已经实现了除了getInfo之外的所有
	方法，StandardWrapper不会直接将自身传给init()方法，而是将用StandardWrapperFacade包装过的对象给init()

	    getServletContext()：
		它会返回StandardWrapper的父容器的servletContext属性，如果StandardWrapper没有父容器就返null

	    getServletName()：
		返回servlet类的名字

	    getInitParameter(String name)
		WtandardWrapper的初始化参数存储在一个HashMap类型的parameters属性中，这个方法就是从这个变
	    量中get一个值

	    getInitParameterNames()
		返回parameters的keys，包装成一个枚举类型Enumeration类，这个类就两个方法hasMoreElements和
	    nextElement
	
	    StandardWrapper类的父容器必须是Context的实现类，因为它的setParent会判断如果传入的Container不
	是Context的子类就会抛出异常

	StandardWrapperFacade：
	    由于StandardWrapper实例会调用servlet类的init方法，而它又想隐藏自己的大部分公开方法，因此使用
	这个类进行隐藏，StandardWrapperFacade也实现了ServletConfig接口，它的构造器需要一个StandardWrapper
	实例，然后每个实现都会使用StandardWrapper实例调用对应的方法
	    除了getServletContext()方法，这个方法会判断如果ServletContext是catalina包下的ApplicationContext
	类的实例的话，就会返回一个ApplicationContextFacade外观类

	StandardWrapperValve：
	    它的invoke()方法会去创建过滤器链：
	createFilterChain：
	    1、创建一个ApplicationFilterChain对象
	    2、获取Context容器中所有的FilterMap
	    3、使用请求的url去匹配所有的FilterMap，把所有能匹配上的FilterConfig都加入filterChain中
	        1、url为null直接返回false
	        2、filter的URLPattern为null也返回false
	        3、如果url.equals(URLPattern)为true就返回true
	        4、如果URLPattern等于/*就直接返回true
	        5、如果URLPattern以/*结尾，就用url的每个/前的路径加/*去用equals匹配，如果某次相等就返回true
	        6、如果URLPattern是以*.开头，就用*.加url最后一个.之后的字符用equals匹配，如果成功就返回true
	        7、否则返回false
	    4、用servletName去匹配所有的filterMap，如果filterMap的servletName属性等于当前这个StandardWrapper的servletName
	        就把这个filterConfig也加入到filterChain中
	    5、返回filterChain

	然后调用过滤器链和service()方法：
	    如果servlet和filterChain都不为null,就执行filterChain的doFilter方法，这个方法会用迭代器调用filterChain里
	每一个filterConfig，然后获取到filterConfig里的filter对象，再调用这个对象的doFilter方法，会把req和
	resp跟filterChain传进去，然后filter每次调用filterChain对象的doFilter方法都会持续的让它的filterConfig
	迭代器一直迭代下一个filter，直到所有的filterConfig都迭代完，如果继续调用就会调用servlet的service
	方法

	执行完所有的doFilter()和service()方法之后，就调用filterChain.release()方法对filterChain里的属性进行清除
	
	再然后就是StandardWrapper对servlet进行回收了，如果是普通的servlet，就直接把总分配servle数目-1就行了，如果
是STM servlet，除了对总分配servle数目-1，还要把servlet放回servlet池instancePool属性中，并唤醒线程，以便让没有分配
到servlet的请求继续获取servlet

	StandardContex只能添加FilterDef对象，这个对象定义了filter的类，和名称等信息，在StandardContext启动和reload
的时候，它会把这些FilterDef实例化成ApplicationFilterConfig对象，这个对象只需要一个Context容器和一个FilterDef对象就
能实例化，并且在实例化时会把FilterDef里的filter类实例化出来

	而FilterMap则是表示了在配置文件中对于Filter标签的定义，包含了filterClass、servletClass、urlPattern等属性

	FilterMap转成FilterDef再转成ApplicationFilterConfig

StandardContext：
	
	StandardContext的配置是在发布开始事件的时候由侦听器进行配置的，侦听器在配置好StandardContext之后，会把它的
configured属性设置为true

	StandardContext构造器：
	    添加基础阀StandardContextValve，并把自身传入到nameingResources的container中

	start()：
	    1、发布启动前事件
	    2、如果resources为null，则设置默认的resources：由docBase后缀决定FileDirContext或WARDirContext
	    3、如果loader为null，则这只默认的loader：WebappLoader
	    4、如果manager为null，则设置默认的manager：StandardManager
	    5、如果useNaming为true，就增加一个NamingContextListener侦听器
	    6、增加默认的servlet映射器：org.apache.catalina.core.StandardContextMapper
	    7、如果本类的组件实现了生命周期接口，就调用它们的start()方法
	    8、为所有实现了生命周期的Mapper调用start()方法，每个协议版本都有不同的Mapper
	    9、为所有实现了生命周期接口的子容器调用start方法
	    10、如果管道实现了生命周期接口，就调用它的start()方法
	    11、发布启动事件（监听器会执行一些配置操作）
	    12、如果session管理器实现了生命周期接口，就调用它的start()方法
	    13、实例化所有的侦听器
	    14、实例化所有的过滤器
	    15、根据wrapper容器的loadOnStartup属性的顺序，然后调用wrapper的load()方法，这个方法会载入servlet类和对象
	    15、发布启动后事件

	invoke()：
	    1、一直循环判断paused属性是否为true，如果为true就说明应用程序在重载，知道为false才跳出循环
	    2、执行管道的invoke()方法
	    3、tomcat5中将1放到了ContainerBase中执行了
	在新版本的tomcat中，不会再调用contarner的invoke()方法了，而是直接调用连接器-容器-管道-第一个阀(有其它阀就
返回其它阀，没有就返回基础阀)-invoke()方法，也就是直接调用连接器里的容器的阀的invoke()方法

	StandardContextMapper：
		StandardContextValve用来匹配Wrapper容器的映射组件


	新版本的request和wrapper匹配是使用org.apache.catalina.mapper.Mapper类的public void map(Context context
, MessageBytes uri,MappingData mappingData)方法来进行匹配的，会把匹配到的wrapper放进mappingData的wrapper属性中





注意：

	写服务器遇到的深坑：
	
	1、在header里写Content-Lenght的时候，可以写少，可以不写，但是不能写多，如果写多了，浏览器就会认为
数据没有读完，一直读，导致内容无法展示，而写少了会有什么影响还不知道，目前少了数据写少了也能完全展示，可
能是因为目前的数据一次性就读出来了，如果一次读不出来，而浏览器根据Content-Lenght认为已经读完了，可能就不
会再读了，造成数据缺失

	2、超级坑，由于socket在close之后read才会返回-1，因此这里会一直阻塞，直到刷新页面才会继续，因此前
面第二次刷新才会打印数据，因为客户端主动关闭了连接，因此也会返回-1；而并且不会输出数据是因为，客户端在刷
新页面后跳出了read循环，可是连接都关闭了这时候服务器在输出客户端也收不到，因此不会有输出。书上贼的很，就
读了一次1024字节的数据，而我根据以往的读取经验直接写了个循环一直读，自己坑自己。
	解决途径：1、约定结束标识
		  2、设置超时时长
		  3、在request的header中标注好数据长度，按照这个长度来读

	CRLF是回车换行的意思

























