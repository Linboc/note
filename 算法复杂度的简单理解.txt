搜索一个好的哈希表会得到 O(1) 复杂度
		计算出hash值，然后去对应数组看有没有(好的哈希表应该指的是hash值没有重复的，每个下标都只有一个数，因此一次就能找到)
搜索一个均衡的树会得到 O(log(n)) 复杂度
		平衡树、二分查找
搜索一个阵列会得到 O(n) 复杂度			比如无序的集合

最好的排序算法具有 O(n*log(n)) 复杂度
		比如快排
糟糕的排序算法具有 O(n^2) 复杂度		比如冒泡
		
	

有多种类型的时间复杂度


一般情况场景

最佳情况场景

最差情况场景

时间复杂度经常处于最差情况场景。

B+数只有在最低层节点才保存真正的数据，其它节点只是帮助指引找到想要节点的辅助节点，并且底层节点
存储的数据都是连续的

哈希表越大，消耗越多的内存，但是桶位更不容易重叠，不重叠就不用进行比较，因此查找的次数会越少，
最好的情况就是完全不重叠，直接根据hash值在数组中取出来