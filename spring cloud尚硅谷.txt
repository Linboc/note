eureka自我保护机制：

	默认情况下，如果EurekaServer在一定时间内没有收到某个微服务实例的心跳，EurekaServer将会注销该实例(默认90秒)
，但是如果网络只是阻塞了，而服务本身是健康的，这会造成微服务与EurekaServer无法正常通信，因此此时不该注销这个微服务
。Eureka通过"自我保护模式"来解决这个问题--当EurekaServer节点在短时间内丢失过多客户端时，那么这个节点就会进入自我保
护模式。一旦进入该模式，EurekaServer就会保护服务注册表中的信息，也就是不会注销微服务。当网络故障恢复后，该EurekaServer
节点会自动退出自我保护模式。

	在自我保护模式中，EurekaServer会保护所有已注册微服务的信息。直到收到的心跳数重新恢复到阈值以上时，才会退出
自我保护模式。也就是说宁愿保留错误信息，也不能注销任何可能正确的信息。

	自我保护模式是一种应对网络异常的安全保护措施。亦可让Eureka集群更加健壮、稳定。

	自我保护机制是默认启动的，可以通过eureka.server.enablr-self-preservation=false关闭

info:
	在application.yml里可以定义info节点下的信息，这样在点击对应服务的时候就能看到该服务的信息了

服务发现：
	Eureka的客户端可以通过@EnableDiscoveryClient注解来启动客户端服务发现，然后通过注入DiscoveryClient对象来获
取所有服务的信息，这个客户端就可以向外暴露服务的信息、服务的提供者、每个提供者的ip、端口、服务名等信息，消费者有了
这些信息之后，就可以对感兴趣的服务通过ip+端口进行调用了

eureka集群：
	把eurekaServer的eureka.client.service-url.defaultZone配置设置为其它的eurekaServer注册地址，多个url之间用,
隔开，并且要互相注册才能集群，如果只是单向注册，那么被注册的一方无法看到注册进来的服务，在集群里的eureka服务器之间
的信息是共享的

分布式：
	将一个应用分成多个模块来部署，各个模块负责不同的功能

集群：
	将一个应用放到多个服务器上，通过负载均衡来选择服务器

应用监控：
	增加spring-boot-starter-actuator的依赖，就能自动进行监控，默认只开放/info和/health接口，其它接口需要鉴权，
可以通过management.security.enable=false配置来关闭鉴权，让所有监控接口公开

ACID原则：
	ACID原则指关系型数据库事务执行的时的4个原则，分别为：A、原子性，C、一致性，I、隔离性，D、持久性

CAP原则：
	C、一致性，A、可用性、P、分区容错性，CAP原则又称CAP定理，指的是在一个分布式系统中，这三个要素最多只能同时
实现两个
	强一致性：在分布式系统中，所有的节点在同一时刻同一个数据是否是同样的值，
	可用性：在集群中一部分节点故障后，集群是否还能相应客户端的读写请求，并且响应时间正常
	分区容错性：在出现网络故障时，系统是否能继续响应(把系统放到不同的网段)

	如何满足任意两个要素，并且为什么不能满足第三个？
		CA：要满足一致性和可用性，就多个服务只用一份数据，因为没有副本，因此无法进行分区

		CP：要满足一致性和分区容错性，就让数据每次写入都进行同步，同步期间无法读取，因为同步会发生阻塞，因
	此无法满足可用性

		AP：要满足可用性和分区容错性，数据有多个副本，并且不是实时同步，因此某些网络崩了，其它网络节点的副
	本写入和读取也不受影响，可以按照某些规则来进行数据的同步，所以有了最终一致性

NoSql属于CP序列，关系型数据库属于CA序列，而分布式系统不可能部署在同一台机上，因此分布式系统中P是必须要有的
	nosql关心分布式的分区容错性和强一致性
	关系型数据库关心可用性和强一致性
可见数据库都是关心数据的一致性，不过nosql更侧重分布式的方向，关系型数据库更侧重于集群的方向

Zookeeper是CP：即服务挂了之后会马上阻塞，然后选举，马上进行同步，因此会阻塞所有服务

Eureka是AP：用了自我保护机制，服务挂了就挂了，因此会造成服务过期了依然没有移除，新注册的服务不会同步到其它节点，等
网络稳定了退出自我保护机制才会进行同步


BASE原则：
	在分布式系统的实践中由CAP演化而来，指BA、基本可用，S、软状态，E最终一致性

	基本可用：系统出现异常，那么响应结果可以延迟、或者把请求引导到一个降级页面，而不是要求必须正常的成功
	弱状态：系统的数据存在中间状态，也即允许系统在不同节点中的数据副本同步的过程存在延迟
	最终一致性(弱一致)：所有的数据副本，在经过一段时间的同步之后，最终能达到一致性的状态

Load Balance：

Ribbon：
	客户端负载均衡的工具。

	集中式LB：通过一个独立的组件进行负载均衡，客户端连接这个组件，这个组件再去连接服务端

	进程内LB：将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择一个合适
的服务器。

	Ribbon就属于进程内LB，他只是一个类库。

	把消费者注册成eureka客户端，并且在RestTemplete这个Bean创建方法上面加上@LoadBalance注解，然后使用restTemplete
的时候不用写Ip地址和端口号，只需要写服务名和访问资源就可以了，会自动进行负载均衡

	Ribbon注册成Eureka客户端之后就会向Eureka查询可用服务列表，然后自己根据列表去访问对应的服务，默认是轮询

	切换负载均衡规则：自己创建一个IRule对象加入ioc中，这样ribbon就不会使用默认规则，而是使用自己选择的规则，ribbon
默认有7种规则，默认用的是RoundRobinRule，可以通过自己实现一个IRule并加入ioc中创建一个自定义规则

	为每个服务定制特有的负载均衡规则：
		@RibbonClient(value = "服务名", configuration = 配置类名)，通过这种方式去加载IRule对象，配置类要是
	个@Configuration类，并且要有个@Bean方法返回IRule对象，这个对象不会加入ioc中，因此可以定义多个

		可以用@RibbonClients里面放@RibbonClient数组为每个服务都指定各自的规则，并且还能指定一种默认的负载
	均衡策略

	
Feign：

	feign是一个声明式的Web服务客户端

	使用需要用@EnableFeignClient注解开启，并指定@FeignClient所在的包进行扫描，用@FeignClient注解标注一个接口，
并且value是一个服务名，调用这个接口就会调用这个服务，接口的方法映射对应着服务的controller层映射，如果是服务那边的
参数需要@RequestBody，那么接口这边对应的参数也加上@RequestBody，@PathVariable注解也一样，两边的注解要对应上


Hystrix：断路器
	
	断路器的存在就是对故障和延迟进行隔离和管理，以便单个服务的失败不会影响到整个应用程序或系统


服务雪崩：
	A服务掉B服务，B服务调C服务，越调越多，这就是"扇出"，如果扇出的链路上某个微服务的调用响应书剑过长或者不可用，
那么对服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，这就是"雪崩效应"。

	服务熔断：在服务器多次出现异常后，Hystrix是5秒内20次调用失败，Hystrix就会堆该服务进行熔断，无论谁来访问都
	          快速返回错误的相应信息，等检测到服务正常之后才会取消熔断
	
	服务降级：在服务器压力很大的情况下，对一些服务和页面有策略地不处理或者进行简单才处理，比如返回一个当前人数
		  过多的信息，通过牺牲这个服务来缓解服务器压力

	服务限流：在流量过多的情况下进行限制，比如返回一个默认界面，或者进行排队(lol人多的时候就会限流)，限流的条件
	          分很多很多种，比如可以限制总数、限制每秒的平均速率、限制内存或CUP负载等等

	区别：服务熔断一般是故障引起的，服务降级一般是从整体的负荷考虑主动进行的
	
	使用服务端断路器：
		1、导入yhstrix依赖
		2、启动服务熔断@EnableCircuitBreaker
		3、在controller方法中使用@HystrixCommand注解，并用fallbackMethod属性指定一个方法，如果该controller
		   方法出现异常，就会去调用fallbackMethod指定的方法返回

	使用客户端断路器：
		1、启动feign整个hystrix：feign.hystrix.enabled: true
		2、在feign接口的@FeignClient注解里指定fallbackFactory属性，指向一个FallbackFactory的实现类，这个接
		   口还有一个泛型，需要指定feign接口，这样在FallbackFactory的实现方法中就需要返回这个接口的实现类，
		   为每一个通过feign调用的服务定制一种异常后的处理方式，如果feign调用服务正常就正常返回，如果服务
		   异常就调用这个实现类对应的方法来返回







