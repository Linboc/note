
ClassLoader(类加载器)：

    它负责加载class文件，将class文件字节码内容加载到内存中，并将这些内容转成方法区中的运行时数据，也就是Class对象，并且ClassLoader只负责class文件的加载，至于class是否可运行则取决于Execution Engine

    JVM加载class文件时，判断是否可加载的依据不是文件扩展名，而是文件内容，class文件内容的开头都是cafe babe

    系统自带的类加载器分三种：
	启动类加载器(Bootstrap)，会加载${JAVA_HOME}\jre\lib\rt.jar，C++写的，因此看不到，比如Object、Arrays的类加载      器是null
	扩展类加载器(Extension)，会加载${JAVA_HOME}\jre\lib\ext下的包，比如CurveDB
	应用程序类加载器(AppClassLoader)，会加载ClassPath下的包，自己写的类和第三方包就是这个类加载器加载的，比如         Servlet、Bean等
    以上都可以用class.getClassLoader()来进行验证

    用户还可以自己继承java.lang.ClassLoader来自定义类自己的加载器

    双亲委派机制：
	类加载器需要加载类的时候，会先让父加载器去加载，如果父加载器加载不到，才会让子加载器加载，如果子加载器也加    载不到，就会抛出ClassNotCouldException。类加载顺序是：启动类加载器->扩展类加载器->应用程序类加载器。这就是双亲      委派机制

    沙箱安全机制：
	用户自定义java.lang.Object或者java.lang.String的时候，会先去启动类加载器(Bootstrap)里找，避免了JDK自带的类      被其它来源污染或顶替，这就是沙箱安全机制。可以自己自定义一个java.lang.String，然后写个main方法启动，会报找不到      入口main函数，因为找到的类是jdk自带的String，自己定义的并不会被加载到


Java内存模型：

    本地方法栈：
	放native修饰的方法

    PC寄存器(程序计数器)：
	每个线程都有一个程序计数器，是线程私有的，就是一个指针，用来存储指向存放下一条指令的地址，是一个非常小的内    存空间。

    方法区：
	里面的数据是所有线程共享的。它只是一种规范，不同虚拟机有不同的实现，比如永久代和元空间就是其中两种方法区的      实现。java7中常量池是放在永久代的，java8移到了堆中。虽然JVM规范将方法区描述为堆的一个逻辑部分，但它还有一个别      名叫Non-Heap(非堆)，就是为了和堆区分开
	主要存储了类信息、普通常量、静态常量、编译后的字节码，不会被GC回收

    栈(stack)：
	栈主管运行,在线程创建时创建，它的生命周期跟随线程的生命周期，线程结束栈内存就跟着释放。栈不存在垃圾回收问题     ，因为线程一结束就全都清理了，是线程私有的资源。
	主要存储方法信息，它的结构就是一个栈，main方法在栈底，如果调用了方法1，那么方法1就会在main上面，每个栈帧都      会存储它所属的那个方法的信息，比如父帧(调用者)、子帧(被调用者)、方法的局部变量、成员变量、静态变量，输入参数、      返回参数等等。每调用一个方法都会在栈中加一个新的栈帧，这个方法执行完毕就会出栈
	变量的引用都在栈中，线程会先从主内存复制一份引用出来到工作内存中，因此如果修改时成员变量的属性能马上可见，      因为它在堆中，所有线程共享。如果改了变量本身，就要把数据同步到主内存其它线程才能可见，因为它在栈中，是线程独有
	A a = new A()，其中a在栈中，new A()产生的源数据在堆中，A本身的结构在方法区中

    堆(heap)：
	堆主管存储，字符串常量池、基本数据类型都在堆中。一个JVM中只存在一个堆，堆的内存大小是可调节的，是线程共享的
	java8之前逻辑上堆由三部分组成：新生代、老年代、永久代，物理上由两部分组成：新生代、老年代。java8之后永久区      变成了元空间。
	
	新生区(new)：
	    伊甸园区(Eden)：新new的对象都在Eden区，如果Eden区满了则会对整个新生区进行YGC，然后把剩余对象放入S0
	    幸存者0区(S0、Survivor0、From)：如果S0区满了也会进行YGC(因为发现S0满的前提是Eden满了想要放进来，因此触		  发条件还是Eden区满)，然后把剩余的对象放入S1区
	    幸存者1区(S1、Survivor1、To)：如果S1区的对象从Eden区开始一共经历过15次YGC都没被回收，则会放进老年区

	老年区(old、Tenure Generation)：
	    老年区如果满了则会进行FGC，除了幸存足够多次的对象，如果有很大的对象，新生区装不下，也会直接放进老年区，		  一但老年区都满了GC还释放不出足够的空间就会抛出OutOfMemoryError错误。

	YGC(Young GC、Minor GC)：对新生代区，包括Eden、S0、S1进行GC
	FGC(Full GC)：对老年区进行GC

	YGC细节：Eden区满了之后会对Eden区和From区进行GC，然后把存活对象复制到To区，接着清空Eden区和From区。这时候         Eden区和From区都是空的，因此可用容量有90%。如果下一次Eden区又满了，原来的To区作为新的From区，和Eden区一起被GC       ，存活的对象再复制到原来的From区也即新的To区。就这样From区和To区一直互换，直到某个对象交换到15次，进入老年代       。这样进行复制、清除、交换的原因是，如果直接清除不需要的对象，会造成大量内存碎片，如果复制的话就能让内存连续

	堆空间的分配：新生代占1/3，内部细分的空间默认是：Eden占80%、From占10%、To占10%，老年代占2/3

	新生代进入老年代的存活次数由JVM参数MaxTenuringThreshold控制，这个参数默认是15

	永久区(Permanent)：
	    它是方法区的一种实现，java8之前的实现叫永久代，java8之后的实现叫元空间
	    它用于存放JDK自带的Class和Interface的元数据，也就是说它储存了运行环境必须的类信息，因此此区域的数据不会		  GC所回收，只有关闭JVM才会释放此区域所占用的内存



















