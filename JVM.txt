
ClassLoader(类加载器)：

    它负责加载class文件，将class文件字节码内容加载到内存中，并将这些内容转成方法区中的运行时数据，也就是Class对象，并且ClassLoader只负责class文件的加载，至于class是否可运行则取决于Execution Engine

    JVM加载class文件时，判断是否可加载的依据不是文件扩展名，而是文件内容，class文件内容的开头都是cafe babe

    系统自带的类加载器分三种：
	启动类加载器(Bootstrap)，会加载${JAVA_HOME}\jre\lib\rt.jar，C++写的，因此看不到，比如Object、Arrays的类加载      器是null
	扩展类加载器(Extension)，会加载${JAVA_HOME}\jre\lib\ext下的包，比如CurveDB
	应用程序类加载器(AppClassLoader)，会加载ClassPath下的包，自己写的类和第三方包就是这个类加载器加载的，比如         Servlet、Bean等
    以上都可以用class.getClassLoader()来进行验证

    用户还可以自己继承java.lang.ClassLoader来自定义类自己的加载器

    双亲委派机制：
	类加载器需要加载类的时候，会先让父加载器去加载，如果父加载器加载不到，才会让子加载器加载，如果子加载器也加    载不到，就会抛出ClassNotCouldException。类加载顺序是：启动类加载器->扩展类加载器->应用程序类加载器。这就是双亲    委派机制

    沙箱安全机制：
	用户自定义java.lang.Object或者java.lang.String的时候，会先去启动类加载器(Bootstrap)里找，避免了JDK自带的类      被其它来源污染或顶替，这就是沙箱安全机制。可以自己自定义一个java.lang.String，然后写个main方法启动，会报找不到      入口main函数，因为找到的类是jdk自带的String，自己定义的并不会被加载到

















