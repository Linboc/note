
ClassLoader(类加载器)：

    它负责加载class文件，将class文件字节码内容加载到内存中，并将这些内容转成方法区中的运行时数据，也就是Class对象，并且ClassLoader只负责class文件的加载，至于class是否可运行则取决于Execution Engine

    JVM加载class文件时，判断是否可加载的依据不是文件扩展名，而是文件内容，class文件内容的开头都是cafe babe

    系统自带的类加载器分三种：
	启动类加载器(Bootstrap)，会加载${JAVA_HOME}\jre\lib\rt.jar，C++写的，因此看不到，比如Object、Arrays的类加载      器是null
	扩展类加载器(Extension)，会加载${JAVA_HOME}\jre\lib\ext下的包，比如CurveDB
	应用程序类加载器(AppClassLoader)，会加载ClassPath下的包，自己写的类和第三方包就是这个类加载器加载的，比如         Servlet、Bean等
    以上都可以用class.getClassLoader()来进行验证

    用户还可以自己继承java.lang.ClassLoader来自定义类自己的加载器

    双亲委派机制：
	类加载器需要加载类的时候，会先让父加载器去加载，如果父加载器加载不到，才会让子加载器加载，如果子加载器也加    载不到，就会抛出ClassNotCouldException。类加载顺序是：启动类加载器->扩展类加载器->应用程序类加载器。这就是双亲      委派机制

    沙箱安全机制：
	用户自定义java.lang.Object或者java.lang.String的时候，会先去启动类加载器(Bootstrap)里找，避免了JDK自带的类      被其它来源污染或顶替，这就是沙箱安全机制。可以自己自定义一个java.lang.String，然后写个main方法启动，会报找不到      入口main函数，因为找到的类是jdk自带的String，自己定义的并不会被加载到


JVM内存模型(跟java内存模型是两回事)：

    本地方法栈：
	放native修饰的方法

    PC寄存器(程序计数器)：
	每个线程都有一个程序计数器，是线程私有的，就是一个指针，用来存储指向存放下一条指令的地址，是一个非常小的内    存空间。

    方法区：
	里面的数据是所有线程共享的。它只是一种规范，不同虚拟机有不同的实现，比如永久代和元空间就是其中两种方法区的      实现。java7中常量池是放在永久代的，java8移到了堆中。虽然JVM规范将方法区描述为堆的一个逻辑部分，但它还有一个别       名叫Non-Heap(非堆)，就是为了和堆区分开
	主要存储了类信息、普通常量、静态常量、编译后的字节码，不会被GC回收
	永久代会占用堆内存，元空间使用的是物理内存，不受JVM的堆内存限制，只受元空间的内存配置限制

    栈(stack)：
	栈主管运行,在线程创建时创建，它的生命周期跟随线程的生命周期，线程结束栈内存就跟着释放。栈不存在垃圾回收问题     ，因为线程一结束就全都清理了，是线程私有的资源。
	主要存储方法信息，它的结构就是一个栈，main方法在栈底，如果调用了方法1，那么方法1就会在main上面，每个栈帧都      会存储它所属的那个方法的信息，比如父帧(调用者)、子帧(被调用者)、方法的局部变量、成员变量，输入参数、返回参数等      等。每调用一个方法都会在栈中加一个新的栈帧，这个方法执行完毕就会出栈
	变量的引用都在栈中，线程会先从主内存复制一份引用出来到工作内存中，因此如果修改时成员变量的属性能马上可见，      因为它在堆中，所有线程共享。如果改了变量本身，就要把数据同步到主内存其它线程才能可见，因为它在栈中，是线程独有
	A a = new A()，其中a在栈中，new A()产生的源数据在堆中，A本身的结构在方法区中
	在Debug的时候可以看到，当前Debug线程的所有栈帧，每个栈帧都有自己的一份数据，那些就是工作内存，包里面括各种      静态变量、成员变量、局部变量，这些就是主内存的变量拷贝副本

    堆(heap)：
	堆主管存储，字符串常量池、基本数据类型、静态变量都在堆中。一个JVM中只存在一个堆，堆的内存大小是可调节的，是    线程共享的
	java8之前逻辑上堆由三部分组成：新生代、老年代、永久代，物理上由两部分组成：新生代、老年代。java8之后永久区      变成了元空间。
	
	新生区(new)：
	    伊甸园区(Eden)：新new的对象都在Eden区，如果Eden区满了则会对Eden区From区进行YGC，然后把剩余对象放入To区
	    幸存者0区(S0、Survivor0、From)：如果S0区满了也会进行YGC(因为发现S0满的前提是Eden满了想要放进来，因此触		  发条件还是Eden区满)，然后把剩余的对象放入S1区
	    幸存者1区(S1、Survivor1、To)：如果S1区的对象从Eden区开始一共经历过15次YGC都没被回收，则会放进老年区

	老年区(old、Tenure Generation)：
	    老年区如果满了则会进行FGC，除了幸存足够多次的对象，如果有很大的对象，新生区装不下，也会直接放进老年区，		  一但老年区都满了GC还释放不出足够的空间就会抛出OutOfMemoryError错误。

	Minor GC：对Eden区进行GC，第一次新生代GC时From是空的，因此Minor GC就够了，触发条件是Eden区满
	YGC(Young GC)：对新生代区，包括Eden、S0、S1(其实就是Eden和From)进行GC，触发条件是Eden区满
	FGC(Full GC、Major GC)：对整个堆进行回收，包括新生代、老年代和永久代，FGC之前通常会发生一次YCG，因为FCG的前       提是新生代放不下并进行YCG后依然放不下然后去老年代依然放不下才会进行FCG，但这并非绝对，一般FGC比YGC慢十倍以上      ，因为老年代空间比较大

	YGC细节：来了一个新对象，如果Eden放得下就放Eden，放不下就进行一次YGC或Minor GC(因为第一次GC只清Eden，之后就       是Eden+From)，GC后的对象复制To区，然后清空Eden和From，并且To和From互换，再把超过15次的对象放到老年区，并且To        区对象年龄+1，如果To区也满了就把To区部分活跃对象放到老年区。此时新对象还未分配，将再试尝试放Eden区，如果Eden        放得下就放，放不下就放老年区，如果老年区放不下就进行一次FCG，然后再尝试放一次，如果还不行则OOM
	基本就是放不下就进行GC后再试，还不行就去下一级，然后下级再试着放，不行就CG然后再下一级

	堆空间的分配：新生代占1/3，老年代占2/3，新生代内部细分的空间默认是：Eden占80%、From占10%、To占10%

	新生代进入老年代的存活次数由JVM参数MaxTenuringThreshold控制，这个参数默认是15

	永久区(Permanent)：
	    它是方法区的一种实现，java8之前的实现叫永久代，java8之后的实现叫元空间
	    它用于存放JDK自带的Class和Interface的元数据，也就是说它储存了运行环境必须的类信息，因此此区域的数据不会		  GC所回收，只有关闭JVM才会释放此区域所占用的内存

堆参数：

    -Xmx：JVM堆的最大可分配内存，默认是可用物理内存的1/4，剩余内存大于70%时就会慢慢减到-Xms，示例：-Xmx1024m/k/g
    -Xms：JVM堆的初始分配的内存，默认是可用物理内存的1/64，剩余内存小于40%时就会慢慢增大到-Xmx，示例：-Xms1024m/k/g
    这两个参数一般要设置成一样，避免内存忽高忽低
    -XX:+PrintGCDetails：输出堆信息，包括新生代、老年代、元空间




    Runtime.getRuntime().totalMemory()：返回堆当前占用的总内存，包括新生代和老年代，单位字节(bit/8位)，关联-Xms
    Runtime.getRuntime().maxMemory()：返回堆的最大可用内存，包括新生代和老年代，单位字节(bit/8位)，关联-Xmx

GC日志分析：

[GC (Allocation Failure) [DefNew: 4416K->512K(4928K), 0.0039289 secs] 4416K->1127K(15872K), 0.0039789 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
    GC：发生了CG，没有Full说明它是YCG
    Allocation Failure：这次发生GC是新生代内存不够引发的
    DefNew：新生代信息
      4416K：新生代的CG前内存占用
      512K：新生代的CG后内存占用
      (4928K)：新生代的总可用内存
      0.0039289 secs：新生代的CG耗时
    4416K：整个堆CG前内存占用
    1127K：整个堆CG后内存占用
    (15872K)：整个堆的总可用内存
    0.0039789 secs：总CG执行耗时
    user=0.00：用户耗时
    Times：执行时间信息
      user=0.00：用户耗时
      sys=0.00：系统耗时
      real=0.00：CG实际耗时
      secs：耗时单位，秒

[Full GC (Allocation Failure) [DefNew: 4416K->512K(4928K), 0.0039289 secs], [Tenured: 174057K->174057K(174784K), 0.0115170 secs] 252170K->251884K(253440K), [Metaspace: 2835K->2835K(4480K)], 0.0115644 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]

    Full GC：发生了FGC
    Allocation Failure：这次发生GC是新生代内存不够引发的
    DefNew：新生代信息
      4416K：新生代的CG前内存占用
      512K：新生代的CG后内存占用
      (4928K)：新生代的总可用内存
      0.0039289 secs：新生代的CG耗时
    Tenured：老年代信息
      174057K：老年代的CG前内存占用
      174057K：老年代的CG后内存占用
      (174784K)：老年代的总可用内存
      0.0115170 secs：老年代的CG耗时
    252170：整个堆CG前内存占用
    251884K：整个堆CG后内存占用
    (253440K)：整个堆的总可用内存
    Metaspace：元空间信息
      2835K：元空间的CG前内存占用
      2835K：元空间的CG后内存占用
      (4480K)：元空间的总可用内存
    0.0115644 secs：总CG执行耗时
    Times：执行时间信息
      user=0.00：用户耗时
      sys=0.00：系统耗时
      real=0.01：CG实际耗时
      secs：耗时单位，秒


GC算法：

    GC线程的运行都会暂停整个应用程序

    1、引用计数法：
	每个对象被引用计数就+1，引用失效计数就-1，为0就说明是可回收对象，一般不用这个算法
	缺点：无法解决循环引用的问题

    2、复制算法(Copying)：
	由于年轻代存活率低，因此这是YGC中主要采用的算法，GC开始时，对象只会存在Eden区和From区，To区是空的。GC后存活       的对象会复制到To区，然后To区和From区互换，并且年龄+1，这时年龄到15的就移到老年代，如果To区满了，就会将所有对        象移到老年代中
        优点：没有碎片内存
	缺点：浪费了一半内存，因为每一时刻S1和S2总有一个是空的，并且如果对象存活率很高，每个对象都需要复制一遍
	因此使用复制算法需要对象存活率很低才行，并且要克服50%的内存浪费

    标记清除(Mark-Sweep)：
	对象存活率高，用在老年代，第一步先标记可清除的对象，然后再进行统一清除
	优点：不会有空闲内存
	缺点：有内存碎片，切效率较低，需要经历标记清除两步

    标记压缩(Mark-Compact，又叫标记清除压缩算法)：
	用在老年代，第一步是标记，第二步是压缩，标记步骤就是标记清除，第二部就是再次扫描，把清除后的对象整理起来
	优点：没有内存碎片，也不浪费内存
	缺点：效率不高

    标记整理算法(不算GC算法)：
	在进行多次标记清除后才进行压缩，比较折中的方案，这只是一种方案，实际上没有这种算法

    没有最好的算法，只有最合适的算法，因此这些又叫分代收集算法，不同的代使用不同的算法，新生代用复制算法，老年代用  标记清除和标记压缩

    效率：复制算法>标记清除>标记压缩(这并不绝对，因为复制算法极端情况下存活率100%，效率反而差)
    内存利用率：标记压缩=标记清除>复制算法
    内存整齐度：复制算法=标记压缩>标记清除


JMM(Java Memory Modle，java内存模型)：

    JMM本身是一种规范，，通过这组规范定义了程序中各个变量包括成员变量，静态变量的访问方式

    JMM线程同步的规定：
	1、线程解锁前，必须把共享变量的值刷新回主内存
	2、线程加锁前，必须读取主内存的最新值到工作内存
	3、加锁和解锁是同一把锁

    由于JVM运行程序的主体是线程，从main开始的主线程，到自己启动的线程，到gc线程，都是由线程在完成工作。而每个线程创建时JVM都会为其创建一个工作内存，工作内存是每个线程的私有数据，而Java内存模型中规定所有变量都存在主内存，主内存是共享区域，所有线程都能访问。但线程对变量的操作必须在工作内存完成，因此要先将变量从主内存拷贝到线程的工作内存，然后对变量进行操作，操作完后在写会主内存，因此各个线程中的工作内存中存储着主内存的变量拷贝副本，因此不同内存之间无法访问对方的工作内存，传值(线程间的通信)必须通过主内存来完成。当然线程的数据在栈，而栈只是保存着变量的引用，可见性只对不可变类型或直接改引用有效
    内存可见性测试：创建一个共享变量，一个线程一直读，一个线程去改，然后会发现值明明已经改了，读的值却还一直是旧的

    线程可见性问题可以用加锁或者volatile来解决，相当于在写了值之后有一个通知机制通知其它线程更新值











