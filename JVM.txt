
ClassLoader(类加载器)：

    它负责加载class文件，将class文件字节码内容加载到内存中，并将这些内容转成方法区中的运行时数据，也就是Class对象，并且ClassLoader只负责class文件的加载，至于class是否可运行则取决于Execution Engine

    JVM加载class文件时，判断是否可加载的依据不是文件扩展名，而是文件内容，class文件内容的开头都是cafe babe

    系统自带的类加载器分三种：
	启动类加载器(Bootstrap)，会加载${JAVA_HOME}\jre\lib\rt.jar，C++写的，因此看不到，比如Object、Arrays的类加载      器是null
	扩展类加载器(Extension)，会加载${JAVA_HOME}\jre\lib\ext下的包，比如CurveDB
	应用程序类加载器(AppClassLoader)，会加载ClassPath下的包，自己写的类和第三方包就是这个类加载器加载的，比如         Servlet、Bean等
    以上都可以用class.getClassLoader()来进行验证

    用户还可以自己继承java.lang.ClassLoader来自定义类自己的加载器

    双亲委派机制：
	类加载器需要加载类的时候，会先让父加载器去加载，如果父加载器加载不到，才会让子加载器加载，如果子加载器也加    载不到，就会抛出ClassNotCouldException。类加载顺序是：启动类加载器->扩展类加载器->应用程序类加载器。这就是双亲    委派机制

    沙箱安全机制：
	用户自定义java.lang.Object或者java.lang.String的时候，会先去启动类加载器(Bootstrap)里找，避免了JDK自带的类      被其它来源污染或顶替，这就是沙箱安全机制。可以自己自定义一个java.lang.String，然后写个main方法启动，会报找不到      入口main函数，因为找到的类是jdk自带的String，自己定义的并不会被加载到


Java内存模型：

    本地方法栈：
	放native修饰的方法

    PC寄存器(程序计数器)：
	每个线程都有一个程序计数器，是线程私有的，就是一个指针，用来存储指向存放下一条指令的地址，是一个非常小的内    存空间。

    方法区：
	里面的数据是所有线程共享的。存放类的结构信息，表现为Class实例，比如属性和方法、构造函数和普通方法的字节码内     容(由class文件而来)、常量池。它只是一种规范，不同虚拟机有不同的实现，比如永久代和元空间就是其中两种方法区的实现
    实例变量存放在堆中，与方法区无关

    栈：
	栈主管运行,在线程创建时创建，它的生命周期跟随线程的生命周期，线程结束栈内存就跟着释放。栈不存在垃圾回收问题     ，因为线程一结束就全都清理了，是线程私有的资源。
	主要存储方法信息，它的结构就是一个栈，main方法在栈底，如果调用了方法1，那么方法1就会在main上面，每个栈帧都      会存储它所属的那个方法的信息，比如父帧(调用者)、子帧(被调用者)、方法的局部变量，输入参数、返回参数等等。每调用      一个方法都会在栈中加一个新的栈帧，这个方法执行完毕就会出栈
	运行时常量池、所有变量的引用、基本类型的变量都在栈中
	A a = new A()，其中a在栈中，new A()产生的源数据在堆中，A本身的结构在方法区中

    堆：
	堆管存储






















