信道：
	通过创建一个TCP连接，让所有与AMQP(高级消息队列协议)连接的的生产者和消费者都会创建一个信
道，这些信道被AMQP管理，用信道就不用每次连接都创建一个TCP连接，而是多个连接共用一个TCP，就像光
缆里面的多个通道一样，极大地节省了系统开销，而具体的信道管理交给AMQP

生产者、消费者：
	生产者就是发送消息的，消费者就是获取消息的，任何程序都可以既是生产者也是消费者，RabbitMQ
就像一个中转站一样
	
死信：
	当使用basic.reject并把requeue设置为false的时候，被拒绝的消息会被加入死信队列，所以死信
就是存放那些被认为无法处理的消息队列

	如果一条消息被消费者确认，那么另外一个消费者将不会收到这条消息，也就是说每条消息只能被
消费一次，也可以在订阅后就将auto_ack设置为true，这样的话就会在接收完每条消息后自动确认，如果消
息在接收完后，还未确认就被取消订阅或者从Rabbit断开连接，或者拒绝了消息，那么RabbitMQ就会认为这
条消息没有被消费而发送给另一个消费者

	Rabbit只有在上一条消息被确认后才会发送下一条消息，这样可以避免程序出了BUG，没有确认消息
导致源源不断的消息发送过来

AMQP命令：
	basic.consume：自动接收模式，在消费了或拒绝了最近接收的那条消息后，就能从队列中自动接收
下一条消息，知道取消对队列的订阅为止，如果要消息一到达就自动接收的话，那么就应该用basic.consume

	basic.get：每次调用此命令，就会从队列中获取一条信息，basic.get会用basic.consume订阅消息
，获取单条信息后并确认，再取消订阅，因此不应该用basic.get放在循环里代替basic.consume，因为这样
会Rabbit影响性能

	basic.reject：拒绝消息，如果把basic.reject的requeue设置为true的话，RabbitMQ会把消息重新
发送给下一个消费者，如果把basic.reject的requeue设置为false的话，RabbitMQ会把消息从队列中移除，
而不会发给其它消费者，当然，如果确认这条消息的话，也会把消息移除,不过这样不利于死信

	队列是消息的容易，可以存在多个的，并且任何进程都能创建队列

队列设置的参数：
	exclusive;如果设置为true的话，队列将变成私有的，此时只有当前的应用程序才能够消费队列消
息。当想要限制一个队列只有一个消费者的时候很有帮助，因为一个进程只会用一个TCP来创建多个信道，而
无论是消费还是生产，都是用同一个TCP，因此只有自己可见就是只会被一个TCP消费

	auto-delete：当最后一个消费者取消订阅的时候，队列就会自动移除，如果需要临时队列只为一个
消费者服务的话，就同时使用exclusive和auto-delete，这样就只能被自己使用，并且自己取消订阅后就会
自动移除

	queue.declare：如果把queue.declare的passive选项设为true，那么如果队列存在queue.declare
命令会成功返回，如果不存在也不会创建，而是返回一个错误
	
	如果新声明的队列完全匹配已存在的队列，那么Rabbit就什么都不做，并返回成功，如果只是队列
名称匹配，参数不匹配，队列声明尝试会失败

	如果生产者把消息发给不存在的队列，那么该消息会被Rabbit忽略

交换器和绑定：

	当要将消息投递到队列时，就要先把消息发送给AMQP交换器；当把消息发送给交换器后，消息将拥
有一个路由键，即使是空的；队列通过路由键绑定到交换器，服务器会将该消息复制给所有与消息键匹配的
队列，如果全都没有匹配，那么该消息会被忽略，至于怎么匹配，这取决于匹配规则

绑定(交换器的路由键匹配规则)：
	direct：默认交换器，用对列名做键，会根据消息的键来把消息投递给对应键的队列

	fanout：将收到的消息广播到绑定的队列上，当发送一条消息到fanout交换器时，它会把消息投递
给所有附加在此交换器上的队列

	topic：可以通过通配符来匹配，比如：log.*.msg，匹配前缀为log.，后缀为.msg的任何键，"*"将
"."视为分隔符，也就是说"*"如果遇到"."的话将不能继续通配，而如果键为"#"的话，将匹配所有键

vhost：
	
	vhost(虚拟机)，是在RabbitMQ服务器里面运行的，一个RabbitMQ服务器里面有多个vhost，并且它
们互相隔离，vhost1的交换机无法把消息绑定到vhost2的队列

vhost的创建：
	vhost是AMQP种唯一无法通过AMQP协议创建的单元，需要通过RabbitMQ的安装路径下的sbin中的
rabbitmqctl工具来创建，运行rabbitmqctl add_vhost[vhost_name]就可以创建一个vhost，运行
rabbitmqctl  list_vhosts则能知道特定Rabbit服务器上运行着哪些vhosts

消息的持久化：

	消息在服务器崩溃后将会丢失，如过想要服务重启后重新创建队列或者交换器，并且回复数据，那
么需要几个设置：
	1、把消息的投递模式设置为2(持久模式)
	2、发送到持久化交换器
	3、到达持久化队列
	持久化队列和持久化交换器可以通过把普通的队列和交换器的durable属性设置为true来获得

	消息持久化后：交换器会不会把消息写入日志
	交换器持久化后：在收到消息后写入日志文件
	队列持久化后：消息被消费前交换器不会把写入的消息移除

	持久性消息回复方式：将消息写入磁盘中的一个持久化日志文件，如果要发送消息给持久化交换器
的话，那么服务器会将消息先写入日志文件后才会发送给交换器，如果之后持久化交换器没有把消息发送给
持久化队列，那么就会把这条消息从持久化日志中移除，并无法恢复，因为正常的逻辑来说不进入持久化队
列就说明消息不需要持久化，那为什么不在发送给持久化队列时再持久化？因为一条消息可能需要发送给多
个队列，如果发送给持久化队列再写入日志，那么同一数据会被多次写入，因此在持久化交换器之前写入才
合理

	一旦消费(消费指接受并确认)了一条持久性消息，RabbitMQ会在持久化队列中把这条消息标识为等
待垃圾收集

	如果RabbitMQ重启的话，服务器会自动重建持久化过的交换器和队列，并绑定它们，重新把持久化
日志中的消息发送到何时的队列或者交换器上，这取决于Rabbit服务器宕机的时候，消息处在哪个环节

	持久化是很消耗性能的，使用持久化而导致消息吞吐量降低至少10倍的情况并不少见

	如何保证消息发送成功？生产者发送消息后，等待消费者反馈消息，如果长时间没有反馈，则重发

AMQP信道的事务：
	
	在把信道设置成事务模式后，通过信道发送一些想要确认的消息，其后跟着多条命令，如果第一条
消息发送成功的话，那么随后的命令都会被执行，如果发送失败，其后的命令将不会执行
	那么怎么确定第一条消息发送成功了呢？这个时候可以让生产者监听信道，应用程序在收到消息后
反馈消息是否接收成功，不过这样会使生产者和应用发生同步

	使用事务需要注意，事务不但会降低大约2~10倍的消息吞吐量，而且会使生产者和应用程序产生同步

发送确认模式：
	将信道设置成confirm模式，一旦进入confirm模式，只能通过重新创建信道来关闭该设置

	设置confirm模式后，所有在信道发布的消息都会被指派一个唯一的ID号(从1开始)；一旦消息被投
递给所有匹配的队列后，信道会发送一个包含唯一ID的发送确认模式给生产者应用程序，使得生产者知晓消
息成功到达目的队列如果消息和队列是持久化的，那么包含唯一ID的确认模式消息会在消息写入磁盘后发出
，如果因为Rabbit内部错误导致消息丢失，Rabbit会发送一条nack(未确认)消息来说明消息丢失

	confirm因为是回调模式，因此不会产生同步，同时由于没有回滚的概念，因此对Rabbit代理服务器
的性能影响几乎可以忽略不计


