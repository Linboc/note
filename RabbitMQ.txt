RabbitMQ是一个消息中间件

消息中间件：
    消息是指在应用中传送的数据，消息可以只包含字符串，JSON等，也可以很复杂，比如内嵌对象
    消息队列简称为MQ。是指利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分
布式系统的集成，通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信

    消息队列一般有两种传递模式：
	点对点模式：
	    消息生产者发布消息到队列，消息消费者从队列中接受消息
	
	发布/订阅模式：
	    发布/订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题，主题可以认为是消息
	传递的中介，消息发布者将消息发布到某个主题，消息订阅者从主题中订阅消息。主题使得发布者和订阅者互
	相保持独立，不需要接触就可以保证消息的传递，发布/订阅模式在一对多时广播采用

    消息中间件能在不同平台之间通信，它常被用来屏蔽各种平台以及协议之间的特性，其优点在于能够在客户和服务
器之间提供同步和异步的连接，并且在任何时刻都可以将消息进行传送或者存储转发，这也是它比远程过程调用更进步
的原因

    消息中间件的通信方式是异步的，比如应用A将消息发送给应用B，而这时应用B处于不运行状态，那么消息中间件就
会把消息保留起来，知道B应用开始执行并消费消息，这样还防止了应用A因为等待应用B消费消息而出现阻塞，这种方法
适用于对于时间无关或者并行处理的场景

消息中间件的作用：

	解耦：
	    在设计的时候预测将来的什么需求是比较困难的，消息中间件允许独立的扩展中间件两边的处理过程

	冗余(存储)：
	    当数据处理过程失败的时候，消息中间件可以吧数据进行持久化，直到他们被完全处理了，这样避免了数据
	丢失的风险、在一个消息被删除之前，处理系统必须明确地指出该消息已经被处理完成了，从而确保数据被安
	全地保存到使用完毕

	扩展性：
	    因为消息中间件解耦了应用的处理过程，所以提高消息入队和处理的效率是很容易的，只要增加额外的处
	理过程，比如MQ集群，不需要改代码

	削峰：
	    在访问量剧增的情况下，应用仍然要继续可用，但是这样的高并发并不常见，不值得按照这个标准投入资
	源，这是很大的浪费，使用消息中间件能使关键组件支撑突发访问压力，不会因为突发的超负荷请求而崩溃，
	也就是把所有需要处理的数据放到MQ中去，然后真正的处理程序再慢慢处理，只要平时有多余的计算资源，这
	些突然增长的访问总能处理完，这样做的坏处是不能及时处理，只适用于时间要求不严格的地方

	可恢复性：
	    当部分组件失效时，不会影响到整个系统；因为消息中间件是异步执行的，某个处理程序挂掉了，重新加
	入消息中间件后仍然可以在系统恢复后继续处理

	顺序保证：
	    消息中间件可以保证数据一定程度上的顺序

	缓冲：
	    消息中间件通过一个缓冲层来帮助任务高效率地执行，该缓冲层有助于控制和优化数据流经过系统的速度

	异步通信：
	    很多时候不需要立即处理的消息，消息中间件提供了异步处理机制，云溪把消息放入中间件，在之后需要
	的时候再慢慢处理

	RabbitMQ是采用Erlang语言实现的AMQP(高级消息队列协议)的消息中间件，最早起源于金融系统
	
	为了能够让消息在各个消息队列平台互通，JMS(Java Message Service)应运而生。JMS试图通过提供公共的
    Java API的方式隐藏单独MQ产品供应商提供的实际接口，从而跨越了壁垒，解决了互通的问题。Java程序只需要选
    择合适的MQ驱动即可，JMS会打理好其它部分。ActiveMQ就是JMS的一种实现。不过这种方式很脆弱，暴露出问题，
    使得应用程序变的更加脆弱，所以急需一种新的消息通信标准化方案

	AMQP是应用层协议的一个开放标准，以解决众多消息中间件的需求和拓扑结构问题。它为面向消息的中间件设
    计，基于此协议的客户端与消息中间件可传递消息，而不受产品和开发语言的限制。

	RabbitMQ服务器跟MySQL服务器一样是开机自启动的，它的经常名称是erlsrv.exe，因为它是erlang语言编写的
    ，这个应用下还有个子应用，那个子应用就是RabbitMQ了

	RabbitMQ有个默认用户，用户名和密码都是guest，这个账户限制只能通过本地访问

    添加新用户：
	rabbitmqctl add_user root root
    为root用户设置所有权限：
	rabbitmqctl set_permissions -p / root ".*" ".*" ".*"
    设置root用户为管理员角色：
	rabbitmqctl set_user_tags root administrator

生产者和消费者：
	
    生产者：Producer
	生产者就是投递消息的一方，生产者创建消息，然后发布到RabbitMQ中。消息一般包含两个部分：消息体
    (payload)和标签(Label)。在实际应用中，消息体一般是带有业务逻辑结构的数据，比如JSON字符串或者序列化数
    据，标签用来表述这条消息，比如描述消息属于那个交换器哪个路由键，RabbitMQ发送消息就是根据标签来发送的
    消费者：Consumer
	消费者连接到RabbitMQ服务器，并订阅到队列上，当消费者消费一条消息时，只是消费消息的消息体。在消息
    路由的过程中，消息的标签会丢弃，存入到队列的消息只有消息体，消费者也只会消费到消息体，并不知道生产者
    是谁，也不需要知道

    Broker：消息中间件的服务节点
	对于RabbitMQ来说，一个Broker可以看做一个服务节点，或者服务实例。大多数情况下，Broker也可以看做一
    台RabbitMQ服务器

    RabbitMQ消息生产到消费的流程：
	1、生产者创建好业务数据，可能是序列化数据
	2、指定交换器和路由键，也就是添加标签
	3、将消息发送至Broker
	4、消费者订阅并接收消息
	5、消费者拿到消息转为业务数据，可能经过反序列化

    如果多个消费者同时订阅同一队列，这时候队列中的消息会被平均分摊，既轮询给多个消费者进行处理，并不是每
个消费者都能收到所有的消息

    交换器：Exchange
	生产者投递的消息会先到交换器中，然后交换器将消息路由到一个或多个队列中，如果路由不到，或许会返回
    给生产者，或许会直接丢弃
	RabbitMQ有4种类型的交换器，不同的类型有不同的路由策略
	    fanout：把所有发送到该交换器的消息路由到所有绑定的队列中
	    direct：把消息路由到BindingKey和RoutingKey完全匹配的队列中 
	    topic：RoutingKey可以有多个单词，每个单词用.分开，只要这些单词能被BindingKey的规则匹配就会被
		   路由到对应的队列中，BindingKey可以使用*和#，其中*用于匹配一个单词，#匹配多个单词，同样
		   BindingKey可以使用.来分割单词，比如a.b.c的RoutingKey可以被a.*.c和a.#的BindingKey所匹配
	    headers：headers类型的交换器不依赖R路由键和绑定键来匹配路由消息，而是根据发送的消息内容中的
		     headers属性进行匹配，如果消息的headers完全匹配队列和交换器绑定时指定的键值对，消息会
		     路由到该队列，该类型的性能很差，而且不实用，所以基本不会使用

    路由键：RoutingKey
	生产者将消息发给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则，这个RoutingKey
    需要与交换器类型和绑定键(BindingKey)联合使用才能生效。在交换器和绑定建固定的情况下，生产者通过指定
    RoutingKey可以决定消息流向哪里

    绑定键：BindingKey
	RabbitMQ中通过绑定键将交换器与队列关联起来，在绑定的时候一般会指定一个绑定键，RabbitMQ通过绑定键
    将消息路由到正确的队列
    
    当路由键和绑定键相匹配的时候，消息会被路由到对应的队列中，在一个交换器绑定多个队列的时候，这些绑定允
许使用相同的BindingKey，绑定键并不是总是能生效，这依赖于交换器的类型，比如fanout类型的交换器就会无视绑定
键而将消息路由到所有绑定到该交换器的队列中

交换器和队列：

	所有的开发工作基本都在围绕连接和信道进行，一个连接工厂能创建多个连接，一个连接能创建多个信道，但
    是每个信道应该单独存在一个线程中，因为信道是非线程安全的，多线程情况下信道可能会出现通信帧交错

交换器相关方法：
    channel.exchangeDeclare方法：
	交换器声明的相关参数：
	    exchange：交换器名称
	    type：交换器类型
	    durable：是否持久化
	    autoDelete：是否自动删除，当这个交换器第一次被其它交换器或队列绑定后，一旦某一时刻没有任何绑
			定它的交换器或队列，这个交换器将会被删除
	    internal：是否内置，内置的交换器客户端无法直接发送消息，只能被其它非内置的交换器进行路由
	    argument：其它一些结构化参数
	这些重载方法都会返回一个Exchange.DeclareOK，客户端在声明一个交换器之后，需要等待服务器返回这个命
    令，如果返回则说明声明成功
	而channel.exchangeDeclareNoWait方法则是不需要服务器返回，这个方法的返回值是void，其它的地方都和普
    通的交换器声明方法差不多，这个方法有一个问题，那就是客户端声明一个交换器后，服务器还未完成交换器的创
    建，客户端就马上使用交换器了，这里会发生异常，因此没有特殊的缘由不推荐使用这个方法
	还有一个channel.exchangeDeclarePassive方法，这个方法主要用来检测交换器是否存在，只需要提供交换器
    名称，如果存在则正常返回，不存在则抛异常

    channel.exchangeDelete方法：
	exchange：要删除的交换器名称
	ifUnused：这个交换器是否只有在没被使用的情况下才会被删除

队列相关方法：
    channel.queueDeclare方法
	如果直接使用channel.queueDeclare(),就会声明一个名称为随机字符的队列，这个队列只在当前应用的同一个
    连接中可用，创建该队列的信道所属的连接下所有的信道都可共用，其它连接无法使用，并且该连接断开时该队列
    会自动删除，这种队列也称为匿名队列，声明队列时有几个参数：
	    queue：队列名
	    durable：是否持久化
	    exclusive：是否排他，排他队列只在连接内可用，连接断开时删除，即使它是持久化的，并且其他连接虽
		       然无法使用这个排他队列，但是依然无法声明相同名称的排他队列
	    autoDelete：是否自动删除，当这个队列第一次被消费者连接后，一旦某一时刻所有消费者都断开连接，
			这个队列才会被删除
	    argument：其它一些结构化参数
    而空参数声明的队列，queue=""、durable=false、exclusive=true、autoDelete=true

	如果声明的交换器或队列已存在，并且新声明的参数与前面已存在的声明参数一样，就什么都不做，并返回成
    功，如果参数不同则抛出异常

	同样，队列也有相似的queueDeclareNoWait、queueDeclarePassive、queueDelete、queueDeleteNoWait等方法
    ，其中queueDeleteNoWait方法有ifUnused和ifEmpty参数，ifUnused参数是队列没被连接时才会删除，ifEmpty是队
    列为空时才会删除
	channel.queuePurge方法用来清空队列的内容

队列绑定：
	channel.queueBind和channel.queueBindNoWait方法：
	    queue：队列名称
	    exchange：交换器名称
	    routingKey：路由键
	    argument：绑定的参数
队列解绑：
	channel.queueUnbind方法的参数和队列绑定基本一致

交换器与交换器绑定：
	channel.exchangeBind和channel.exchangeBindNoWait，参数与队列绑定类似

	交换器与交换器绑定，怎么决定绑定的交换器什么情况下把消息发给被绑定的交换器？所有都发还是根据交换
    器名称当路由键然后根据交换器类型匹配？

交换器与交换器解绑：
	channel.exchangeUnBind参数与队列解绑类似

发布消息：
	channel.basicPublish参数：
	    exchange：交换器名称，如果为空字符串则会发到RabbitMQ默认的交换器中
	    routingKey：路由键
	    props：这个对象可以设置一些属性，比如头信息、内容类型、用户id，消息id，消息超时时间等等
	    body：消息体，byte数组
	    mandatory：
	    immediate：

消费消息：
	消费消息分推(Push)模式和拉(Pull)模式，推模式使用Basic.Consume，拉模式使用Basic.Get

    推模式：
	推模式可以通过订阅的方式来消费消息，比如通过实现Consumer类或DefaultConsumer类，调用Consumer相关
    API时，不同的订阅采用不同的消费者标签来区分，就算再同一个信道中消费者也需要通过这个标签进行区分

    拉模式：

生产者运行流程：
	1、生产者连接到RabbitMQ Broker，建立一个连接，开启一个信道
	2、生产者声明一个交换器，并设置属性，比如交换器类型、是否持久化等
	3、生产者声明一个队列并设置属性，比如是否排他、是否持久化、是否自动删除等
	4、生产者通过路由键将交换器和队列绑定起来
	5、生产者发送消息至RabbitMQ Broker，其中包含路由键、交换器等信息
	6、交换器根据收到的路由键查找匹配的队列
	7、如果找到，则将从生产者发送过来的消息存入所匹配的队列中
    	8、如果没找到，则根据生产者的配置选择将消息丢弃或者回退给生产者
	9、关闭信道
	10、关闭连接

消费者的运行流程：
	1、消费者连接到RabbitMQ Broker，建立一个连接，开启一个信道
	2、消费者向RabbitMQ Broker请求消费相应队列中的消息，可以设置相应的回调函数，以及做一些准备工作
	3、等待RabbitMQ Broker回应并投递相应队列中的消息，消费者接受消息
	4、消费者确认(ack)接受到的消息
	5、RabbitMQ从队列中删除已经被确认的消息
	6、关闭信道
	7、关闭连接

	注意：如果消费者在一个信道上订阅了一个队列，那么将无法再声明队列，必须先取消订阅，然后将信道置为
    传输模式之后才能声明

Broker：任务代理，或者服务提供方？

AMQP协议：
	
	AMQP协议本身包括三层：
	    Module Layer：协议的最高层，主要定义了一些供客户端调用的命令，客户端可以用这些命令实现自己的
	业务逻辑，例如Queue.Declare声明队列或者Basic.Consume订阅队列
	    Session Layer：协议的中间层，主要将客户端的命令发送给服务器，再将服务器的应答返回给客户端，为
	客户端与服务器之间的通信提供可靠性同步机制和错误处理
	    Transport Layer：协议的最底层，主要传输二进制数据流，提供帧处理、信道复用、错误检测和数据表示

	    AMQP协议是应用层的协议，可以看做一系列结构化命令的集合，每个命令代表一种操作，类似于HTTP中的
	GET、POST、PUT等方法

	    RabbitMQ可以看做是AMQP协议的具体实现

	
	






信道：
	通过创建一个TCP连接，让所有与AMQP(高级消息队列协议)连接的的生产者和消费者都会创建一个信
道，这些信道被AMQP管理，用信道就不用每次连接都创建一个TCP连接，而是多个连接共用一个TCP，就像光
缆里面的多个通道一样，极大地节省了系统开销，而具体的信道管理交给AMQP

生产者、消费者：
	生产者就是发送消息的，消费者就是获取消息的，任何程序都可以既是生产者也是消费者，RabbitMQ
就像一个中转站一样
	
死信：
	当使用basic.reject并把requeue设置为false的时候，被拒绝的消息会被加入死信队列，所以死信
就是存放那些被认为无法处理的消息队列

	如果一条消息被消费者确认，那么另外一个消费者将不会收到这条消息，也就是说每条消息只能被
消费一次，也可以在订阅后就将auto_ack设置为true，这样的话就会在接收完每条消息后自动确认，如果消
息在接收完后，还未确认就被取消订阅或者从Rabbit断开连接，或者拒绝了消息，那么RabbitMQ就会认为这
条消息没有被消费而发送给另一个消费者

	Rabbit只有在上一条消息被确认后才会发送下一条消息，这样可以避免程序出了BUG，没有确认消息
导致源源不断的消息发送过来

AMQP命令：
	basic.consume：自动接收模式，在消费了或拒绝了最近接收的那条消息后，就能从队列中自动接收
下一条消息，知道取消对队列的订阅为止，如果要消息一到达就自动接收的话，那么就应该用basic.consume

	basic.get：每次调用此命令，就会从队列中获取一条信息，basic.get会用basic.consume订阅消息
，获取单条信息后并确认，再取消订阅，因此不应该用basic.get放在循环里代替basic.consume，因为这样
会Rabbit影响性能

	basic.reject：拒绝消息，如果把basic.reject的requeue设置为true的话，RabbitMQ会把消息重新
发送给下一个消费者，如果把basic.reject的requeue设置为false的话，RabbitMQ会把消息从队列中移除，
而不会发给其它消费者，当然，如果确认这条消息的话，也会把消息移除,不过这样不利于死信

	队列是消息的容易，可以存在多个的，并且任何进程都能创建队列

队列设置的参数：
	exclusive;如果设置为true的话，队列将变成私有的，此时只有当前的应用程序才能够消费队列消
息。当想要限制一个队列只有一个消费者的时候很有帮助，因为一个进程只会用一个TCP来创建多个信道，而
无论是消费还是生产，都是用同一个TCP，因此只有自己可见就是只会被一个TCP消费

	auto-delete：当最后一个消费者取消订阅的时候，队列就会自动移除，如果需要临时队列只为一个
消费者服务的话，就同时使用exclusive和auto-delete，这样就只能被自己使用，并且自己取消订阅后就会
自动移除

	queue.declare：如果把queue.declare的passive选项设为true，那么如果队列存在queue.declare
命令会成功返回，如果不存在也不会创建，而是返回一个错误
	
	如果新声明的队列完全匹配已存在的队列，那么Rabbit就什么都不做，并返回成功，如果只是队列
名称匹配，参数不匹配，队列声明尝试会失败

	如果生产者把消息发给不存在的队列，那么该消息会被Rabbit忽略

交换器和绑定：

	当要将消息投递到队列时，就要先把消息发送给AMQP交换器；当把消息发送给交换器后，消息将拥
有一个路由键，即使是空的；队列通过路由键绑定到交换器，服务器会将该消息复制给所有与消息键匹配的
队列，如果全都没有匹配，那么该消息会被忽略，至于怎么匹配，这取决于匹配规则

绑定(交换器的路由键匹配规则)：
	direct：默认交换器，用对列名做键，会根据消息的键来把消息投递给对应键的队列

	fanout：将收到的消息广播到绑定的队列上，当发送一条消息到fanout交换器时，它会把消息投递
给所有附加在此交换器上的队列

	topic：可以通过通配符来匹配，比如：log.*.msg，匹配前缀为log.，后缀为.msg的任何键，"*"将
"."视为分隔符，也就是说"*"如果遇到"."的话将不能继续通配，而如果键为"#"的话，将匹配所有键

vhost：
	
	vhost(虚拟机)，是在RabbitMQ服务器里面运行的，一个RabbitMQ服务器里面有多个vhost，并且它
们互相隔离，vhost1的交换机无法把消息绑定到vhost2的队列

vhost的创建：
	vhost是AMQP种唯一无法通过AMQP协议创建的单元，需要通过RabbitMQ的安装路径下的sbin中的
rabbitmqctl工具来创建，运行rabbitmqctl add_vhost[vhost_name]就可以创建一个vhost，运行
rabbitmqctl  list_vhosts则能知道特定Rabbit服务器上运行着哪些vhosts

消息的持久化：

	消息在服务器崩溃后将会丢失，如过想要服务重启后重新创建队列或者交换器，并且回复数据，那
么需要几个设置：
	1、把消息的投递模式设置为2(持久模式)
	2、发送到持久化交换器
	3、到达持久化队列
	持久化队列和持久化交换器可以通过把普通的队列和交换器的durable属性设置为true来获得

	消息持久化后：交换器会不会把消息写入日志
	交换器持久化后：在收到消息后写入日志文件
	队列持久化后：消息被消费前交换器不会把写入的消息移除

	持久性消息回复方式：将消息写入磁盘中的一个持久化日志文件，如果要发送消息给持久化交换器
的话，那么服务器会将消息先写入日志文件后才会发送给交换器，如果之后持久化交换器没有把消息发送给
持久化队列，那么就会把这条消息从持久化日志中移除，并无法恢复，因为正常的逻辑来说不进入持久化队
列就说明消息不需要持久化，那为什么不在发送给持久化队列时再持久化？因为一条消息可能需要发送给多
个队列，如果发送给持久化队列再写入日志，那么同一数据会被多次写入，因此在持久化交换器之前写入才
合理

	一旦消费(消费指接受并确认)了一条持久性消息，RabbitMQ会在持久化队列中把这条消息标识为等
待垃圾收集

	如果RabbitMQ重启的话，服务器会自动重建持久化过的交换器和队列，并绑定它们，重新把持久化
日志中的消息发送到何时的队列或者交换器上，这取决于Rabbit服务器宕机的时候，消息处在哪个环节

	持久化是很消耗性能的，使用持久化而导致消息吞吐量降低至少10倍的情况并不少见

	如何保证消息发送成功？生产者发送消息后，等待消费者反馈消息，如果长时间没有反馈，则重发

AMQP信道的事务：
	
	在把信道设置成事务模式后，通过信道发送一些想要确认的消息，其后跟着多条命令，如果第一条
消息发送成功的话，那么随后的命令都会被执行，如果发送失败，其后的命令将不会执行
	那么怎么确定第一条消息发送成功了呢？这个时候可以让生产者监听信道，应用程序在收到消息后
反馈消息是否接收成功，不过这样会使生产者和应用发生同步

	使用事务需要注意，事务不但会降低大约2~10倍的消息吞吐量，而且会使生产者和应用程序产生同步

发送确认模式：
	将信道设置成confirm模式，一旦进入confirm模式，只能通过重新创建信道来关闭该设置

	设置confirm模式后，所有在信道发布的消息都会被指派一个唯一的ID号(从1开始)；一旦消息被投
递给所有匹配的队列后，信道会发送一个包含唯一ID的发送确认模式给生产者应用程序，使得生产者知晓消
息成功到达目的队列如果消息和队列是持久化的，那么包含唯一ID的确认模式消息会在消息写入磁盘后发出
，如果因为Rabbit内部错误导致消息丢失，Rabbit会发送一条nack(未确认)消息来说明消息丢失

	confirm因为是回调模式，因此不会产生同步，同时由于没有回滚的概念，因此对Rabbit代理服务器
的性能影响几乎可以忽略不计


