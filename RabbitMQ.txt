RabbitMQ是一个消息中间件

消息中间件：
    消息是指在应用中传送的数据，消息可以只包含字符串，JSON等，也可以很复杂，比如内嵌对象
    消息队列简称为MQ。是指利用搞笑可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分
布式系统的集成，通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信

    消息队列一般有两种传递模式：
	点对点模式：
	    消息生产者发布消息到队列，消息消费者从队列中接受消息
	
	发布/订阅模式：
	    发布/订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题，主题可以认为是消息
	传递的中介，消息发布者将消息发布到某个主题，消息订阅者从主题中订阅消息。主题使得发布者和订阅者互
	相保持独立，不需要接触就可以保证消息的传递，发布/订阅模式在一对多时广播采用

    消息中间件能在不同平台之间通信，它常被用来屏蔽各种平台以及协议之间的特性，其优点在于能够在客户和服务
器之间提供同步和异步的连接，并且在任何时刻都可以将消息进行传送或者存储转发，这也是它比远程过程调用更进步
的原因

    消息中间件的通信方式是异步的，比如应用A将消息发送给应用B，而这时应用B处于不运行状态，那么消息中间件就
会把消息保留起来，知道B应用开始执行并消费消息，这样还防止了应用A因为等待应用B消费消息而出现阻塞，这种方法
适用于对于时间无关或者并行处理的场景

消息中间件的作用：

	解耦：
	    在设计的时候预测将来的什么需求是比较困难的，消息中间件允许独立的扩展中间件两边的处理过程

	冗余(存储)：
	    当数据处理过程失败的时候，消息中间件可以吧数据进行持久化，直到他们被完全处理了，这样避免了数据
	丢失的风险、在一个消息被删除之前，处理系统必须明确地指出该消息已经被处理完成了，从而确保数据被安
	全地保存到使用完毕

	扩展性：
	    因为消息中间件解耦了应用的处理过程，所以提高消息入队和处理的效率是很容易的，只要增加额外的处
	理过程，比如MQ集群，不需要改代码

	削峰：
	    在访问量剧增的情况下，应用仍然要继续可用，但是这样的高并发并不常见，不值得按照这个标准投入资
	源，这是很大的浪费，使用消息中间件能使关键组件支撑突发访问压力，不会因为突发的超负荷请求而崩溃，
	也就是把所有需要处理的数据放到MQ中去，然后真正的处理程序再慢慢处理，只要平时有多余的计算资源，这
	些突然增长的访问总能处理完，这样做的坏处是不能及时处理，只适用于时间要求不严格的地方

	可恢复性：
	    当部分组件失效时，不会影响到整个系统；因为消息中间件是异步执行的，某个处理程序挂掉了，重新加
	入消息中间件后仍然可以在系统恢复后继续处理

	顺序保证：
	    消息中间件可以保证数据一定程度上的顺序

	缓冲：
	    消息中间件通过一个缓冲层来帮助任务高效率地执行，该缓冲层有助于控制和优化数据流经过系统的速度

	异步通信：
	    很多时候不需要立即处理的消息，消息中间件提供了异步处理机制，云溪把消息放入中间件，在之后需要
	的时候再慢慢处理

	RabbitMQ是采用Erlang语言实现的AMQP(高级消息队列协议)的消息中间件，最早起源于金融系统
	
	为了能够让消息在各个消息队列平台互通，JMS(Java Message Service)应运而生。JMS试图通过提供公共的
    Java API的方式隐藏单独MQ产品供应商提供的实际接口，从而跨越了壁垒，解决了互通的问题。Java程序只需要选
    择合适的MQ驱动即可，JMS会打理好其它部分。ActiveMQ就是JMS的一种实现。不过这种方式很脆弱，暴露出问题，
    使得应用程序变的更加脆弱，所以急需一种新的消息通信标准化方案

	AMQP是应用层协议的一个开放标准，以解决众多消息中间件的需求和拓扑结构问题。它为面向消息的中间件设
    计，基于此协议的客户端与消息中间件可传递消息，并不受产品和开发语言的限制。










信道：
	通过创建一个TCP连接，让所有与AMQP(高级消息队列协议)连接的的生产者和消费者都会创建一个信
道，这些信道被AMQP管理，用信道就不用每次连接都创建一个TCP连接，而是多个连接共用一个TCP，就像光
缆里面的多个通道一样，极大地节省了系统开销，而具体的信道管理交给AMQP

生产者、消费者：
	生产者就是发送消息的，消费者就是获取消息的，任何程序都可以既是生产者也是消费者，RabbitMQ
就像一个中转站一样
	
死信：
	当使用basic.reject并把requeue设置为false的时候，被拒绝的消息会被加入死信队列，所以死信
就是存放那些被认为无法处理的消息队列

	如果一条消息被消费者确认，那么另外一个消费者将不会收到这条消息，也就是说每条消息只能被
消费一次，也可以在订阅后就将auto_ack设置为true，这样的话就会在接收完每条消息后自动确认，如果消
息在接收完后，还未确认就被取消订阅或者从Rabbit断开连接，或者拒绝了消息，那么RabbitMQ就会认为这
条消息没有被消费而发送给另一个消费者

	Rabbit只有在上一条消息被确认后才会发送下一条消息，这样可以避免程序出了BUG，没有确认消息
导致源源不断的消息发送过来

AMQP命令：
	basic.consume：自动接收模式，在消费了或拒绝了最近接收的那条消息后，就能从队列中自动接收
下一条消息，知道取消对队列的订阅为止，如果要消息一到达就自动接收的话，那么就应该用basic.consume

	basic.get：每次调用此命令，就会从队列中获取一条信息，basic.get会用basic.consume订阅消息
，获取单条信息后并确认，再取消订阅，因此不应该用basic.get放在循环里代替basic.consume，因为这样
会Rabbit影响性能

	basic.reject：拒绝消息，如果把basic.reject的requeue设置为true的话，RabbitMQ会把消息重新
发送给下一个消费者，如果把basic.reject的requeue设置为false的话，RabbitMQ会把消息从队列中移除，
而不会发给其它消费者，当然，如果确认这条消息的话，也会把消息移除,不过这样不利于死信

	队列是消息的容易，可以存在多个的，并且任何进程都能创建队列

队列设置的参数：
	exclusive;如果设置为true的话，队列将变成私有的，此时只有当前的应用程序才能够消费队列消
息。当想要限制一个队列只有一个消费者的时候很有帮助，因为一个进程只会用一个TCP来创建多个信道，而
无论是消费还是生产，都是用同一个TCP，因此只有自己可见就是只会被一个TCP消费

	auto-delete：当最后一个消费者取消订阅的时候，队列就会自动移除，如果需要临时队列只为一个
消费者服务的话，就同时使用exclusive和auto-delete，这样就只能被自己使用，并且自己取消订阅后就会
自动移除

	queue.declare：如果把queue.declare的passive选项设为true，那么如果队列存在queue.declare
命令会成功返回，如果不存在也不会创建，而是返回一个错误
	
	如果新声明的队列完全匹配已存在的队列，那么Rabbit就什么都不做，并返回成功，如果只是队列
名称匹配，参数不匹配，队列声明尝试会失败

	如果生产者把消息发给不存在的队列，那么该消息会被Rabbit忽略

交换器和绑定：

	当要将消息投递到队列时，就要先把消息发送给AMQP交换器；当把消息发送给交换器后，消息将拥
有一个路由键，即使是空的；队列通过路由键绑定到交换器，服务器会将该消息复制给所有与消息键匹配的
队列，如果全都没有匹配，那么该消息会被忽略，至于怎么匹配，这取决于匹配规则

绑定(交换器的路由键匹配规则)：
	direct：默认交换器，用对列名做键，会根据消息的键来把消息投递给对应键的队列

	fanout：将收到的消息广播到绑定的队列上，当发送一条消息到fanout交换器时，它会把消息投递
给所有附加在此交换器上的队列

	topic：可以通过通配符来匹配，比如：log.*.msg，匹配前缀为log.，后缀为.msg的任何键，"*"将
"."视为分隔符，也就是说"*"如果遇到"."的话将不能继续通配，而如果键为"#"的话，将匹配所有键

vhost：
	
	vhost(虚拟机)，是在RabbitMQ服务器里面运行的，一个RabbitMQ服务器里面有多个vhost，并且它
们互相隔离，vhost1的交换机无法把消息绑定到vhost2的队列

vhost的创建：
	vhost是AMQP种唯一无法通过AMQP协议创建的单元，需要通过RabbitMQ的安装路径下的sbin中的
rabbitmqctl工具来创建，运行rabbitmqctl add_vhost[vhost_name]就可以创建一个vhost，运行
rabbitmqctl  list_vhosts则能知道特定Rabbit服务器上运行着哪些vhosts

消息的持久化：

	消息在服务器崩溃后将会丢失，如过想要服务重启后重新创建队列或者交换器，并且回复数据，那
么需要几个设置：
	1、把消息的投递模式设置为2(持久模式)
	2、发送到持久化交换器
	3、到达持久化队列
	持久化队列和持久化交换器可以通过把普通的队列和交换器的durable属性设置为true来获得

	消息持久化后：交换器会不会把消息写入日志
	交换器持久化后：在收到消息后写入日志文件
	队列持久化后：消息被消费前交换器不会把写入的消息移除

	持久性消息回复方式：将消息写入磁盘中的一个持久化日志文件，如果要发送消息给持久化交换器
的话，那么服务器会将消息先写入日志文件后才会发送给交换器，如果之后持久化交换器没有把消息发送给
持久化队列，那么就会把这条消息从持久化日志中移除，并无法恢复，因为正常的逻辑来说不进入持久化队
列就说明消息不需要持久化，那为什么不在发送给持久化队列时再持久化？因为一条消息可能需要发送给多
个队列，如果发送给持久化队列再写入日志，那么同一数据会被多次写入，因此在持久化交换器之前写入才
合理

	一旦消费(消费指接受并确认)了一条持久性消息，RabbitMQ会在持久化队列中把这条消息标识为等
待垃圾收集

	如果RabbitMQ重启的话，服务器会自动重建持久化过的交换器和队列，并绑定它们，重新把持久化
日志中的消息发送到何时的队列或者交换器上，这取决于Rabbit服务器宕机的时候，消息处在哪个环节

	持久化是很消耗性能的，使用持久化而导致消息吞吐量降低至少10倍的情况并不少见

	如何保证消息发送成功？生产者发送消息后，等待消费者反馈消息，如果长时间没有反馈，则重发

AMQP信道的事务：
	
	在把信道设置成事务模式后，通过信道发送一些想要确认的消息，其后跟着多条命令，如果第一条
消息发送成功的话，那么随后的命令都会被执行，如果发送失败，其后的命令将不会执行
	那么怎么确定第一条消息发送成功了呢？这个时候可以让生产者监听信道，应用程序在收到消息后
反馈消息是否接收成功，不过这样会使生产者和应用发生同步

	使用事务需要注意，事务不但会降低大约2~10倍的消息吞吐量，而且会使生产者和应用程序产生同步

发送确认模式：
	将信道设置成confirm模式，一旦进入confirm模式，只能通过重新创建信道来关闭该设置

	设置confirm模式后，所有在信道发布的消息都会被指派一个唯一的ID号(从1开始)；一旦消息被投
递给所有匹配的队列后，信道会发送一个包含唯一ID的发送确认模式给生产者应用程序，使得生产者知晓消
息成功到达目的队列如果消息和队列是持久化的，那么包含唯一ID的确认模式消息会在消息写入磁盘后发出
，如果因为Rabbit内部错误导致消息丢失，Rabbit会发送一条nack(未确认)消息来说明消息丢失

	confirm因为是回调模式，因此不会产生同步，同时由于没有回滚的概念，因此对Rabbit代理服务器
的性能影响几乎可以忽略不计


