
	分区的作用：
		数据安全：如果要重装系统，或者清除某个分区，那么其它区不会受到影响，重装只会清空c盘
		效能：知道文件在哪个区，可以直接去那个区找，不用浪费资源在不想关的区
		缺点是：分好区之后就不能改了，如果要改动分区，就要清除原来的数据，因为要修改分区范围

	多重引导：
		开机时可以指定要使用的核心文件，比如有windows和linux两个系统，第一次选择就有M1和M2，M1就
	是启动windows系统，m2指向下一个开机程序，如果下一个没有额外的选项的话，就会直接启动linux系统

	映像文件下载：
	在http://ftp.twaren.net/Linux/CentOS/7/isos/x86_64/下载映像文件，CentOS-7-x86_64-Everything-1810.iso
的含义是：7代表第7个版本，x86_64代表64位，Everything代表包含所有东西的版本，1810说明是18年10月发布的，如
果最后面还有01这样的描述的话，就是7.01版本

	VMware vm-boc账号：admin
	VMware vm-boc密码：8822995
	
	centos root密码：8822995

	centos管理员账号：boc
	centos管理员密码：8822995

linux的文件如果要隐藏的话，只需要在名字前面加一个小数点‘.’就会认为是隐藏文件

切换文本模式和窗口界面：
	ctrl+alt+F1~F6，一般情况下F1是窗口界面，不过如果没有窗口界面那么就会是文本界面，每切换到一个新的界面都需要
重新登录，因为界面是第一次切换才创建的，因此不同的界面可以用不同的用户，在文本界面下可以用startx来启动窗口界面

命令行前面字符的含义：
    [boc@study ~]$
	boc：当前登录的用户
	@：用户名与主机名的分隔符
	study：主机名，如果主机名用多个.隔开，只会使用第一个.前面的字符
	~：当前用户的home目录，它是一个变量，如果用户是boc，这个变量则指向/home/boc
	$：命令提示符，一般用户是$，root用户是#

退出系统：exit，其实只是注销当前用户的登陆信息

命令格式：
	command --option1 --option2 param1 param2...
	指令    选项1     选项2   参数1  参数2
    命令之间用空格分隔，多个空格会视为一个，按下Enter就代表执行一行指令，\可以转移特殊字符，包括Enter，如果最后一
个字符是\，然后按下Enter键，就会去到下一行而不会立即执行

locale：
	查看编码信息

基础指令：
	date：显示日期与时间
	    在date后面加上参数：+%Y-%m-%d\ %H:%M:%S就可以打印常用的时间格式，这几个%x参数就是取出date里的部分信息

	cal：显示日历
	    cal [month] [year]，可以显示指定年月的日历，如果只写一个参数则认为是年

	bc：计算器
	    可以用+、-、*、/、^、%等符号，输入quit退出，默认情况下bc仅输出整数，如果要输出小数点就要在进入bc之后
	设置scale属性，它决定了会输出几位小数

有一些指令会直接返回结果，然后等待下一个指令，有一些指令会去到特殊的环境中，执行这个指令内部的信息，在这种情况下输
入的指令会被传给该环境，而不会是命令提示字符环境，需要退出该环境才能继续执行原本的命令，判断是否在等待指令输入环境
只需要看光标前面是否提示用户信息就知道了，比如[boc@study ~]$_就是等待输入指令

重要热键：
	tab：命令补全和文件名补全
	    如果在输入命令的时候按两次tab,就会提示以该命令开头的所有命令，如果在输入非命令的时候，就会去检测输入的
	字符匹配的路径或文件，输入指令时第一个空格之前的字符串就是命令，如果安装了bash-completion软件，有时候会有
	选项或参数补全，比如在命令后面的选项中有一个--然后按tab tab，就会出现可用的选项

	ctrl+c：
	    中断当前程序

	shift+pageUp\pageDown：
	    如果信息很长导致上面的信息被刷走了，可以用这个组合键看前面或后面的信息，shift+pageUp\pageDown在任何情
	况下都能使用，如果在指令内部的话则可以使用pageUp\pageDown，这时候他们的区别是shift+pageUp\pageDown可以跨越
	这个指令的内容看到其它的历史记录，而不加shift则只能看到这个指令的内容，无法跨越 出去

	home/end：
		在指令内部可以通过这两个键去到指令内容的开始和结束位置

--help：
	很多情况下可以通过--help来查看某些指令的选项和参数，比如date --help

man page(操作说明页)：
	使用map 命令可以查看该命令的用法，这些用法的显示就是page，空格可以跳到下一页，q可以退出说明页，shift+pageUp\pageDown
也可以在这里使用，在使用man page时，在第一行会出现man后面的指令，后面会跟着一个括号，里面有数字，这些数字的含义是：
1：可操作的指令或可执行文件；5：配置文件；8：系统管理的管理指令，比较重要的就这几个

在页面进行搜索：
	在指令页面中，比如man date指令之后，可以通过/或者?进行页面搜索，比如/date或者?hello，分别是向下搜索date和
向上搜索hello字符，并且会把找到的字符定位到页面的第一行，/向下，?向上，在进行搜索之后，可以用n或者N进行下一轮搜索
，n往下面搜索，N往上面搜索

info page：
	与man page不同，man page是一口气输出一堆信息，info page是把信息分成一个个段落，再以超链接的方式去不同的页
面浏览，每个页面都称为一个节点(node)

	info page的第一行的File标签显示文件来源，它的文件来源在CentOs7中放到了/usr/share/info/目录中，Node标签显示
当前在哪个节点，Next表示下个节点是哪个，Prev表示上个节点，Up表示上一层，这三个功能分别以它的首字母作为快捷键，q可
以退出，t可以回到top节点，也就是刚进来时的节点，h可以显示帮助信息，里面有各个按键的功能，tab可以跳跃到不同的超链接
处，在那些地方按下enter则会进行跳转，当然自己用光标进行移动然后单enter键效果一样
	如果info选择的命令没有info文件来源，也就是不支持info功能，就会按照man page的方式显示，比如info man展示的界
面和man man一样

	还有很多文件或指令没有联机帮助文档，这些东西需要额外的文件去描述，这些文件都放在/usr/share/doc目录下，每个
不同的指令或文件都可能会有多个版本，因此命名都是命令-版本的格式，还有很多软件安装的时候都会有一些安装须知，工作事
项、未来规划等等，这些文件也都放在这个目录中

    帮助总结：
	如果不知道某个指令就用man或者info，如果知道指令但是忘记了参数和选项就用--help，如果想要更多的信息就去
/usr/share/doc目录找

简单的文本编辑器：nano
	nano后面跟上文件名，如果该文件存在就编辑该文件，如果不存在就打开新的界面，最下两行会显示各种^+英文，^的意
思就是ctrl，比如ctrl+g就会进入帮助界面，ctrl+o就会保存,ctrl+w可以搜索，在保存界面最下两行还会有m-英文，m的意思就是
alt，比如alt-a就会把当前文件插入到目标文件的尾部，如果不想插入了可以用ctrl+c取消

关机注意事项：
	由于Linux是多人多任务，跟Windows单人多任务不一样，Windows关机后不会影响到别人，只要确保自己的任务状态可以
关机就可以了，Linux如果直接关机其他人正在执行的任务就会受到影响，比如传输文件传输到一半就关机了，会造成文件损坏，
还有服务器突然关机造成的问题更多，因此Linux的关机有很多需要注意的地方

关机相关的常用指令：

	观察系统的使用状态：
	    使用who(谁)命令可以查看当前系统有哪些用户在使用，使用netstat -a可以查看网络联机状态，使用ps -aux可以看
	到正在执行的程序

	通知使用者关机的时间：
	    使用shutdown治疗可以达到这个功能

	将数据同步到硬盘：
	    sync：
		由于数据需要被频繁的修改，如果总是把内存中的数据写入硬盘中再去读取会很慢，所以在默认情况下，某些加
	    载到内存中的数据就不会被写入硬盘中，就算被重复的改写也只会在内存中操作，这样无疑速度会快上很多；如此一
	    来万一系统因为某些原因造成不正常关机就会造成数据不正常，这个时候就需要sync指令把数据从内存中写入到硬盘
	    中，在关机前最好多执行几次这个指令，虽然shutdown、reboot、halt等指令在关机前都会执行这个指令，不过多执
	    行几次总是放心点
		如果使用一般的账户执行sync指令只会同步自己的数据，如果是root账户则会更新所有的数据

	常用关机指令：
	    shutdown
		1、可以自由选择关机模式，关机重启均可
		2、可以设置关机时间
		3、自定义关机信息，在关机前可以将信息发送给在线用户
		4、发出警告信息，有时候需要进行一些测试，而不想被其它使用者干扰，就可以使用这个吓一下其它使用者

		格式：shutdown [option] [date] [info]
		shutdown -k：只发送警告信息
		shutdown -r：将服务停掉后重启
		shutdown -h：将服务停掉后关机
		shutdown -c：取消正在进行的shutdown
		以上如果没有指定时间则默认一分钟
		示例：shutdown -h 10 'will shutdown 10 mins after'
		以上指令将会在十分钟后停机并立即发送警告，旧版本的一定要加上时间，不然会跳到单人维护模式，这个版本
	    会默认在一分钟后执行
	时间选项：
	    now：立刻执行
	    20:25：将会在下一个20:25执行
	    +10：十分钟后执行
		

	重启，关机：
	    reboot、halt、poweroff：
		这三个指令执行的函数库都差不多，所以当使用man reboot时，这三个指令的说明会同时出现，其中reboot是重
	    启，halt是系统停止，poweroff是系统关机，关机和停止的区别是关机会切断电源，啥都显示不了，停止的话屏幕可
	    能会保留一些信息
		基本上这几个指令都会去执行systemctl这个命令

	systemctl：
		这个指令非常复杂，是管理系统使用的，目前只干涉到关机的部分
	    重启：systemctl reboot
	    关机：systemctl poweroff
	    停止：systemctl halt
	    休眠：systemctl suspend

	由于关机/重启是很重要的行为，因此只有root才能够执行shutdown、reboot等指令，不过某些distributions中允许在
tty1-tty7中可以用一般的账号来关机或重启(tty1-tty7就是按下ctrl+alt+F1~F7切换的界面)，如果是远程管理工具的话就只能用
root账户来关机了，但某些distributions要在关机时输入root密码

	切换到root账户：
	    执行su -，执行后就要输入密码，密码正确后就会切换到root用户了

任意文件都具有[User、Group、Others]三种身份的权限：
	文件拥有者User：
	    文件的拥有者可以对这个文件进行读写

	群组Group：
	    拥有者可以创建一个群组，并为文件指定这个群组，只有加入这个群组的用户才能对这个文件进行读写

	其他人Others：
	    其他人就是不属于群组和拥有者的用户，有些文件会对其它人的身份开放一些权限，比如读和执行

	root：
	    root账号可以无视任何权限限制

    Linux中所有的账号与身份都记录在/etc/passwd文件内，个人密码记录在/etc/shadow下，组名都记录在/etc/group下，目前
的系统并没有这几个文件夹，当前的版本是CentOS Linux 7，Kernel 3.10.0

    ls指令：
	ls是list的意思，主要是显示文件与文件名相关属性

	ls -al params：
	    列出所有文件的详细权限与属性，包括隐藏文件，params可以写表达式，比如file1*，就只展示file1开头的文件
	，不过要加-d参数才能只列出当前目录下的文件

		第一列：权限
		    权限一共有十个字符，比如：-rwxrwx---，第一个是文件类型，然后每三个分别是拥有者、群组和其他人的
		读、写、执行权限，比如上面的例子第一个字符是-：这个字符如果为[d]则是目录，如果为[-]则是文件，如果
		为[l]则是链接文件，如果为[b]则是配置文件里的可随机存取装置，如果为[c]则是串行端口设备；第二到第四
		个为rwx，说明拥有者有读写执行的权限；第五到七为rwx，说明群组有读写执行权限；第8到10是---，说明其他
		人没有权限进行任何操作
		    注意：如果用户拥有文件夹的读权限，没有执行权限，是不能进入文件夹的，因为进入文件夹需要执行权限
		，就算权限是---------，root用户也可以进行任何操作，因为它可以无视权限限制

		第二列：连接数量
		    每个文件都会将他的权限与属性记录到文件系统的i-node中，每个i-node就是一个文件夹，每个文件夹都会
		关联到一个i-node(另一个文件夹)下面，而这个属性代表了它的下级目录有多少个文件夹，也就是这个i-node下
		一级有多少个i-node

		第三列：拥有者
		    该文件拥有者的账号

		第四列：群组
		    该文件所属群组

		第五列：文件大小
		    该文件的大小，默认单位为byte

		第六列：修改日期
		    该文件最后修改日期，如果年份较远，则只会显示日期，如果想显示完整时间日期，可以使用
		ls -l --full-time来显示

		第七列：文件名
		    文件名，如果是以.开头，则代表隐藏文件

	ls：显示所有的非隐藏文件的名称

	ls -a：显示所有文件的名称

	加了-a能显示所有的，加了-l能显示属性，-al显示发所有的属性

    chgrp(change group)p：改变文件群组
	chgrp [-R] group fileName，例如：chgrp test1 init.cfg，把init.cfg文件的群组改为test1，如果在chgrp后面加上
    -R，就会进行递归变更，那么这个目录下的所有文件、目录都会成为这个群组，如果该群组不存在，就会报错误说找不到这个
    群组，所有群组都存在/ect/group目录下，我这个版本实际上找不到该目录
	
    chown(change woner)：改变文件拥有者
	chown [-R] owner:group 文件，例如：chown user1:group1 file1.txt，把file1.txt的拥有者改为user1，群组改为
    group1，也可以只改群组，也就是不写user1，只写:group1，冒号:可以改为点.，效果一样，不过冒号不容易有用户名冲突，
    这个同样可以加-R，效果相同

    chmod：改变文件权限
	chmod [-R] 777 file1.txt：将file1.txt的3种角色权限改为读写执行，777分别是：读=4，写=2，执行=1，读写执行就
    是7，只有读和写就是6，3个7分别代表3个角色：拥有者、群组和其他人
	除了这种方式之外，还可以指定不同角色的权限，比如chmod u=rwx,go=rx fileName，这句指令的意思是：fileName文件
    的拥有者指令改为读写执行，群组和其他人的权限改为读执行，如果要把所有人的的权限都改为只读，可以用chmod a=rwx file
    ，a代表所有权限，如果想去掉所有角色的执行权限，并且其他权限保持原样，则可以用chmod a-x fileName，-的意思是去掉
    权限，同理，+是加上权限，=是直接覆盖

    每种权限对于文件的具体含义：
	r：可读取此文件的内容
	w：可以编辑、新增或修改该文件的内容，但是不能删除
	x：可以让系统执行该文件，在linux中，一个文件是否能被执行取决于扩展名，在Linux中则取决于有没有x权限，当然，
	   能被执行和能成功的被执行是两回事

    每种权限对于目录的具体含义：
	r：只可以读取目录的名称，不能看到权限、文件夹大小、目录结构等信息，因为这些需要x权限进去才能获取到，r并不
	   是必须的，因为文件夹没有r，只有w也能顺利进入，r只能决定了是否可以看到这个文件，比如使用tab时能否自动补
	   齐，用ls时是否会显示这个目录，即时看不到也可以执行，因此一般开放目录都会开放rx权限，让用户能看到和进入
	w：可以新建、删除、重命名目录下的文件和目录，无论有没有那个文件的权限，还可以把文件粘贴到目录下
	x：能否进入该目录成为工作目录，工作目录就是当前的目录，也就是决定了该目录能不能成为当前目录，cd是切换目录，
	   如果没有x权限，则cd也无法切换进去

    文件和目录的区别在于，文件干涉具体的数据内容，目录则负责管理文件，因此文件的权限能决定对文件内数据处理，而目录
的权限则能决定该目录下的文件或目录的处理

    mkdir(make directory)：创建文件夹
	mkdir fileName

    touch fileName：创建新的空文件
	touch test/testFile，在test目录下创建一个名为testFile的文件
	
    rm fileName：删除文件

    rmdir dirName：删除文件夹

    Linux中的文件一般分为3种，分别是：普通文本、二进制文件和数据格式文件，数据格式文件就是特定格式的文件，比如登陆
信息都是保存在/var/log/wtmp文件内，这就是一个数据文件，该文件能用last指令读出来，但是用cat指令则会读出乱码

    Linux的链接文件类似于Windows的快捷方式

    虽然Linux不需要扩展名来决定程序是否能被执行以及怎样执行，但是通常还是会用适当的扩展名来表示该文件是什么类型，
常用的有*.sh：表示shell脚本文件，*Z、*.tar、*.tar.gz、*.zip、*.tgz都表示被打包的压缩文件，*.html、*.php就不用说了

    常用的文件系统，最大的文件或目录名允许最大为255byte，也就是255个英文或128个中文，文件命名最好避开特殊字符，比
如.、-、,、+等，.代表隐藏文件，-代表指令选项，,和+在修改角色的权限时有用到

    ~代表当前用户的家目录，~boc代表boc用户的家目录

    指令文件路径的时候，以/开头的会认为是绝对路径，否则都是相对路径，../代表上一层，./代表当前层

    特殊目录
	.：当前层目录
	..：上层目录
	-：前一个工作目录
	~：当前用户的家目录
	~boc：boc用户的家目录
    在所有目录下都会存在.与..目录，代表此层和上层目录，根目录也有.与..目录，仔细看会发现它的这两个目录的属性完全一
致，这代表根目录的上层目录依然是根目录

目录相关指令：

	cd(change Directory)：切换目录
	    参数可以填写路径，或者特殊目录，比如~代表当前用户的家目录，root用户则是/root，~boc则是去到boc用户的家
	目录，..代表上层目录，-代表刚才所在的上个目录，啥都不填就是代表家目录

	pwd(print working directoryy)：
	    显示当前目录，可以加-P选项，这样就会获取到最终的路径，比如如果是链接文件，就会显示链接到的路径，普通文
	件保持原路径

	mkdir：创建一个目录
	    -p参数可以自动创建上级目录，比如要创建test1/test2，可是test1还不存在，直接创建会报文件夹不存在，-p可以
	自动创建test1，-m可以在创建时指定目录的权限，如果不指定则用默认属性，示例：mkdir -p -m 711 t/t1/t2

	rmdir：删除一个目录
	    rmdir每次只能删除一个目录，并且只能是空目录，-p选项可以连通上层目录一起删除，比如rmdir -p t1/t2/t3，如
	果t3、t2、t1都没有包含其他文件与目录的话，这三个文件夹就会被一起删除，如果要强行清空目录，可以用rm指令

	rm：删除文件
	    -r选项可以删除多个文件，比如rm -r test，递归删除所有test前缀的文件与目录，也就是说子目录也会生效，-f参
	数则可以删除无需确认，跑路指令rm -rf /*的意思就是，删除根目录下的所有文件，且无需确认

	mv：移动文件
	    mv file dir，将file移动到dir目录下

    $PATH：
	所有能够执行的指令都会在$PATH变量下找，不同路径用:分割，可以通过echo $PATH去查看$PATH包含了哪些路径，
    在使用指令的时候会通过$PATH变量去找，最先找到的指令将会被使用，如果指令找不到可以去$PATH变量找找是否路径不
    正确
	
	如果想使用某一指令，而不想加入$PATH变量，可以使用绝对路径或者相对路径，不能直接去到目录里面使用，而是要
    用/和./来指定，因为当前路径./没有加入$PATH变量，这个路径最好不要加入，因为在公共目录如果有人恶意放一些常用
    指令，加了这个变量就会优先调用它的指令，最准确的方式还是使用绝对路径或者相对路径

    不同的用户可以使用的指令也不相同，比如root用户就会有/root/bin路径，而一般的用户则会有/home/boc/bin路径

    修改变量：
	PATH="xxx"，这种方法可以修改PATH变量，PATH="${PATH}:/root"，这种方式可以引用其它变量，现在$PATH变量就
    会加上:/root路径了

文件相关指令：
	ls(list)：
	    -a：全部文件与文件夹，以文件名排序
	    -A：全部文件与文件夹，不包括.(当前层)和..(上一层)，以文件名排序
	    -d：列出目录本身，也就是.
	    -f：列出结果，不排序
	    -h：将文件的容量以易读的方式列出来
	    -i：列出inode号码
	    -l：列出列表的数据包含文件的属性权限等
	    -n：列出UID与GID而不是使用者和群组
	    -r：反向排序
	    -R：递归列出子目录
	    -S：将文件按照容量大小排序
	    -t：按照时间排序
	    --color=never：不使用颜色
	    --color=always：使用颜色
	    --color=auto：系统自动判断是否使用颜色
	    --full-time：显示完整的时间
	    --time=atime或ctime(这两个在文件时间部分有介绍)
	很多时候会把ll预设成ls -l

	cp -options source1 source2 dest：复制
	    无：直接进行复制，如果目标是链接文件也会复制源文件
	    -d：如果文件为链接文件，则复制链接文件，而非文件本身
	    -f：如果目标文件已存在，则覆盖后再复制
	    -i：如果目标文件已存在，则询问后再覆盖
	    -l：进行硬式链接
	    -p：连通文件的属性一起复制过去，权限用户时间等
	    -r：递归赋值，用来复制一整个文件夹
	    -s：复制为链接文件
	    -u：如果目标比源文件更旧或者目标不存在才复制
	    --preserver=all：除了-p的权限之外，SELinux的属性也被复制了，如links、xattr等
	    -a：相当于-dr --preserver=all
	如果有多个source，则dest必须是目录
	当使用属性复制选项时(-p-a等)，如果保持原来的权限当前用户无法对文件进行写入，那么拥有者就会改为当前用户，因
    为如果不改就无法对文件进行写入，无法完成复制
    
	rm -option fileName：删除文件或目录
	    -f：忽略不存在的文件，也就是当删除的文件不存在时不会出现警告
	    -i：删除前会询问
	    -r：递归删除，通常用来删除文件夹，这是个很危险的选项

	    rm -i bashrc*：删除所有以bashrc开头的文件，删除前会询问
	    root用户在删除的时候会默认加上-i选项，也就是每个删除都会询问，因为root用户有权限删除大量重要文件，如果
	不想要被询问，可以在rm之前加上\，也就是使用\rm指令来删除
	    如果删除的文件有特殊符号，比如文件名为-aaa-，那么可以使用rm ./-aaa-，这样系统就不会把文件名识别为选项了
	，还有一种方式，那就是用rm -- -aaa-，这样也能被正确识别

	mv -option source1 source2 dir：文件移动
	    无：文件移动到dest，如果dir里该文件已存在则报错
	    -f：强制移动，如果文件已存在则覆盖
	    -i：如果文件已存在则询问是否覆盖
	    -u：如果目标已存在，而源文件又比较新才会覆盖
	    
	basename file：获取该文件或目录的名称
	dirname file：获取该文件或目录所在的目录的绝对路径
	判断哪个是文件名哪个是目录名，通过判断是否以/开头就知道了，/开头的就是目录名

查看文件内容：
	
	cat(Concatenate)：从第一行开始显示文件内容
	    -A：相当于-vET选项，可以列出一些特殊字符
	    -b：打印行号，只有非空白行才会标行号，空白行不会
	    -E：将结尾的换行字符$显示出来
	    -n：打印行号，连空白行也会有行号
	    -T：将制表符以^I显示出来
	    -v：列出一些看不出来的特殊字符

	tac：从最后一行开始显示，其实他就是cat倒着显示
	    功能跟cat一致(猜测)

	more：一页一页的显示文件内容
	    在执行指令过程中，有以下按键可使用：
		空格：下一页
		enter：下一行
		/+字符串：代表在当前显示的内容中向下搜索这个字符串
		n：继续执行搜索
		:-f：显示文件名以及目前显示的行数
		q：离开more
		b或ctrl-b：往回翻页

	less：和more类似，不过它可以往前翻页
	    在执行指令过程中，有以下按键可使用：
		空格：下一页
		pagedown：下一页
		pageup：上一页
		/+字符串：向后搜索字符串
		?+字符串：向前搜索字符串
		n：继续搜索下一个
		N：反向搜索下一个
		g：去到第一行
		G：去到最后一行
		q：退出less
	    man就是用less来展示说明文件的内容

	tail：只看最后几行
	    -n：number属性，其它跟head一样，如果想略过前面100行，可以使用+100
	    -f file：检测文件到目标文件一更新就显示在屏幕上，检测持续到按ctrl+c才结束

	head：只看前面几行
	    head -n number file：显示前面的number行，如果-n number不填，默认为10行,number为负数则代表后面的number
	行不打印

	nl：显示的时候会显示行号
	    -b：行号的指定方式
		-b a：无论是否为空行，都列出行号，默认为空行不显示
		-b t：如果有空行，空的那行不要列出行号
	    -n：行号的显示方式
		-n ln：行号显示在最左方
		-n rn：行号显示在最右方，且不加0
		-n rz：行号显示在最右方，且加0，默认是6位
	    -w：行号字段占用的字符数

	od：以二进制的方式读取文件内容
	    -t：输出类型
		a：默认字符输出(二进制)
		c：ASCII字符输出
		d：用十进制来输出数据
		f：用浮点数来输出数据
		o：用八进制来输出数据
		x：用十六进制来输出数据
文件时间：
    每个Linux下的文件都会记录一些时间参数，分别是：
	修改时间(mtime)：
	    文件内容最后一次被修改的时间
	状态改变时间(ctime)：
	    文件属性最后一次被修改的时间，比如权限和名称等待
	被读取时间(atime)：
	    文件文件内容最后一次被读取的时间

修改文件时间：
    touch：
	无：把指定文件的三个时间属性更新到当前的时间，如果文件不存在则创建一个新文件
	-a：仅修改access time
	-m：仅修改modify time
	-c：如果文件不存在也不会创建新文件
	-d：指定想要修改的日期而不用当前的日期
	-t：指定想要修改的时间，而不是用当前的时间，格式为YYYYMMDDhhmm
	--date：指定日期或时间
	示例：
	    touch -d "2 days ago" file：将file的atime和mtime修改到当前时间的两天前
	    touch -t 201906150202 file：将filed的atime和mtime修改到指定时间，精确到分
	    ctime这个属性无法被修改，只有文件属性被修改的时候它才会被修改
	    
执行多个指令：
	如果在同一行中同时写多个指令，并且这些指令用分号分隔，那么这些指令将会被依次执行

文件默认权限：
	文件原本的默认权限：-rw-rw-rw-
	文件夹原本的默认权限：drwxrwxrwx

	umask：默认权限
	    无：显示4位数字，分别是特殊权限、拥有者权限，群组权限、其他人权限
		特殊权限先不谈，后面3位的权限是指默认值要减掉的权限，比如：0022，那么文件的默认权限减去0022，除去
		特殊权限不谈，就等于：666-022=644，也就是文件的默认权限是-rw-r--r--，文件夹同理，文件夹的默认权限
		：drwxr-xr-x。注意!被减去的权限只有存在时才会被减，如果有个权限本身只有6，而umask却减3，那么不会剩
		下3，而是4，因为是按照位算的，3代表1和2位，也就是后面2位，不能按照数值计算
	    -S：显示每个角色拥有哪些默认权限
	    number：直接在umask后面输入3位数字，就能更改默认被减去的权限了，当然每位最高只能是7

	root用户和普通用户的默认amask不同，root用户是022，普通用户是002，因为root用户的安全要求更高
	
文件的隐藏属性：
	chattr [+-=] -options file：修改文件的隐藏属性
	    +：增加某个特殊参数
	    -：减去某个特殊参数
	    =：设置某个特殊参数
	    -A：被访问时atime属性不会被修改，避免机器过度存取磁盘
	    -S：文件的修改会被同步写入磁盘，同步的作用参考sync指令
	    -a：文件内容只能被增加，root权限才能设置
	    -c：每次存取都会先经过压缩
	    -d：当dump程序执行的时候，该文件将不会被dump备份
	    -i：让该文件不能被删除、设置权限、改名、修改内容和设定链接，只有root权限可以设定此属性
	    -s：如果被删除了，就会被完全移出硬盘，无法恢复
	    -u：如果被删除了，还会存在于硬盘，可以恢复

	lsattr -options file：查看文件的隐藏属性
	    无：显示文件的隐藏属性
	    -a：显示隐藏文件的隐藏属性
	    -d：显示目录本身的隐藏属性
	    -R：连子目录的数据也列出来

文件特殊权限：
	
	SUID：
	    SUID是Set UID的简称，在拥有者执行权限的位置不会显示x,而是s，它有以下限制与功能：
		1、SUID权限仅对二进制程序有效
		2、执行该程序需要具备x权限
		3、本权限仅在程序执行过程中有效
		4、在执行该程序的过程中会获得该程序的拥有者权限
		5、对目录无效
	    比如/usr/bin/passwd指令，任意用户可以通过它修改自己的密码，它的拥有者是root，拥有者权限是rws，而密码所
	在的文件在/etc/shadow目录下，权限全是-，只有root用户能进行操作，passwd指令可以让用户暂时性拥有root的权限，
	从而去修改密码文件
	    所以看起来就是让使用者在使用自己程序的时候短暂开放自己的权限

	SGID：
	    SGID是Set GID的简称，在群组执行权限的位置不会显示x,而是s，它有以下限制与功能：
		1、SGID只对二进制程序有效
		2、执行该程序需要具备x权限
		3、在执行该程序的过程中会获得该程序的群组权限
		4、与SUID不同的是，SGID可以用在目录上
	    当用在目录上时他将具有以下功能：
		1、用户只有对目录具有r与x权限才能进入该目录
		2、用户在此目录下的有效群组将会变成该目录的群组，就是获得该目录群组权限的意思
	    SGID与SUID差不多，一个是针对拥有者，一个是针对群组，他们的名称区别也是一个U一个G

	SBIT：
	    SBIT是Sticky Bit的简称，它具有以下限制与功能：
		1、只对目录有效
		2、用户必须对目标目录具有rwx权限
		3、在该目录下，只有目录或文件的创建者和root用户有权删除文件
	    比如/tmp目录，它的权限是drwxrwxrwt，那么按理来说对于A用户在里面建立的文件或文件夹所有的用户都能删除，
	因为other具有w权限，但是由于其他人的x权限是t，因此A用户建立的文件或文件加只能被自己删除，当然root用户也能

总结：
	SUID让执行者在该程序中暂时拥有该程序拥有者的权限
	SGID让执行者在该程序中暂时拥有该程序群组的权限，如果是文件夹则在文件夹的子目录下都用该该文件夹的群组权限
	SBIT让某个目录下的文件只能被创建者和root用户删除

特殊权限设置：
	同样使用chmod，原本是chmod 3位数字 file，现在是4位数字，第一位数字代表特殊权限：4为SUIC，2为SGID，1为SBIT
	示例：chmod 6755 test，结果是test文件的权限更改为-rwsr-sr-x，使用者和群组的执行权限都变为s了
	SUID会改变使用者的x为s,SGID会改变群组的x为s,SBIT会改变其他人的x为t
	使用字母设置示例：chmod g+s,u+s,o+t，把三个权限的特殊权限都设置上
    注意：
	当特殊权限显示为大写的时候，比如-rwSrwSrwT，则说明特殊权限为空，因为虽然给设置了特殊权限，但是当前用户没有
    执行权限，因此特殊权限无法生效，特殊权限是在执行权限升级而来
	
查看文件类型：
    通过file指令可以简单的查看目标文件是什么类型，示例：
        file file.db，结果可能会为file.db: data，意思是这是data文件

搜索指令与文件：
    which -option command：在PATH路径中搜索命令
	无：列出PATH目录中第一个找到的目标命令的绝对路径
	-a：列出PATH目录中所有能找到的目标命令的绝对路径

    whereis -option fileName：在特定目录中搜索文件名
	无：直接去目标目录进行寻找文件
	-l：列出whereis会去哪几个目录查询
	-b：只找二进制(binary)格式的文件
	-m：只找在说明文件man目录下的文件
	-s：只找source来源文件
	-u：搜索不在上述三个选项中的其它特殊文件，也就是非man目录下，非来源文件和非二进制文件

    locate -option fileName：在数据库里搜索文件
	无：直接去数据库里面找对应的文件或目录名
	-i：忽略大小写差异
	-c：计算找到的文件数量
	-l：仅输出几行，-l后面跟着行数，比如-l 5，就是仅输出5行
	-S：输出locate所属用的数据库文件信息，比如数据库记录的文件/目录的数量等
	-r：后面可接正规表示法的显示方式
        注意：因为数据库是每天更新一次的，因此新建的文件可能搜索不到
    updatedb：立即更新数据库
	这个指令会去读取/ect/updatedb.conf配置文件，然后在硬盘里搜索文件名来更新数据库，因此会比较慢

    find PATHs -option：在硬盘进行文件搜索
	时间搜索：
	    -mtime n：查找n天之前的那一天被改过内容的文件，0代表今天
	    -mtime +n：查找n天之前(不包含n天本身)被修改过内容的文件
	    -mtime -n：查找n天之内(包含n天本身)被改过内容的文件
	    -newer file：查找比file还要新的文件
	    -f是代表修改时间，还有-atime和-ctime分别代表访问时间和创建时间，用法都和-mtime一样
	    示例：find /tmp -mtime 0：查找/tmp目录下在一天内被修改过的文件
	拥有者搜索：
	    -uid n：搜索目录下所有uid等于n的文件，UID是账号对应的ID
	    -gid n：搜索目录下所有gid等于n的文件，GID是群组对应的ID
	    -user name：搜索所有拥有者名称等于name的文件
	    -group name：搜索所有群组名称等于name的文件
	    -nouser：寻找文件的拥有者不存在于/etc/passwd的文件
	    -nogroup：寻找文件群组不存在于/etc/group中的文件
	    注意：当用户被删除了或者安装第三方软件就会不存在的拥有者或者群组
	    示例：find /home -user boc：搜索/home目录下所有拥有者为boc的文件
	文件权限与名称搜索：
	    -name fileName：搜索文件名，可以用*来进行模糊匹配
	    -size [+-]SIZE：搜索比SIZE还要大或小的文件，50c代表50type，50k代表50kb
	    -type TYPE：搜索指定类型的文件，常见类型：一般文件：f，配置文件b、c，目录d，链接文件：l，socket文件s
	    -perm mode：搜索权限刚好等于mode的文件，比如搜索-perm 0744，那么就会搜索所有权限等于-rwxr--r--的文件
	    -perm -mode：搜索权限包含mode的文件，比如mode是0744，那么文件为-rwxr-xr-x也会被搜索出来
	    -perm /mode：搜索权限包含mode里任意某个权限的文件，比如mode是755，那么-r--------也会被搜索出来，因为它
			 的r在mode中有存在
	    示例：find /tmp -perm /7000：搜索所有有特殊权限的文件
	特殊功能：
	    -exec command：将搜索到的结果执行新的指令，指令不能是别名，比如ll
	    -print：将结果打印到屏幕上，这是默认使用的
	    示例：find /tmp /home -perm /7000 -exec ls -l {} \;：搜索/tmp和/home目录下所有拥有特殊权限的文件，并把
		  它们的属性信息打印出来，{}代表find的结果，-exec是额外功能的起始，\是额外功能的结束，期间就是要执
		  行的指令，;在bash环境下有特殊含义，\用来转义

	df：用来查询文件系统的磁盘使用情况
	    -i：显示inode的数量
	    -h：将数值以易懂的方式显示，比如M\G\K等
	    -T：同时显示分区的文件系统名
	    -a：列出所有的文件系统

	文件系统中有多个分区槽，每个分区槽都有容量上限，一但某个分区槽满了，就算上级目录还有空间，这个分区槽也无法
    再添加任何文件了，比如/dev在/下面，就算/还有空间，如果/dev满了那么/dev就无法新增文件了
	
	/proc挂载点里面的东西都是在内存中的，因此不占磁盘容量

	du：评估文件系统的磁盘使用量，不指定目录则评估当前的目录
	    -a：列出所有文件与目录的容量
	    -h：以易懂的方式显示容量
	    -s：列出总量
	    -S：列出总量，不包括子目录

	ln：实体链接与符号链接
	    默认是实体链接(hard link)
	    -s：进行Symbolic link链接
	    -f：如果链接文件存在，就将链接文件删除再创建
	    示例：ln -sf /tmp(链接的目标文件) /boc/tmp(新的链接文件)

	符号链接(Symbolic Link)：类似Windows的快捷方式，创建新的链接文件
		新建的文件在读取数据时会指向它链接的那个文件，由于只是指向文件，因此源文件被删除了，符号链接也就无
	    法打开了

		用法：ln -s 要链接的文件 链接文件

		由于Symbolic Link会建立一个独立的新文件，因此会占用inode和block

		Symbolic Link可以链接文件夹

	实体链接(Hard Link)：通过文件系统的inode链接产生新的文件名，而不是新文件
		也就是两个文件链接到同一个inode号码，这种情况下两个文件除了文件名，其它所有信息都会一样，如果使用
	    ll查看目录信息，会发现权限后面的列是一个数字，这个数字代表着这个inode号码被多少个文件链接了

	    用法：ln 要链接的文件 链接文件

	    使用这种方式的好处是，无论删除了哪个文件，实际上的文件inode和block还是存在的，并且在任意链接文件中都能
	对该文件进行修改

	    并且使用hard link(实体链接)也不会增加磁盘的空间和inode的数目，当然如果建立这个链接所需的容量刚好把上一
	个block填满，也是会修改磁盘空间的，不过因为很小，一般都不会

	    hard link不能跨文件系统，也不能链接目录，由于如果链接目录，则这个目录下面的所有文件也都要链接，并且新
	增删除目录下的文件也要多其它的链接做处理，环境会变得很复杂，因此暂时不支持

文件与文件系统的压缩、打包和备份：
	
	Linux系统中，压缩文件的扩展名大多是：tar、tar.gz、tgz、gz、Z、bz2、xz

	虽然扩展名在Linux下没用，但是因为Linux支持的压缩指令很多，并且不同的压缩指令的压缩技术不同，因此无法互相解
    压文件，因此用不同的后缀来对压缩文件进行区分

    压缩单个文件：

	gzip -option filename：
	    gzip是应用最广泛的压缩指令，目前可以解开compress、zip、gzip等压缩文件，它的文件名后缀为gz
	    -c：将压缩后的数据输出到屏幕上，可通过数据量重导向来处理
	    -d：解压缩
	    -t：检验压缩文件有无错误
	    -v：压缩后显示原文件/压缩文件的压缩比例信息
	    -n：n是一个数字，代表压缩等级，1最快，9最慢，越快压缩比例越差，默认是-6
	    注意：压缩后源文件就不存在了，而是变成源文件+.gz后缀的压缩文件，而gzip -d后.gz后缀的压缩文件也会消失，
	变成无后缀的源文件

	    使用gzip -c source > target可以保留源文件

	zcat：显示gzip压缩文件解压缩后的内容

	egrep：在压缩文件中查找数据

	bzip2 -option filename：
	    bzip2是为了取代gzip而来的，比gzip压缩比例更高，也需要更多时间，其后缀名是.bz2
	    -k：保留源文件
	    其它的参数与gzip一样

	bzcat：显示bzip2压缩文件解压缩后的内容

	bzgrep：在压缩文件中查找数据

	xz -option filename：
	    相比bzip2，压缩比进一步下降，时间也需要更长，文件后缀为.xz
	    参数几乎一样

	xzcat：显示xz压缩文件解压缩后的内容

	以上指令虽然能对目录进行压缩，不过只是将目录内所有文件分别进行压缩，因此会产生很多压缩文件

打包多个文件：
	
	tar -option newFilename sourceFilename1 sourceFilename2...：
	    将多个文件或目录进行压缩，压缩为一个文件
	    -c：打包
	    -t：查看被打包的文件
	    -x：解包
	    以上三个只能同时使用一个
	    -z：通过gzip进行，打包后的文件名最好为.tar.gz
	    -j：通过bzip2进行，打包后的文件名最好为.tar.bz2
	    -J：通过xz进行，打包后的文件名最好为.tar.xz
	    以上三个只能同时使用一个
	    -v：在打包或解包过程中显示正在处理的文件名
	    -f filename：打包后的文件名或准备解包的文件名，还有第二个参数可以指定要解包的文件，也就是只解包部分，具
	                 体可以解包的文件名有哪些可以用-t查看，如果里面的文件没有根目录，那么这里也不能加根目录
	    -C dir：解包后文件放在哪个目录，默认是本目录
	    -p：保留打包数据的权限和属性
	    -P：保留打包数据的绝对路径
	    --exclude=file：在打包时排除file，这个选项可以同时使用多次，并且能使用*当通配符
	    --newer-mtime="2015/06/07"：仅打包mtime大于指定日期的文件，同理能使用atime和ctime
	示例：
	    打包：tar -cjv -f /tmp/file.tar.bz2 /tmp：将tmp用bzip2打包成file.tar.bz2，保存在tmp目录下，过程中显示正在处理的文件
	    查看：tar -tjv -f /tmp/file.tar.bz2：用bzip2查看/tmp目录下的file.tar.bz2的文件，过程显示正在处理的文件
	    解包：tar -xjv -f file.tar.bz2 -C /tmp/tar：将file.tar.bz2用bzip2解包放到/tmp/tar下，过程中显示正在处理的文件
	注意！tar打包不会自动产生文件名，.tar.bz2是自己取的，-cjvf是可以的，但是-cjfv不行，因为-f后面要跟着文件名
	    在tar前面加上time，在使用-v时会显示每个文件花费的时间
	    在默认情况下，打包的文件会移除掉根目录，也就是前面的/，这是为了防止，比如要备份/etc下的数据，打包出来
	如果有根目录就会把/etc下的文件覆盖掉，去掉的话在如果在/tmp解压，目录就会变成/tmp/etc/xxx了，因此在打包时会
	出现一个移除/的警告，如果确定就是要解压到根目录，可以使用-P选项
	    如果打包时没有指定压缩算法，那就不会进行压缩，这种打包文件称呼为tarfile，如果指定了压缩算法则称呼为tarball

vi编辑器：
    vi的优点：	
	1、vi编辑器是所有Unix Like系统都会内置的编辑器
	2、有很多软件的编辑接口都会主动使用vi
	3、vim具有程序编辑的能力，可以以字体颜色区分语法的正确性
	4、编辑速度快

	vim是vi的进阶版，vim有颜色或底线等显示方式，比如打开程序文件，vim会根据文件的扩展名或文件的开头信息判断文
    件的内容类型而自动判断程序的语法，再以颜色来显示代码和一般信息，所以vim可以看成程序编辑器，vi则是文字编辑器

    vi有三种模式：
	一般指令模式：
	    用vi打开一个文件默认就是一般指令模式，在这个模式下可以用上下左右移动光标，可以删除字符或整行，也能复制
	粘贴

	编辑模式：
	    按下i、o、a、r等键时就会进入编辑模式，不区分大小写，编辑模式左下方会出现INSERT或REPLACE等字样，这个模
	式下才能修改文件内容，如果要回到一般指令模式可以按Ese键来退出编辑模式

	指令行命令模式：
	    按下:/?三个键中的任意一个(注意有些符号要按shift才能出来)就能将光标移动到最底一行，进入指令行命令模式，
	在这个模式中可以进行搜索文本、读取、保存、替换、退出vi、显示行号等操作，同样可以通过Esc退出到一般指令模式

	一般指令模式能与其它两个模式相互切换，其它两个模式无法相互切换

	在一般指令模式下：
	    crtl+f：下移一页
	    ctrl+b：上移一页
	    ctrl+d：下移半页
	    ctrl+u：上移半页
	    +：移动到下一个非空页
	    -：移动到上一个非空页
	    n+空格：向右移动n列
	    0(Home)：移动到该行的第一列
	    $(End)：移动到该行的最后一列
	    H：移动到屏幕的第一行
	    M：移动到屏幕的中间那一行
	    L：移动到屏幕的最后一行
	    G：移动到文件的最后一行
	    nG：移动到第n行
	    gg：移动到第一行，相当于1G
	    n+Enter：向下移动n列
	    /word：向下搜索word字符串
	    ?word：向上搜索word字符串
	    :noh：取消搜索后的高亮	 
	    n：继续前一个动作，比如继续执行刚才的搜索   
	    N：反向进行刚才的动作，比如刚才向上搜索，N则会往下搜索
	    :100,200s/w1/w2/g：在100到200行之间将所有的w1替换成w2
	    :10,$s/w1/w2/g：在第10行到最后一行之间将所有的w1替换成w2
	    :5,$s/w1/w2/gc：在第5行到最后一行之间将所有的w1替换成w2，在替换之前会让用户确认是否替换
	    x：删除后一个字符
	    X：删除前一个字符
	    nx：删除后面n个字符
	    dd：删除一整行
	    ndd：删除下面n行
	    dnG：删除当前行到第n行的所有数据
	    dG：删除当前行到最后一行的所有数据
	    d$：删除当前行游标所在后面的数据
	    dn+方向：删除n行或n列，这取决于d+数字之后按那个方向键，上下左右都行
	    yy：复制当前行，仅仅是复制，如果要使用还要另外进行粘贴
	    nyy：复制光标行到下面的n行
	    y1G：复制光标行到第一行的所有数据
	    yG：复制光标行到最后一行的所有数据
	    p：将所有复制的数据在下一行进行粘贴
	    P：将所有复制的数据在上一行进行粘贴
	    J：将当前行与下一行合成一行
	    u：撤销上一次操作
	    crtl+r或.：重复上一次操作
	    n+方向：往哪个方向移动n位

	进入编辑模式：
	    i：进入插入模式，会在光标的位置插入，其它插入模式不同之处就是光标出现的位置不同
	    r：进入取代模式，会去到光标所在位置的字符，只能取代一次
	    R：进入连续取代模式，可以连续输入取代光标所在的字符

	指令行命令模式可用操作：
	    :w：将数据写入硬盘
	    :w!：将数据强制写入硬盘
	    :q：离开vi
	    :q!：强制离开vi不保存修改
	    :wq：保存(write)并(quit)退出
	    :wq!：没有写入权限的情况下，使用wq!会强制写入，这个在权限可以改变的情况下能生效，比如拥有者没有写入权限
	    ZZ：如果没改过，则不保存离开，如果改过则保存后离开
	    :w filename：将数据保存到filename，类似于另存为
	    :r filename：加载filename，并将加载的数据添加到游标所在行的后面
	    :n1,n2 w filename：将n1到n2的内容保存到filename
	    :! command：暂时离开vi，并执行command，比如:! ls /home，则会显示/home下以ls的文件信息
	    :set nu：显示行号
	    :set nonu：隐藏行号
	    :e!：撤回编辑过的操作，还原文件的原始内容

    现在打开vi其实就是vim，可以通过alias看到vi就是vim的别名

    vim的暂存和恢复：
	在vim的一般指令模式中，按下ztrl+z就会在同目录下出现一个隐藏的同名文件，这个隐藏的文件名是.源文件名.swp，这
    个文件的作用是暂存未保存的记录，并且在将来能恢复该记录，如果用vim打开某个文件，并且这个文件同目录下有它的.swp
    文件，那么就会出现一个警告界面，出现这个界面可能是有其他人正在编辑，也有可能是因为某些未知原因导致vim中断，这
    个界面下可以按以下几个按键进行不同的选择：
	[O]pen Read-Only：以只读方式打开
	[E]dit anyway：还是正常打开文件，不过这样可能出现多个用户改变同一文件
	[R]ecover：加载.swp暂存文件的内容
	[Q]uit：退出
	[A]bort：行为上也是退出
    只要.swp暂存文件存在，每次进入都会出现警告界面，如果已经保存了暂存的内容或者想丢弃，就要手动删除该文件了

    批量复制和删除：
	v：批量选择字符
	V：批量选择行
	ctrl+v：区块选择
	y：复制被选择的地方
	d：删除被选择的地方
	p：粘贴刚才复制的内容

    多文件编辑：
	:r filename：加载目标文件
	:n：编辑下一个文件
	:N：编辑上一个文件
	:files：列出vim正在编辑的所有文件
	vim file1 file2...：直接打开多个文件
    多文件编辑能同时编辑多个文件，并且能在多个文件间互相复制粘贴

    多窗口：
	:sp filename：如果不输入filename，则重新在新窗口打开当前文件
	ctrl+w，松开后按上下键：切换窗口
	ctrl+w，松开后按q：离开当前窗口

    补全：
	ctrl+x，然后ctrl+n：根据文字内容补全
	ctrl+x，然后ctrl+f：根据文件名补全
	ctrl+x，然后ctrl+o：根据文件扩展名以vim内建的关键词补全

    vim环境设置：
	/etc/vimrc：vim的全局配置
	~ /.viminfo：vim的操作记录，比如上次进入文件光标停留在什么位置等等
	~/.vimrc：用户个人的vim配置，如果没有可以自己创建
	:set all：可在一般命令环境下使用查看所有设置
	
    tty1-7默认不支持中文编码，所以一定会看到乱码，狗日的第九章才说!

编码转换：
    iconv -f 原编码 -t 新编码 filename [-o newFile]：
	--list：列出所有支持的编码
	-f：原来的编码
	-t：新的编码
	-o：保留原来的文件，并指定新文件名

BASH(Boume Again SHell)：

    SHell是壳的意思，也就是壳程序，因为操作系统内核需要去操控硬件，如果直接让用户操作内核，那么由于很多用户不熟悉
硬件，因此不能直接开发内核给用户，可是用户又需要对操作系统进行操控才能使用，因此出现了SHell，SHell就是给普通用户操
控内核的一个程序，SHell的功能就是提供用户操作系统的一个接口，而bash其中一种SHell，与bash类似的有CSHell、K SHell、
TCSH等等

    在/etc/shells中可以看到当前可用的所有shell

bash的特点：

    记忆使用过的指令：
	在bash中，只需要在指令列按上下键就能找到前面或后面输入的指令，在很多发行版本中，默认的指令能记忆1000个，这
    些指令都记录在~/.bash_history，这里记录的都是前一次登陆以前所有执行过的指令，当前这次的都在内存中，因此不在其
    内，这个功能可能会暴露一些隐秘信息，比如输入指令时参数带着密码

    命令补全：
	第一个单词按tab补全命令，第二个单词之后按tab补全路径，按两次tab展示当前所有可选列表，如果安装了bash-completion
    ，在某些指令后面按tab可以补全选项或参数

    命令别名：
	可以给一串带着参数和选项的指令指定别名，比如ls -al指定为ll，这样在输入很长指令的时候就能省很多事了
	使用方式：alias lm='ls -al'，通过alias可以查看所有别名

    工作控制、前景背景控制：
	前景背景控制可以让工作进行更顺利，工作控制可以让工作后台执行

    程序化脚本：
	Linux下的shell scripts可以将平时管理系统的常用连续指令写成一个文件，该文件可以通过交互式的方式来进行主机的
    侦测工作，也可以由shell提供的环境变量和相关指令进行设计。几乎可以看成一个小型的程序语言了

    通配符：
	可以通过通配符*来进行匹配，比如ls -d /usr/bin/X*，能查看/usr/bin下所有以X开头的文件

bash的基础用法：

    type -options name：查询指令是否由bash提供
	无：显示name是外部指令还是bash内部指令
	-t：type会显示name的其他意义，file代表外部指令，builtin代表内部指令，alias代表该指令是其它指令的别名
	-P：只有name为外部指令才会显示完整文件名
	-a：将PATH中所有匹配name的指令都列出来，包括别名，并以调用优先顺序排序

    删除输入的指令：
	crtl+u：删除光标前面的指令
	ctrl+k：删除光标后面的指令
	ctrl+a：让光标移动到最前
	ctrl+e：让光标移动到最后

Shell的变量：
    
    环境变量：
	比如PATH、HOME、MAIL、SHELL等，可以通过echo $变量名 查看，为了区别于普通变量，环境变量通常用大写字符来表示
    ,通过export使普通变量变为环境变量

普通变量的使用：

    读取变量：
	echo $变量名或者echo ${变量名}
    
    设置变量：
	变量名=值
	注意事项：两边不能有空格存在，有空格则要用单引号或双引号包起来；开头不能为数字；使用双引号时内容可以包含特
    殊字符，如在值里使用$引用其它变量；用单引号则只会当做普通字符处理；可以使用\对特殊字符进行转义，比如\$空格等，
    转义的值不需要再加引号；引用其它指令可以用$(指令)或者`指令`来获取该指令的结果；当引用变量与其他的值累加，可以
    使用${变量名}或"$变量名"进行引用，比如PATH="$PATH":/home/bin；使用export使变量变成环境变量；环境变量通常为大写
    ，自定义变量通常为小写

    取消变量：
	unset 变量名

    在执行指令的时候，可以通过使用变量来把该变量插入指令的参数中，比如cd /home/${name}，可以打开当前用户的家目录；
而用`command`可以将所执行指令的结果返回给当前指令使用，使用$(command)也能执行括号中的指令

环境变量的使用：

    查看环境变量：
	env(environment环境)：
	    显示当前所有的环境变量
	常用变量的含义：
	    HOME：当前用户的家目录，使用cd ~或cd就能去到家目录就是根据这个变量跳转的
	    SHELL：当前使用的SHELL是引用哪个程序文件，默认是/bin/bash
	    HISTSIZE：记录历史用过指令最大数目
	    MAIL：当前用户的邮箱目录
	    PATH：执行指令的时候会去PATH中指定的路径去寻找对应指令
	    LANG：当前使用的语言
	    RANDOM：返回一个随机数，0~32767

	set：
	    显示所有变量，包括环境变量与自定义变量
	常用变量的含义：
	    PS1：命令行前面的那一串[boc@study /] $，这个是可编辑的，并且每个用户都能自定义，可用变量代表的信息：
		\d：星期 月 日
		\H：完整的主机名
		\h：主机第一个小数点之前的名字
		\t：显示时间，24小时制，精确到秒
		\T：显示时间，12小时制，精确到秒
		\A：显示时间，24小时制，精确到分
		\@：显示时间，12小时制，am/pm格式
		\u：当前账号名称
		\v：BASH的版本信息
		\w：完整工作目录名称
		\W：最后一个目录的名称
		\#：当前这个指令是用过的第几个指令
		\$：提示字符，root用户为#，普通用户为$
		默认PS1=[\u@\h \W] \$
	    $：$本身也是一个变量，它代表当前的PID(Process ID)，可使用$$来获取
	    ?：上一个执行的指令的返回值，执行正常会返回0，非0都是异常

	export：
	    不添加任何参数与选项的情况下展示所有环境变量
	    或者将指定的自定义变量转成环境变量

	当在某个程序中定义一个变量时，这个变量就会在这个程序中可用，比如刚进入linux系统时就会自动进入一个bash程序，
    如果在这个bash程序中打开另外一个程序，比如ls，那么这个bash程序是父程序，ls就是子程序，当进入子程序时父程序会进
    入休眠。在子程序中是看不到父程序定义自定义变量的，如果想在子程序中引用父程序的变量，就需要把自定义变量用export
    转成环境变量。
	所以export就是让进入程序后使用其它指令的时候能随时找到这个变量，通常在主文件中会定义这种变量给其他附属文件
    使用，如果重启或者切换到其它tty，或者注销用户重新登陆，那么export所设置的环境变量就会消失

语言相关：
	
	Linux主机的终端机接口环境下无法显示中文，需要加装一些中文化接口的软件

    locale：
	无：展示所有功能的语言设置，这些信息存储在/etc/locale.conf中
	-a：展示当前支持的所有语言
	如果其他功能的语言没有设置，那么就会使用LANG的值，而LC_ALL并不是环境变量，因此一般情况下不会生效，如果要生
    效需要用export将它设置成环境变量

用户交互：
	
    read [-option] variable：将用户输入的值转换进variable指定的变量中
	无：出现空行白等待输入
	-p：提示字符
	-t：等待秒数

    declare -option variable=value：定义变量类型
	无：跟set一样显示所有变量
	-a：将变量定义为数组
	-i：将变量定义成整型，如果变量的值是表达式，就会进行计算比如变量原本是100+200，使用这个参数后就变成300
	-x：将变量定义为环境变量
	-r：将变量定义为只读，不能修改，也不能unset
	-用来定义类型，+用来取消定义，因为变量定义了-i之后值就不能变为为字符串了，因此需要取消功能
	注意：value必须有，如果只有变量，那么变量里就算原本有值也不会进行转换，而是需要：变量名=$变量名进行重新赋值
	如果不小心将变量设置为只读，那么只有注销后重新登陆才能恢复类型了，是重登后变量消失后重新声明的意思吗？

    bash中变量的默认类型是字符串，bash环境中的数值运算最高精度只能达到整型

    定义数组：
	var[1]=xxx：定义一个var下标为1的元素，可以用${var[1]}取得，好像跟非数组一样...
	
    ulimit -option config：限制用户的系统资源
	-H：hard limit，严格的限制，一定不能超过这个数值
	-S：soft limit，警告的限制，可以超过，但是有警告，一般-S会比-H小一点，先警告再限制
	-a：列出所有的限制配置
	-c：核心文件的最大容量，将程序出错时，系统会将程序在内存中的信息写成文件，这就是core file
	-f：shell可以建立的最大文件容量，单位为K
	-d：程序可用的最大断裂内存容量
	-l：可用于锁定的内存量
	-t：最大可用CPU时间，单位为秒
	-u：单一用户能使用的最大程序数量
	注销再登陆能重置ulimit的设定，否则就要重新设置ulimit，如果设置了-f，而文件又已经存在，那么文件容量只能减少
    ，不能增加

    变量字符的删除：
	${var#/*/}：删除var从第一个/到第二个/中的所有字符，如果将#换成##，结果就是删除从第一个/到最后一个/中的所有
    字符，#代表从前面删除，而##就是#的贪婪模式，*代表匹配多个
	${var%/*/}：将var由后面到前面删除，删除最后一个/到倒数第二个/之中的所有字符，%%代表贪婪模式，详情看上两行

	注意!：如果用#或##，那么从第一个字符开始就要符合匹配，比如变量是123，就不能写2*3，而是12*3，否则无效也就是
    前面的字符必须要删，不能跳过删前面的；如果用%或%%的话，则是后面的字符一定要删，比如321，不能写*2，而是写*1，或
    3*，否则无效

    变量字符的替换：
	${var/s1/s2}：将var中的s1第一个s1替换成s2，如果是${var//s1/s1}就是将所有的s1替换成s2

    变量默认值：
	通过在变量名后面加-默认值的方式设置默认值，比如${name-root}，如果name变量不存在则返回root，如果name存在则
    返回name，name还有可能是空字符串，如果要变量为空字符串或者不存在的时候都返回默认值可以用${name:-root}，这样如
    果name是空字符串或者不存在则返回root

别名：
    
    alias：
	查看所有的别名
    
    alias newName='oldName'：
	指定一个别名，这个别名会替代原有的指定，比如alias rm='rm -i'，由于-i选项会在删除前进行询问，所以这个别名可
    以避免失手删除文件，特别是root用户

    unalias name：
	取消指定的别名

    别名可以看成创建新的指令，echo用的不爽可以换成alias p='echo'

历史命令：

    history n -option：
	n：列出最近的n个命令
	-c：将目前shell中所有的history清除
	-a：将目前新增的指令写入histfiles中，如果没有加histfiles，则默认写入~/.bash_history
	-r：将histfiles的内容读到目前这个shell中的history中，会覆盖这次登陆下达过的指令
	-w：立即将目前history的内容写入histfiles中，只会保留最新HISTSIZE条

    历史命令容量：
	与HISTSIZE变量有关

    !numbrr：
	执行历史记录中第number条指令

    !command：
	执行以command开头的最近一个历史记录

    !!：
	重新执行上一个指令，相当于↑+Enter，如果用了上面两个!指令，按↑不会显示!command或!number，而是实际执行的那
    个指令

    当在bash登陆时，history命令会先去~/.bash_history文件读取以前下过的指令，这个文件记录的数据上限与HISTSIZE变量有
关，比如原本.bash_history中有900条记录，这次登陆又下达过200条指令，那么等注销时就会保留101-1100条记录到.bash_history

    如果多个bash同时使用一个用户进行操作，那么最后一个注销的bash会覆盖掉前面的history

执行命令时查找命令的顺序：
	1、以绝对路径或相对路径执行，那么就会去该路径找
	2、去alias找该命令
	3、在bash内建的指令来执行
	4、通过$PATH对这个变量进行顺序寻找，以找到的第一个匹配的指令来执行

    /etc/issue文件是bash程序的欢迎界面，也就是一开始进入bash程序时显示的文字，用\作为前缀的都是有特殊含义的引用

    /etc/motd文件里的内容所有使用者登陆后都会显示包括一般用户与root用户

运行环境变量配置：

    login shell：启动bash时需要完整的登录流程，比如tty0-6进入时都会经历
    non-login shell：启动bash不需要登录，比如tty0登录之后打开终端应用，这时不需要登录，或者在原本的bash中打开新的bash
    以上两种情况进入bash时会读取的配置文件并不一致

    一般login shell登录时会去读取这两个文件：
	/etc/profile
	~/.bash_profile或~/.bash_login或者~/.profile三个其一，目前我的系统里只有第一个文件

    non-login shell会去读取~/.bashrc，这个文件是个人的偏好设置，默认内容会对一些敏感命令进行保险的别名，比如alias 
rm='rm -i'类似的设置，这样删除文件时就会进行确认询问，而且它还会去读取/etc/bashrc
    /etc/bashrc的作用：
	1、根据不同UID设置umask的值
	2、根据不同UID设置提示字符(设置PS1变量)
	3、执行能匹配/etc/profile.d/*.sh文件
    
    /etc/man_db.conf：
	man page读取说明文档的路径，如果用man command读取不到说明文档，那就要手动吧说明文档的路径添加进该文件中

    ~/.bash_history：
	记录历史命令的文件，具体描述前面有

    ~/.bash_logout：
	记录了注销bash后执行的指令，也可以用来做一些备份工作

读取配置文件：
    source file：将配置文件的内容读进当前的shell环境中
    . file：作用跟source file一样

stty -a:
    列出目前环境中所有的按键列表与其触发的功能
	intr：发送中断信号给当前正在运行的程序
	quit：发送退出信号给当前正在运行的程序
	erase：向后删除字符
	kill：删除目前指令列上的所有文字
	eof：结束输入
	start：重启程序的输出
	stop：停止目前程序向屏幕的输出
	susp：发送一个中断停止的信号给正在运行的程序

stty erase ^h：将向后删除字符改为ctrl+h触发

set -option：控制指令的输入/输出环境
    $-：当前set启用的所有选项
    -u：使用未设置的变量时，会显示错误信息
    -v：信息被输出前，先显示信息的原始内容
    -x：指令被执行前，会显示指令的内容（指令内容有+符号）
    -h：历史命令有关
    -H：历史命令有关
    -m：工作管理相关
    -B：与[]符号的作用有关
    -C：如果使用>，则当文件存在时，该文件不会被覆盖
    设置用-，取消用+

常用的默认快捷键：
    Ctrl+C：终止目前的命令
    Ctrl+D：结束输入
    Ctrl+M：其实就是Enter
    Ctrl+S：暂停对屏幕的输出
    Ctrl+Q：恢复对屏幕的输出
    Ctrl+U：将整列命令删除
    Ctrl+Z：暂停目前的命(阻塞当前线程？)


通配符与特殊符号：
    *：0到无穷个任意字符
    ?：一个任意字符
    []：一定有一个字符被包括在[]字符里面，参考正则
    [-]：编码顺序内的所有字符，例如[0-9]、[a-z]、[a-&]这种是否也可以呢？
    [^]：一定有一个字符不被包括在[]字符里面，参考正则

    以上这些可以在执行指令时匹配文件或目录，比如ls -d sud*：匹配当前目录下所有sud开头的目录


其它bash环境中的特殊符号：
    #：注释符号，在其后的数据均不执行
    \：转义符号
    |：管道符号，分隔两个管道命令的分界线
    ;：命令分隔符，分隔多个连续命令
    ~：家目录符号
    $：取变量的前缀
    &：工作控制，将指令变成后台工作
    !：非
    /：目录符号，路径的分隔符
    >、>>：数据流输出导向，分别是取代和累加
    <、<<：数据流输入导向
    ''：将单引号的任意字符当做普通字符处理
    ""：将双引号中的特殊字符进行处理
    ``：将``中执行的命令结果返回，$(xxx)也具有相同的效果
    ()：子shell的结束与开始，左括号开始，右括号结束
    {}：命令区块的组合，中间可以执行一些复杂命令，比如${var%/*/}


查看进程：

    ps -ef | grep java：查看所有关键字包含java的进程

杀死进程：

    kill -9 25000：杀死进程id为25000的进程


数据流重导向：

    数据流重导向，就是将要出现在屏幕上的数据传输到其它地方，例如文件和打印机之类的

    指令执行之后会将数据输出到屏幕上，分别是standard output和standard error output，标准输出和标准错误输出

    标准输出：
        指令执行所回传的正确信息
    标准错误输出：
        指令执行失败后，所传回的错误信息

    数据流重导向指令：
	标准输入：代码为0，使用<或<<
	标准输出：代码为1，使用>或>>，也可以使用1>或1>>，效果一样
	标准错误输出：代码为2，使用2>或2>>
        使用<、>、2>，如果文件不存在则创建，如果存在则先清空内容再写入数据，效果看起来是覆盖，但是会保留文件的属性
	使用<<、>>、2>>，则会对数据进行累加

    示例：ll / > ~/rootfile，将ll /返回的内容输出到~/rootfile，屏幕上就不会输出内容了
    示例：find /home -name .bashrc > list_right 2> list_error，由于find下的/home中有其它用户的目录，因此搜索非自己
  目录时会报错，搜索自己目录时则不会报错，因此搜索自己目录的内容放到list_right中，搜索其他人的错误信息放到list_error

    黑洞装置：
	/dev/null：这个目录会吞掉任何导向这个目录的信息，如果将错误信息导向它，就能达到忽略错误信息的目的了

    将正确与错误的数据写入同一文件：
	不能使用find /home -name .bashrc > list 2> list，这种写法会导致错误与正确的数据交叉写入，造成次序的错乱
	应该使用：
	    find /home -name .bashrc > list 2>&1
	    或
	    find /home -name .bashrc &> list
	这会将错误与正确的信息同时导向list文件

    2>&1：
	将错误输出的信息转到标准输出去
    1>&2：
	将标准输出的信息转到错误输出去

        比如：cat file 2> /dev/null 1>&2：这样会让错误消息输出到黑洞装置，正确消息输出到错误消息，最终也去黑洞，所
    以页面就会为空

    文件写入：
	cat > catfile：cat打开一个待输出的文件，这样会让终端变为可输入状态，输入的内容会放入catfile文件中，按下^d
    键结束输入
	cat > catfile < ~/.bashrc：cat准备打开一个待输出的文件，在同时又输入了文件，将~/.bashrc文件的内容输入到
    catfile中

	cat > catfile << "eof"：读取程序的输入内容，一但某次输入是eof(这个是可改的)，就会结束输入，并且把前面的内
    容输出到catfile中，内容不包含eof，如果想要输入的内容不触发结束，可以让内容写成"eof"，加了双引号就不会触发结束

命令执行的判断依据：
    
    ;：多个指令中间用分号隔开，可以一次性执行多个指令，前面的执行完会马上执行后面的

    如果前一个指令执行正确，linux会传回一个$? = 0的值

    &&：cmd1 && cmd2，如果cmd1执行成功就执行cmd2
    ||：cmd1 || cmd2，如果cmd1执行不成功就执行cmd2

    ls a && echo 1 || echo 2：如果a存在就输出1，不存在就输出2，当前前面还会输出ls a的结果，可以在ls a后用2>不展示它

    id username：查询用户的UID/GID等信息

管线命令：

    |：将前面命令执行的结果传给后面的命令执行，并且|后面的第一个数据必须是指令，而且这个指令还要能接受standare input
的数据才行，比如less、more、head、tail都可以接受，ls、cp、mv不行，管道命令传递给下一个指令的数据是从上一个指令的
standard output得来的，也就是说standard error output会被忽略

    如果想让管道命令也能处理error output的数据，可以使用2>&1让它变为output数据


攫取指令：
    攫取指令就是将数据经过分析后，取出想要的部分

    cut -option file：解析一行信息中想要的部分
        -d：将信息根据分割字符将数据分割成数段，后面跟着分割的字符，与-f一起使用
	-f：--f决定取出-d结果的第几段
	-c：以字符的单位取出固定字符区间，-c的参数用法跟-f一样，参考下面，不过它不分割，直接操作字符
    示例：echo ${PATH} | cut -d ":" -f 
					5(取出第5个)
					3,5(取出第三跟第五个)
					1-5(取出第一到第五个)
					2-(第二个之后的)
					-2(第二个之前的)
    注意：如果传给cut的数据有多行，那么cut每次会根据参数来处理一行，也就是每行都单独处理一次
    cut的用途主要在于将每行的数据进行分解

    grep '搜索的字符串' -option file：如果某行的信息符合条件则拿出该行所有的信息，搜索字符串似乎能写正则
	grep -option '搜索字符串' filename
	-a：将二进制文件以text文件的方式搜索数据
	-c：计算找到搜索字符串的次数
	-i：忽略大小写的不同
	-n：输出行号
	-v：反向选择，既显示没有搜索字符串的那行
    示例：last | grep 'boc' | cut -d ' ' -f 1 > ~/test，只要输出的信息里某行包含boc就会输出那行，然后去那行的第一
个空格前的字符串，然后将结果输出到~/test文件中


排序命令：

    sort  -option：以行为单位对数据进行排序
	-f：忽略大小写
	-b；忽略前面的空字符
	-M,：以月份的名字排序
	-n：使用纯数字进行排序
	-r：反向排序
	-u：其实就是uniq，相同的数据只出现一行
	-t：分隔符，把要排序的数据分成多段，默认用[tab]键分隔
	-k：以区间进行排序，使用分隔符号会有多段，选择哪一段

    uniq -option：以行为单位，对数据进行除重，只对排序好的数据有效，未排序的数据无法完全除重与计数有问题
	-i：忽略大小写字符的不同
	-c：进行计数

    wc -option：对文件或输入的数据进行统计
	-l：统计有多少行
	-w：统计有多少种不同的英文字符
	-m：统计有多少字符
	无：分别列出-l、-w、-m的统计结果


双向重导向：

    tee -option file：数据重导向只能把结果输出给屏幕或文件，如果想把结果输出到文件，然后用结果继续处理，就只能把数
  据再从文件读出来，而双向重导向可以既输出到文件又保留数据得以继续处理
	-a：以累加的方式将数据加入file中
	示例：last | tee /dev/null | wc -c：这样文件既能写入文件又能继续利用


字符串转换：

    tr -option c content1 content2...：字符串删除和替换
	-d：删除当前信息中指定的内容
	-s：取代重复的字符
	无：默认有-s的效果
	示例：last | tr -s o g，将所有o替换成g
    
    col -option：
	-x：将tab替换成空格
	示例：cat -A /etc/man_db.conf | col -x | cat：cat -A会显示特殊字符，tab是^I，col -x后就变成了空格

    join -option file1 file2：两个文件的数据以一定的条件连接起来
	-t 'content' ：默认以空格符分割数据，并且对比每行分割后第一段的数据，如果两个文件相同，则将两个数据连成一
      行，第一个字段放在开头，比如root:1和root:2，使用join -t ':' f1 f2，结果会是root:1:2，root只会出现在开头一次
	-i：忽略大小写
	-1：第一个文件要用哪段字符来分析
	-2：第二个文件要用哪段字符来分析
	示例：join -t ':' -1 4 /etc/passwd -2 3 /etc/group | head -n 3：将/etc/passwd用':'分割后的第四段，/etc/group
      分割后第三段对比，如果一致就抽出来放到最前面，再把两边剩下的追加在后面，然后显示前三行

    peste -option file1 file2...：把两个文件的数据连接起来
	-d 'conent'：后面是两个文件内容的分割字符，默认是[tab]
	-：如果file部分写成-，则代表数据来自standard input，比如来自管道符号的输入

    expand -option file：将[tab]转成空格，不过可以自己决定[tab]等于多少空格
	-t n：一般[tab]是8个空格，可以通过n来 决定[tab]会替换成几个空格
	-：如果file部分写成-，则代表数据来自standard input，比如来自管道符号的输入

    split -option file PREFIX：分割文件，将一个文件分成多个
	-b：后面可以跟着要分区后的文件大小，可加单位，如b、k、m等
	-i：以行数来分区
	PREFIX：分区文件名的前缀
        示例：split -b 300k /etc/services services：将/etc/services分割成多个300k的文件，分不完的全给最后一个文件，
    并且新文件名以services为前面，前缀后面会加上aa,ab,ac这样的名字，文件默认在当前目录下
	示例：cat services* >> servicesback：文件合并，将当前目录下所有services开头的文件追加到servicesback
	示例：ls -al / | split -l 10 - lsroot：将ls -al /的结果当做输入，-的含义就是拿到标准输入的结果当文件用，然
   后将结果以每10行转换成一个文件进行分割，并且新文件名以lsroot开头

    xargs -option command：将输入的内容转换成参数，并以空格或换行符来区分每个参数
	-O：将输入特殊的字符`\空格键等还原成一般字符
	-e content：end of file的意思，后面跟着一个字符串（不用空格），当xargs解析到这个字符串时就会停止工作
	-p：执行每个指令的参数时，都会询问使用者
	-n n：后面跟着次数，每次command执行时，要使用几个参数的意思
	当xargs没有填command时，默认以echo输出
	示例：cat /etc/passwd | cut -d ':' -f 1 | xargs -e'sync' -n 1 id：将passwd文件内，每行':'符号前面的字符，
   当作一个参数，每次都传一个参数给id，并执行：id 参数，等解析道sync参数，xargs就会结束停止执行
	很多指令都是不支持管线命令|的，这时候就可以通过xargs指令给不支持的指令使用srandard input的数据

    -：有些指令需要把数据写入文件，可是有时候又不需要把数据写入文件，而是要给下一个指令处理，就可以在填输出文件的
时候填-，然后再管道命令后面用-取出来，简单来说就是把前一个的stdout当作这一个文件的stdin，如果前一个命令的结果不是
要传给文件，而是直接输出结果，那么后面的指令也可以用-取到stdin
	示例：tar -cvf - /home | tar -xvf - -C /tmo/homeback：将/home目录打包到stdout，然后将stdin解包到/tmp/homeback

    系统合法的shell都写在/etc/shells文件中
    用户登录时获取到的shell记录在/etc/passwd文件的最后一行中
    $?也是一个变量，保存了前一个指令执行完后返回的值
    通配符包含：*?[]等，很多字符串操作都支持，比如grep的字符串搜索

    
正规表示法：

    ^：行首
    $：行尾
    .：一个任意字符
    \：转义字符
    *：任意数量字符
    []：会匹配[]里面任意的一个字符
    [n1-n2]：ASCII编码中n1-n2中的所有字符
    [^]：不匹配[]里面任意的一个字符
    \{n,m\}：连续n到m个，可以只填一个
 延伸正规表示法：
    +：一个以上
    ?：一个或零个
    |：或
    ()：群组
    ()+：连续匹配一个以上个群组
    (aa|bb)：aa或bb，和[]的区别是它可以匹配单词

    grep本身支持正规表示法

    egrep则支持延伸正规表示法，egrep其实就是grep -E

    sed -option command：
	-n：使用安静模式，一般情况下所有输入的数据都会列出，-n模式下只有匹配的数据才列出
        -e：在指令模式上进行sed的编辑
	-f file：将sed的表达式写在文件中，直接从文件中读取并执行
	-r：sed默认是基础正规表示法，-r让sed支持延伸正规表示法
	-i：直接修改读取的文件内容，而不是输出到屏幕

shell:

    ${}：取变量
    $()：使用函数
    $(())：数值计算

    bc：
	可以通过管道指令把数值运算传给它，比如：echo 1*2 | bc，结果输出2

    不同方式执行script的差异：
	./、sh、bash：创建一个新的bash去执行shell，子程序里设置的环境变量只在子程序生效，一但退回到父程序则会消失
	source：在父程序执行shell，因此如果修改了环境变量想要刷新则要用source

    test：
	-e：判断路径是否存在
	-f：判断路径是否存在，并且是文件
	-d：判断路径是否存在，并且是目录
	-r：判断路径是否有可读权限
	-w：判断路径是否有可写权限
	-x：判断路径是否有执行权限
	-nt f1 f2：(newer than)判断f1是否比f2新
	-ot f1 f2：判断f1是否比f2旧
	-ef：判断两个文件是否为同一个，比较是否指向同一个inode
	-eq：是否相等
	-ne：是否不相等
	-a：and，例如：test -r f1 -a -x f1
	-o：or
	!:!，例如：test ! -x f1

    []：
	[]和test的作用一样，不过[]里每个符号必须用空格隔开，比如：[ ${a2} == ${a1} ]和test ${a1} == ${a2}的作用是
    一样的，如果写成[${a1}==${a2}]会报错
	[]中的变量最好用双引号括起来，常量最好用单引号括起来，比如"${a1}"，'hello'
	中括号能用和test一样的选项

    在bash中，=和==的作用是一样的，

    获取变量：
	$#：获取参数的个数
	$n：代表第几个参数，$0代表指令本身，比如ls -a，$0是ls，$1是-a
	$@：列出所有$0之外的参数
	$*：代表除$0外的所有参数，默认分隔符是空格，和$@类似

    参数偏移：
	shift n：n代表偏移的数量

    条件判断：
	if [条件]; then
	    执行逻辑	
	elif [条件]; then
	    执行逻辑
	else
	    执行逻辑
	fi
