缓存：

缓存穿透：
    一直请求缓存和数据库里都没有的数据，导致数据库压力过大
    解决：如果查数据库查不到就把缓存的的值设置为null或空字符串，并且设置过期时间，如果查缓存的时候发现返回值是这个空字符串，就不会去查数据库了。设置过期时间是为了防止数据库里的值后来出现了还一直查缓存里的

缓存击穿：
    某个缓存突然过期，导致大量请求直接走到数据库访问，对数据库造成了巨大压力
    解决：设置永不过期，或者在查数据库之前先对key进行加锁，拿到锁后才去数据库里查询并更新缓存，拿不到锁的话就休眠一小段时间，等缓存差不多刷新了再查一遍缓存。尝试加锁可以用可重入锁的tryLock，马上返回true或false

缓存雪崩：
    大量缓存突然过期，并且查询量巨大，引起数据库压力过大
    解决：设置过期时间随机，设置热点数据永不过期

布隆过滤器：
    将key根据多个不同的hash算法转换成多个不同的hash，然后在一个足够大的byte数组里将这些hash下标置1，查询的时候再转换一遍判断这些hash的位置是否都是1，如果有任意一个为0则说明数据绝对不存在，如果全都为1则数据可能不存在，因为这些hash其它key也在用
    案例：发生缓存穿透的时候，先用布隆过滤器判断该key是否存在，如果不存在就不用去查库了，但是这样会因为误算造成有些不存在的key也会查库，因此还是用设置特定的value来判断是否查库比较稳
    优点：速度快，占用空间少
    缺点：会出现误算，并且不可删除
    用法：数组可用redis的string类型代替，它支持字节级别的操作
    降低误算概率：用几组不同的hash算法配几个数组，多重校验
    删除：布隆过滤器的hash加了就不可删除，因为该hash的位置可能也有其他key的，虽然可以每来一个新的key该hash位的byte就+1，但是根本无法判断该key是否已经加过了

跳跃表：
    在链表的基础上，为链表的每个节点加索引，本来只有next，加了索引后就多了L1，L1可能指向100个之后的元素，然后只要链表是有序的，在遍历链表的时候就可以判断只要查找的值比较大，每次都遍历L1，直到找到了接近的值再用next，还可以加L2，指向下1000个，只要需要可以无限加，其实就是空间换时间。在redis中的zset如果元素比较多或者成员是比较长的字符串就会用跳跃表来作为有序集合的实现

redis分布式锁：
    主要用setnx实现，这个指令是如果不存在则set，并返回true or false，只要能拿到锁并设置对应的锁id，就认为获取到锁了，还要设置锁过期时间。设置过期时间和设置锁必须在同一条指令上(有支持)，否则要是加了锁在设置过期时挂了那就凉凉
    释放锁的时候判断锁id跟传入的是否一样，一样才释放，并且释放和id判断应该用脚本写成同一条指令。因为如果判断了id一样，准备删除锁，这时刚好锁过期被其它线程获取到了锁，这时候再进行删除就会误删其他线程的锁

redis为什么单线程还这么快：
    因为redis的性能瓶颈从来都不是cpu，而是内存大小，一次内存操作的时间单位是以纳秒来计算的

redis过期策略：
	1、定时过期：每个设置过期时间的key都需要创建一个定时器，过期立即清除，会占用大量CPU资源去处理过其实据
	2、惰性过期：只有访问某个key时才会判断该key是否过期，极端情况下会出现大量过期key占用内存，节省CPU资源
	3、定期过期：每过一段时间都清理一定数量的key，通过扫描过期字典表里的数据，这个字典会保存所有设置了过期的key      和过期时间，这是个折中方案
	redis同时使用了惰性过期和定时过期

redis内存淘汰策略：
	1、noeviction：内存不足以容纳写入数据时，写入报错
	2、allkeys-lru：当内存不足以容易新写入数据时，移除最少使用的key
	3、allkeys-random：当内存不足以容纳新写入数据时，随机移除某个key
	4、volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的key里，移除最少使用的key
	5、volatile-random：当内存不足以容易新写入数据时，在设置了过期时间的key中随机移除某个key
	6、volatile-ttl：当内存不足以容纳新数据时，在设置了过期时间的key中，移除最早过期的key

redis应用场景：
    数据缓存
    分布式锁
    session共享
    请求限流
    产品秒杀

redis哨兵挂了咋办？
    哨兵集群，哨兵集群是哨兵直接连接到主库，就能通过主库获取其它哨兵的信息，自动进行集群。并且哨兵也是从主库获取到其它从库的信息的
    哨兵判断主库下线后，先通过哨兵集群进行选举一个leader，然后这个leader在对主从进行切换，且必须超过半票都选举同一哨兵才会成功，假如没有，就再进行下一轮投票

redis从库调用：
    redis配置好主从、哨兵后，直接连主库调用就行了，会自动调到从库


锁：

自旋锁：
    如果获取不到锁，则一直重复尝试获取锁，期间占用线程资源

互斥锁：
    获取不到锁则线程挂起，等锁释放后才进行唤醒，期间不占用线程资源，但是如果唤醒很快可能线程上下文切换的成本比自旋锁循环的成本还高

读写锁：
    读锁可以重复获取，写锁获取之后读锁跟写锁再获取会阻塞，直到写锁释放

乐观锁：
    不会锁资源，而是先改了再说，改了之后用版本号判断资源是有冲突

悲观锁：
    先锁资源再说，锁了再改，如果已被锁则阻塞，自旋锁、互斥锁、写锁、原子锁都是悲观锁

原子锁：
    对资源的操作为原子性


epoll和select：
    epoll和select都是I/O多路复用技术，都可以实时监听多个I/O事件的状态，但epoll是系统支持的I/O通知机制，select是轮询机制，因此epoll效率更高


什么是微服务
    微服务是一种架构模式，它提倡将单一的应用程序划分成一组小的服务，每个服务运行在自己独立的进程中

SpringCloud和Dubbo的区别：
    SpringCloud通信用的是http协议RESTFUL风格请求，Dubbo用的是RPC
    SpringCloud对分布式架构有一站式的解决方案，Dubbo则没那么全面

Ribbon负载均衡策略支持：
    1、轮询
    2、随机
    3、最大可用，过滤掉故障服务器后选一个请求数最少的
    4、根据响应时间做加权轮询

Ribbon和Feign的区别：
    1、Ribbon启动用的是@RibbonClient，Feign用的是@EnableFeignClients
    2、Ribbon实在@RibbonClient注解上声明服务，Feign在接口上使用@FeignClient声明

    Ribbon使用@RibboClients启动，用ioc加载一个RestTemplate来发起调用，调用时地址填服务名就行了，注解里可以填@RibbonClien数组，可以为每个服务配置不同的负载均衡，也可以在创建RestTemplae时在@Bean注解那里用@LoadBalanced来为Ribbon指定负载均衡
    Ribbon每30秒从Eureka服务获取一次服务注册信息，期间会在本地缓存一份

    Feign使用@EnableFeignClients注解启动，注解的value需要填一个包名，指定Feign接口的包路径，Feign会去扫描类上加了@FeignClient注解的，这个注解的value是指定这个Feign对应的服务名称，还能指定fallbackFactory来决定相关方法调用失败后去调用指定类的对应方法，这个类会返回一个实现了Feign接口的对象
    Feign整合了Ribbon和Hystrix，因此有负载均衡跟服务熔断能力

    Hystrix使用@EnableCircuitBreaker注解启动，启动后可以在对应方法上加@HystrixCommand注解，指定fallbackMethod属性来指定一个本类的方法名，当该方法调用失败后就会调用fallbackMethod指定的方法进行返回，它的作用是快速失败，防止服务雪崩
Hystrix Dashboard可以监控依赖了spring-boot-starter-actuator包的服务，加了spring-cloud-starter-hystrix包后使用@EnableHystrixDashboard注解启动，在仪表盘服务地址加上/hystrix就能查看了
    提供线程池，不同的服务使用不停的线程池，实现了不同服务调用隔离，避免了服务雪崩
    断路器有三个状态
	1、全开：一段时间内达到一定错误次数就会让请求直接失败
	2、半开：断路器会将部分请求发给该服务判断是否能正常调用，如果能正常调用就关闭断路器
	3、关闭：当服务一直正常时，断路器就是关闭状态

    服务熔断是被动的，服务出现多次异常自动返回预设的错误信息，服务降级是主动的，客户端直接返回预设的错误消息，不调用服务，熔断可以配置失败频率到一定的程度就不再调用服务，过一段时间后再重新尝试，次数、频率和尝试间隔时间都是可配置的，也可以熔断后进行降级，只要在调用者处，比如@FeignClient指定fallbackFactory就可以了
    两种降级方式：@HystrixCommand和@FeignClient里写fallbackFactory

    SpringCloudConfig启动需要Config服务导spring-cloud-config-server包，然后用@EnableConfigServer注解启动
SpringCloudConfig是与Eureka无关的，无需注册到Eureka，如果需要高可用就注册到eureka，只需要在服务里填写spring.cloud.config.uri=config服务的地址，.profile=环境，.label=分支就行了，请求文件的规则就是：服务名/环境.yml或propertity

    Eureka自我保护机制：Eureka服务节点在短时间内与过多服务失去连接，节点就会进入自我保护模式，不再删除注册的数据，并且依然能注册新服务，当故障恢复时，自动退出自我保护模式

    Eureka不会马上剔除关闭的服务，因为它会过一段时间(60S)检测一次服务心跳，如果检测到服务已经有90S没有心跳，就会剔除，服务每30S发送一次心跳，这几个数值都是可配置的

    调用流程：nginx->zuul->服务提供者


分库分表情况下的复杂查询：
    使用ElasticSerach

分库分表技术：
    客户端分库分表：ShardingJDBC，服务端代理分库分表：MyCat

    分库分表下产生的join、分页、事务(seata)的问题

雪花算法：
    分布式id生成算法，由64位bit二进制组成，第1位bit不用，代表整数，其后41位bit作为毫秒数，再后10位bit作为机器id，最后12位bit作为序列号
    也就是同一毫秒内每台机器最多能生成2^12-1位id，并且可以挤压机器id的空间来进行扩大
    由于是依据41位毫秒数来生成的，因此系统时间错误可能会造成id冲突，并且是同一机器才会出现时间回调id冲突

zookeeper选举：
    1、先选举自己为leader
    2、广播投票信息、等待其它节点投票信息
    3、收到的节点投票信息是否轮次比自己新，且编号比自己大，如果是则更新投票信息
    4、2-3步骤一直循环，直到有节点获得一半以上选票
    5、如果获得一半以上选票的是自己则把自己设置为leader，且广播

dubbo支持的协议：
    dubbo、rmi、hessian、http、http REST、web service、redis





