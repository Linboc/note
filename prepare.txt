
分布式事务相关概念：
    事务：一个程序执行单元，用户定义的一组操作，需要满足ACID属性
    本地事务：本地事务由本地资源管理器管理
    分布式事务：事务的操作位于不同的服务器节点
    分支事务：分布式事务中，由本资源管理器管理的本地事务
    全局事务：一次性操作多个资源管理器完成的事务，由一组分支事务组成

分布式事务主要有两种：基于XA协议的强一致性与基于MQ的最终一致性


XA：
    XA是基于二阶段提交协议设计的接口标准，实现了XA规范的资源管理器就可以参与XA全局事务。一般而言应用作为事务管
理器TM(Transaction Manage，TM)，数据库作为资源管理器RM(Resouce Manage，RM)，TM生成全局事务id，控制RM的
提交和回滚
    注：这里的TM是Seata里TM和TC的结合体
    1、TM生成全局事务id
    2、RM执行本地事务，执行完后暂不提交
    3、TM询问每个RM是否准备好，也就是prepare阶段，此时RM会获取锁并执行，只不过未commit，就差临门一脚
    4、一旦有任意一个RM进行回滚，TM就会通知所有RM进行回滚
    5、一旦所有RM都准备完成，TM就会通知所有RM进行提交，TM出现超时，那么RM就会长时间阻塞，不释放资源


3PC：
    三阶段提交，是二阶段提交的改进版

    分为三个阶段：
        1、第一阶段：询问(CanCommit)
        2、第二阶段：锁资源(PreCommit)
        3、第三阶段：提交(DoCommit)

    具体流程：
        1、TM向TC注册全局事务
        2、RM向TC注册分支事务，然后执行
        3、TM通知RC执行完毕
        4、TC询问所有RM是否就绪(CanCommit)，RM响应就绪，否则TC通知全部RM回滚
        5、TC询问所有RM是否准备(PreCommit)，RM响应准备完毕，否则TC通知全部RM回滚
        5、TC向所有RM确认提交(DoCommit)，RM响应准提交完毕，否则TC通知全部RM回滚

    表面上看3PC比2PC多了一个准备阶段，或者说把原prepare阶段一分为二。

    3PC的优势：
        1、二阶段在prepare阶段就把所有锁都占用，并执行完所有的操作，仅剩提交，如果此时rollback就会白白浪费大量资源，而
    3PC多了一个PreComit阶段，这个阶段让分支事务可以不用做那么多事，如果此时失败了损失也没那么大
        2、支持超时策略，在2PC中，如果TC长时间没响应，所有RM都会一直等待。而在3PC中，分为RM和TC两种超时：

            参与者：CanCommit和PreCommit阶段，如果RM长时间收不到响应就会进行rollback，而DoCommit阶段如果依然超时，RM就
          会认为大概率会进行提交，因此直接提交本地事务

            协调者：三个阶段如果出现超时都会进行回滚

        3、2PC会出现数据不一致的情况，比如commit只发送给一个参与者后TC就挂了。而3PC会选举出一个新的TC，然后询问所有的
      参与者的状态，因为commit的前提是所有参与者都PreCommit了，因此一但有任意一个commit他就会通知其它所有参与者commit。
      否则就通知所有参与者rollback。因为它不知道所有参与者的状态，如果有commit它就能确定所有参与者PreCommit完毕，而如果
      没有commit，为了保险一点就只能rollback了
    3PC的劣势：
        1、如果出现网络超时，参与者自动commit，但其实TC想要的是rollback，就会出现数据不一致
        2、3PC步骤更多，导致并发更低


柔性事务的最终一致性：
    该规范主要有3种：TCC、MQ事务消息、本地消息表

    TCC：
        TCC指的是：try、confirm、cancel，也就是尝试、确认、取消，TCC同样有一个事务管理器
        1、TM生成全局事务ID
        2、本地事务执行，这一步只是锁定资源，比如从已配送改为取消中，扣库存改为冻结库存，锁定后直接提交事务
        3、然后事务管理器就会根据是否所有本地事务都锁定成功
        4、如果有任意一个本地资源管理器try失败，事务管理器就会通知所有资源管理器进行cancel，将锁定的资源释放
        5、如果所有本地资源管理器都能锁定成功，那么事务管理器就尝试confirm，也就是通知所有的本地资源管理器将中间
    状态改为完成状态

    MQ事务：
        MQ事务的前提是消息系统支持事务消息，比如RocketMQ
        1、本地事务在提交前发送消息到MQ，此时消息处于未提交状态，消费者无法消费到，这种消息叫半消息
        2、本地事务提交后，会提交MQ上的半消息
        3、如果第二步失败了，MQ后续将会对用户状态进行回查
        4、如果用户确认该事务已提交，MQ就会提交该消息，让其可被消费
        5、如果用户确认该事务已回滚，或者长期无法确认事务的状态，MQ就可以把该消息删除
        6、消费者只要能消费到该消息就代表生产者的事务肯定提交成功了

    本地消息表：
        本地消息表跟MQ事务消息类似，区别在于MQ不支持事务消息时，需要借助本地数据库的事务管理功能


Seata：

    Seata有三个核心组件：
        Transaction Coordinator(TC，事务协调器)：
            维护全局事务和分支事务的状态，驱动全局事务提交或回滚，TC以服务的形式独立部署

        Transaction Manager(TM，事务管理器)：
            定义全局事务的范围，开始事务、提交事务、回滚事务，向TC注册全局事务，管理RM之间的事务传递

        Resource Manager(RM，资源管理器)：
            管理分支事务上的资源，向TC注册分支事务，汇报分支事务状态，驱动分支事务的提交或回滚，向TC注册分支事务，
        分支事务回滚

    关于Seata的疑惑：
        1、如果A服务调用B服务，B服务要返回结果就必须prepare然后commit，但是B服务不返回A服务就无法prepare：
            B服务可以做到prepare不commit，直接返回结果，等收到TC的commit或rollback后再进行，因为事务的提交或回滚
        也是通过AOP进行的，完全可以做到Seata自定义的事务在方法结束后不提交，而是等TC的调用

Seata支持的4种工作模式：

1、
    AT(Auto Transaction，自动事务)：
        AT模式是Seata默认的工作模式，需要基于支持本地ACID事务的关系型数据库与Java应用，通过JDBC访问数据库

    AT协议是XA协议的演变，AT协议也分为两个阶段：
        一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和资源连接
        二阶段：提交异步化，这可以非常快速的完成，如果发生回滚则通过一阶段的回滚日志进行补偿
    具体流程：
        1、TM向TC注册全局事务，也就是申请全局事务ID，在各个子调用之间传递
        2、RM向TC注册分支事务，这一步需要带着TM的全局事务标识来进行
        3、RM执行完成后提交或回滚自己的分支事务，并把结果通知TC
        4、当代码执行到TM的全局事务出口时，也就是最外层开启全局事务的方法已结束，TM就进行提交
        5、如果期间有任何RM发生异常，TM就会通知TC进行该全局事务的回滚，TC将通知个个参与该全局事务的RM通过本地
    日志进行补偿性回滚

    AT模式的优点：并发性高，对代码无入侵，每个分支事务的锁在第一阶段就会释放，不需要数据库对XA进行支持
                  缺点：只能用在支持ACID的关系型数据库，SQL解析不支持全部语法，因此无法完全准确的进行补偿


2、
    TCC(try、commit、cancel，尝试、提交、取消)：
        一阶段：TM注册全局事务后，调用服务的try接口
        二阶段；TM观察是否全部服务接口的try都返回成功，如果都成功就commit，否则就rollback，TC会调服务相对应的接口
    具体流程：
        1、TM向TC注册全局事务，也就是申请全局事务ID，在各个子调用之间传递
        2、每个子调用所在的TM都向TC注册分支事务，随后执行本地prepare，并向TC汇报执行结果，prepare只是锁定资源
        3、TM根据各个分支事务的执行结果确定第二阶段进行commit还是rollback，然后对TC进行提交或回滚 
        4、如果TM进行提交，TC就调用个个分支服务的commit接口，否则调用cancel接口

    TCC模式的优点：不依赖本地事务
                    缺点：资源锁定、提交、回滚都需要手动编码，对业务侵入性较大


3、
    Saga：
        简单来说，Saga就是将一个长事务分解成一系列子事务，并且每个子事务都有对应的补偿动作，用于撤销对应子事务产生
    的影响
        Saga是Seata提供的长事务解决方案。如果全局事务中涉及到外部系统，无法去管理它的资源，也无法实行TCC，就可以
    用Saga这种方案
        例如：事务1->事务2->事务3，全部成功则全部提交
              ：事务1->事务2->事务3失败->事务2补偿->事务1补偿，出现失败则对之前的事务进行逆向补偿

    具体流程：
        1、Saga应用(集成了Saga状态机)向TC注册全局事务
        2、Saga应用在数据库记录状态机启动
        3、Saga应用向TC注册分支事务，并在数据库记录分支启动
        4、Saga应用执行具体任务，也就是调其它第三方服务的执行接口
        5、Saga应用调用第三方服务后在数据库记录执行结果，并向TC报告分支任务的执行结果
        6、Saga应用将执行结果记录到数据库
        7、Saga应用告知TC此时需要提交还是回滚，如果是回滚，则从TC获取相关会话，然后从DB加载详细信息来恢复状态机

    Saga模式的优点：一阶段本地事务提交，无锁，高性能，事件驱动架构，参与者之间可以异步执行，高吞吐，补偿易于实现
              缺点：不保证隔离性(不同的Saga操作的每一个分支事务都有ACID特效，为什么说保证不了隔离性)，额外的Saga协调器
                    增加了系统的复杂度，并且需考虑协调器自身的故障


4、
    XA模式：
        XA模式是Seata利用事务资源对XA协议的支持，以XA协议的机制来管理分支事务的一种事务模式
        初始阶段：TM向TC注册全局事务
        执行阶段：业务SQL在XA分支中执行，由分支事务的RM管理器进行管理，然后执行XA prepare
        完成阶段：TM通知TC各个分支执行结果，TC再根据结果确定对各个RM是进行rollback还是commit
    具体流程：
        1、TM向TC注册全局事务，拿到全局事务ID
        2、业务开始对其它服务进行调用，如果其它服务有开启全局事务，则通过自己所在的RM将分支事务注册到TC
        3、TM通知TC是进行提交还是回滚，因为TM是最外层最先开启全局事务的组件，它知道全局事务何时结束
        4、TC询问所有分支事务是否prepare完成，随后TC通知各个分支事务的RM进行commit或rollback

    XA模式的优点：继承了XA协议的优势，事务具有强一致性
            缺点：分支事务持续时间长，并发度低


Seata的默认模式是AT，因此这里分析AT模式核心模块：

    TC(事务协调器)以独立的服务启动，作为Server，维护全局事务和分支事务的状态，驱动全局事务提交或回滚
    启动流程如下：
        1、获取NettyServer启动端口，默认是8091
        2、监控初始化，可用于接入prometheus
        3、UUID生成器初始化，用于生成事务ID
        4、会话管理器初始化，支持file、db、redis模式
        5、TC处理器初始化，支持AT、TCC、SAGA、XA等模式
        6、定时任务创建，用于异步处理
        7、启动NettyServer

    TM(事务管理器)，TM集成在应用中启动，负责定义全局事务的范围、开始事务、提交事务、回滚事务。TM所在应用需要
配置GlobalTransactionScannerBean
    启动流程如下：
        1、初始化TMClient，包括：注册TC响应处理器，注册心跳处理器、启动NettyClient
        2、初始化RMClient，包括：注册分支事务处理器，注册TC响应处理器，注册心跳处理器、启动NettyClient
        3、注册shutdown hook，用于关闭TMClient、RMClient
        4、对使用@GlobalTransactional注解的Bean进行动态代理

    RM(资源管理器)，RM集成在应用中启动，负责管理分支事务上的资源，向TC注册分支事务，汇报分支事务状态，驱动分支
事务的提交或回滚。RM所在的应用除了要跟TM一样配置GlobalTransactionScanner以启动RMClient外，还要配置
DataSourceProxy，以实现对数据源访问代理。该数据源代理实现了sql的解析、生产undo log -> 将业务sql和undo log一起
提交到本地事务等操作

一下以一个简单的例子来说明：

    @GlobalTransactional(timeoutMills = 30000, name = 'demo-tx')
    public void buy(String userId, String itemId, int itemCount) {
        stockClient.deuct(itemId, itemCount);
        ......
    }
    以上代码很简单，第一行开启全局事务，第二行定义了一个购买商品的方法，第三行调用库存服务扣库存

正常流程：
    1、TM应用里@GlobalTransactional注解的方法被代理，被调用时执行GlobalTransactionalInterceptor.invoke过滤器
    2、GlobalTransactionalInterceptor.invoke向TC注册，申请全局事务XID
    3、TC生产全局事务ID，并返回给TM
    4、执行buy方法
    5、调用stockClient.deuct()，RPC框架，比如Dubbo的ApacheDubboTransactionPropagationFilter.invoke会将XID设置
到Dubbo上下文
    6、在stock服务中，这里是RM，Dubbo的ApacheDubboTransactionPropagationFilter.invoke从dubbo上下文中拿到XID
    7、stock服务的RM获取sql执行前的镜像，然后执行sql，再获取sql执行后的镜像，然后通过镜像生成undo-log，这里的镜
像是原数据？
    8、向TC注册BranchID，然后TC返回分支事务ID
    9、RM将undo-log插入数据库，然后提交本地事务
    10、此时RM执行结束，回到TM
    11、TM发现调用完成，向TC发起提交全局事务
    12、TC给全局会话加锁，然后关闭会话设置，进行会话清理，将全局事务设置为提交中，最后异步去进行commit
    13、TC异步删除undo-log，然后清理分支会话，并提交全局事务

异常流程：
    从上面第10点开始
    10、TM出现异常，执行结束，异常抛回给TM
    11、TM回调TC进行回滚
    12、TC全局会话加锁，并将全局事务设置为提交中
    13、TC回滚分支事务，回滚后删除会话分支，删除全局事务
    14、TC事务回滚能成功，TM调用结束抛出异常

AT模式的写隔离：
    考虑到一种情况，两个线程同时调用A服务的业务，其中A服务内部又调了B服务。此时线程1先执行，它调用B服务成功，由
于AT模式是先提交后补偿的机制，因此直接提交事务。但是线程1回到A服务后执行失败，TC对B服务进行补偿性回滚，而TC对
B服务回滚之前，B服务的数据已经被线程2读到了，这种情况就出现了脏数据
    为了解决这种事务之间资源隔离的问题，Seata使用了全局锁，锁的key是表名:复合主键，这个锁在每个RM的分支事务开始
时加，在TM提交或回滚全局事务后释放。如果全局事务A已经拿到锁了，另外一个事务还来拿锁就会一直重试，直至事务A释
放锁

AT模式的读隔离：
    也就是全局事务提交后，分支事务的修改才能被读到，Seata会对加了FOR UPDATE的SELECT语句进行代理，也就是说如果
在Seata代理的数据源中使用FOR UPDATE，Seata会先去拿全局锁，拿到了才允许执行，否则就会进行重试



注册中心：

    客户端逻辑：
        1：在DiscoveryClient类的构造器中进行一系列初始化
        2、一个心跳线程的定时任务，用来续约
        3、一个缓存刷新线程的定时任务，用来刷新客户端的applocations，也就是服务列表
        4、注册实例状态变更监听器与一个定时任务，每次触发都会判断当前实例状态是否有更新，如果有就重新注册到服务端
        5、增量更新实例基于一个recentlyChangedQueue最近变更队列来进行，这个队列会保存最近注册、状态变更、取消等操作的信
    息，每次进行增量拉取时，服务端总会返回这一整个集合，这个集合的清理时间基于服务端配置的retentionTimeInMSInDeltaQueue
    ，当元素的最后更新时间跟当前时间的差距大于该配置，那么这个实例的变更信息将从最近变更队列中被删除。这个定时任务在
    AbstractInstanceRegistry构造器中开启
        6、因此客户端如果挂了一段时间再重连，然后一直拿增量，是有可能出现一些服务拿不到的情况，除非它们出现变更。当然也
    可以禁用增量拉取。而第一次拉取，由于实例数量是0，总是会进行全量拉

    服务端逻辑：
        1、在EurekaServerInitializerConfiguration的start监听器中进行一系列初始化
        2、启动一个剔除的定时任务，用来剔除过期的客户端
        3、如果开启只读缓存，还会定期将只读缓存里所有的key在读写缓存里刷新到最新value
        4、客户端跟服务器之间进行注册、续约、下线、状态变更等操作时，会异步通知给其余所有维护的已知节点，如果是服务器
    之间的状态传递，会附带一个x-netflix-discovery-replication请求头，当有这个请求头时服务器就不会再进行同步，避免无限
    同步
        5、客户端进行心跳时，会附带一个实例最后变更的时间戳，叫lastDirtyTimestamp，如果服务端该实例的时间戳比较小，服务
    端就会返回404，客户端收到404之后就会重新进行注册以刷新实例信息，当客户端的时间戳比较小时，代表客户端的数据是旧的，
    就会返回409，对于eureka客户端来说，它的信息永远不可能比服务端旧，因此它不处理409，只有服务端之间相互同步时才会出现
    一个服务端的实例比另一个服务端的实例旧，此时发起请求的服务端就会同步该实例
        6、读写缓存的写入，是在每次get时，当value为空都会触发一个构建时设置好的CacheLoader缓存加载器，由于缓存有过期时
    间，因此每隔一会儿就会重新加载一次，数据从registry注册表中加载而来
        7、服务端的实例列表并不是启动时由其它服务端同步而来，而是靠心跳、返回404、然后注册而来

    整体逻辑：客户端给其中一个服务端发信息，如果这个服务端有问题就切到下一个，直到找到一个可用的服务端，然后记录这个服
务端信息，后面一直用。服务端收到客户端的信息后，异步同步到其它服务端

    三重缓存：
        1、registry注册表
        2、读写缓存
        3、只读缓存



mysql索引的b+tree与hash：

    b+tree：
        b+tree只有叶子节点才会存放数据，其余节点都是存放索引值和指针，每个指针左边的数据存放的都是小于它的数据，右
    边存放的都是大于等于它的数据，一个节点可以有多个指针，每个指针又指向一个下级节点
        如果是复合索引，那么在叶子节点会出现相同的值，比如一级索引的叶子节点是：1,2,3。而复合索引就变成了：1-1,1-2,
    2,3-1,3-2,3-3。

    hash：
        hash相比于b+tree：
            缺点：
                1、如果使用复合索引，只能一次查所有的字段，因为部分字段的查询无法找到hash
                2、like时索引无法生效，哪怕%在右边
                3、无法进行范围查询，因为hash是无需的
                4、存在hash碰撞问题，效率不稳定
                5、hash索引也无法进行排序
            优点：
                1、如果是等值查询，且数据重复度很低，hash具有优势

    为什么用b+tree而不是btree：
        核心区别就是是否在非叶子节点存储数据以及相邻叶子节点之间是否以指针相连
        1、btree不支持顺序检索，而b+tree维护了指针将叶子节点顺序连在一起，只要遍历叶子结点就能遍历整棵树
        2、b+tree非叶子节点不存储数据，只存储索引值与指针，因此一个节点中b+tree能存放更多的索引，所以b+tree会比
    btree更矮，这能减少了I/O次数
        3、b+tree由于叶子节点是有序的，所以范围查询的性能会更好
        4、b+tree的查询效率更加稳定。只需1-3次，因为b+tree高度一般在2-4层，而根节点是常驻内存的


sentinel常用功能与特点：

    DegradeRule(降级规则)：
        grade：有三个降级模式，平均响应时间、异常比例、异常数量。
        timeWindow：降级之后，断路器要过久之后才会转为半开状态进行下一次尝试
        minRequestAmount：最少要多少个请求满足才能触发降级
        count：异常比例和异常数量模式下触发降级的比例阈值
        slowRatioThreshold：平均响应时间模式下触发降级的慢请求比例阈值
        statIntervalMs：每隔多久统计一次

    SystemRule(系统规则)：
        系统规则限制是针对整个计算机资源的限制，因此每次访问都会拿系统监控信息进行对比
        highestSystemLoad：最高系统负载，既CPU同时需要处理多少任务，大于CPU核数就意味着有任务在某刻拿不到CPU
        highestCpuUsage：最高CPU使用率
        qps：每秒最高处理多少请求
        avgRt：这个进程里通过sentinel途径访问资源的最大平均响应时间
        maxThread：这个进程里通过sentinel途径访问的资源最多同时存在的线程数，既每次entry+1，每次exit-1

    FlowRule(限流规则)：
        grade：有两种限流模式，QPS与线程数
        count：QPS或线程数的上限

    线程池隔离VS信号量隔离：
        线程池优势：
            1、排队
            2、异步
            3、超时，信号量依靠底层socket机制也能超时，但是socket超时分为读超时与连接超时，无法做到准确超时
        线程池劣势：
            1、需要创建过多线程
            2、线程切换额外资源
        线程池使用场景：
            1、请求不会非常频繁，比如读缓存，否则会导致线程频繁切换
            2、限制数量不会很多，例如像网关这种，要同时发几百个请求，那就要创建几百个线程了

    Node类型：
        StatisticNode：基础的统计节点，包含秒级和分支两个滑动窗口结构
        DefaultNode：链路节点，用于统计调用链路上某个资源的数据
        ClusterNode：簇点，用于统计每个资源的全局数据
        EntranceNode：入口节点，对应某个Context入口的所有调用数据


优化：

CPU高排查思路：
    1、用常规CPU过高排查思路找到占用过高的线程
    3、根据线程名判断占用CPU资源较多的是GC线程还是业务线程
    4、如果是GC线程占用过高，那就要排查内存是不是已经满了，并且频繁进行GC也清不下来，需要检查是否内存泄漏
    5、如果是用户进程过高，那就要根据堆栈信息排查框架或业务代码

内存占用过高排查思路：
    1、

常规CPU升高排查：
    1、top查看是哪个进程占用CPU或内存过高
    2、top -Hp PID查看是哪个线程占用CPU或内存过多
    3、printf "%x\n" threadID将线程ID从10进制转为16进制
    4、jstack PID | grep 16进制threadID -A 20查看指定进程中指定线程的堆栈，展示线程开头往下20行

常规内存过高排查：
    1、top查看是哪个进程占用CPU或内存过高
    2、

















