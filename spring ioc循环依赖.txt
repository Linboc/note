一层缓存：
    每次new对象都放在一个单例池里，当有两个对象互相依赖对方，初始化自己就要先初始化对方，此时将会陷入死循环

二层缓存：
    有一个单例池，一个半成品池，对象的初始化分为两步，第一步先实例化，第二部才初始化属性，当有两个对象互相依赖，a对象先实例化放进半成品池，此时它依赖了b对象，就又实例化b对象，把b对象放进半成品池中，然后初始化b对象，b对象又依赖了a对象，b对象会先从单例池中拿到a对象，发现没有就从半成品池里拿，拿到后就初始化完毕，将b对象放到单例池中，将b从半成品中移除，然后a从单例池中拿到b对象，完成自己的初始化
    a(半成品)->b(半成品)->b(拿到a半成品初始化完成，b放到单例池)->a(从单例池中拿到b完成初始化)
    当使用了aop时，如果发生循环依赖，机会出现注入的依赖都是未代理对象，因为半成品池中放的都是刚实例化完毕的bean，代理发生在实例化-初始化-后置处理器，此时代理还没生效

三层缓存：
    一个单例池，一个半成品池，一个工厂池，对象创建会先创建一个工厂Bean，如果创建过程中其它bean引用了这个bean，就会先创建这个bean的代理对象，通过AbstractAutoProxyCreator.getEarlyBeanReference。需要注意的是，实例化-初始化-后置处理器并不是必定的流程，此时的顺序是实例化-后置处理器代理-初始化，因为代理流程不依赖任何实例属性，代理条件依赖于方法名、类名、注解，代理目标依赖bean，因此先代理再初始化并无问题

    a和b相互依赖，它们是动态代理，此时准备创建a，先创建一个工厂bean放在工厂池，然后发现a依赖b，这时就创建b，b也创建一个工厂bean放在工厂池，然后发现b依赖了a，此时单例池和半成品池中都没有a，b去工厂池里拿到a的工厂bean，将这个bean拿出来去创建代理对象,然后放到半成品池中，然后b从半成品池中拿到a进行初始化、执行后置处理器，此时b已执行完毕，由于b初始化过程中没有其它bean依赖它，因此会将工厂池里b的工厂bean删掉，将初始化完成的b放到单例池。此时a继续执行，a创建完b之后，在单例池中拿到b对象(正常流程中在后置处理器被代理了)进行初始化，然后执行后置处理器，此时后置处理器发现a已经被动态代理了，因此直接返回a，详见AbstractAutoProxyCreator.postProcessAfterInitialization
    实例化a-a(工厂池)-实例化b-b(工厂池)-代理a(半成品池)-删除a(工厂池)-半成品池中拿到a初始化b-后置处理器代理b-b(单例池)-删除b(工厂池)-a(单例池中拿到b进行初始化)-a执行后置处理器发现已被代理过，不执行代理直接返回原bean
    所有代理过的bean都会用类名+beanName生成一个key保存在一个集合中，如果集合中已存在这个key说明已被代理过，无需再次代理


单例池：存放所有实例化、初始化、走完所有后置处理器的bean，也就是完全加载好的bean
半成品池：未初始化的bean，存放依赖别人的过程中被自己的依赖所依赖的bean，由工厂bean转成，里面放的可能是代理bean也可能是原始bean，不过都是未初始化的。在bean加载完之后转到单例池，并从半成品池中移除
工厂池：bean的初始池，如果被循环依赖则转到半成品池，如果没被依赖则转到单例池，转了之后都会被移出工厂池

提前引用：依赖的bean在自己没加载好之前就引用自己，此时依赖自己的bean可能需要的是代理对象，因此提前引用可能会发生bean没初始化就被代理，会导致bean由工厂池转到半成品池