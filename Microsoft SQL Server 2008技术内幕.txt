三大范式：
	第一范式：满足唯一性、每一列都有原子性
	第二范式：满足第一范式、对于每一个非主键列来说，都是完全函数依赖于整个主键
	第三范式：满足第二范式、所有的非键属性必须非传递依赖于候选键

唯一性：所有行都是唯一的，也就是要有能区分他们的依据，一般是用主键

原子性：原子性就是不可分割的，一个姓名属性，可以分为姓属性、名属性，可是很多时候根本没必要，所
	以这个原子性一般看自己的需求

完全函数依赖：每一条数据都必须要通过所有主键才能查询出来，如果有主键有两列，而只用了一列就能找
	      出想要的某条数据，那就不是完全函数依赖，这时候可以把这一列放到所依赖的那一列主键
	      作为唯一主键的表里，如果5列只依赖了4列也一样,可以创建一张4列主键的表来满足第二范式

非传递依赖：一个非键属性不依赖于其他非键属性，查询一个非键属性必须通过主键，而不能依赖非主键把
	    它查出来，如果有这种情况，可以把被依赖的那一属性作为主键，依赖的属性作为数据新建一
	    张表来符合第三范式

依赖：这里的依赖是指查询时需要的条件：想查询某一userName就要有userId，所以userName依赖于userId

	 以上所指的查找某一条数据，并不是指通过表达式或者聚合函数来查找，而是指定数据查找

系统数据库：
	master：元数据信息、服务器配置、实例中的所有数据库信息、初始化信息
	Resorce：sql server2005新增的、保存所有系统对象、数据库中的元数据信息，表面上在本库，
		 实际上在Resource库中
	model：	新建数据库的模板，每个新数据库都是model数据库的copy，如果想要给新建的数据库增
		加什么默认配置，可以修改model库的配置
	tempdb：保存临时数据的地方，包括工作表、排序空间、行版本控制等信息，还有用户创建的临时
		表，实际上是保存在tempdb的，每次重启SQL SERVER实例时，都会删除这个数据库的内容
		并以model库为模板重建，因此如果想临时测试，可以在这个库，反正重启sql server也会
		删除
	msdb： 	SQL Server Agent服务保存数据的地方，也保存了一些有关其他SQL Server功能的信息

元数据：数据的数据

声明式数据完整性：作为模型的一部分而实施的数据完整性，比如某个属性NOT NULL，唯一约束，检查约束、主外键等
过程式数据完整性：用代码实施的数据完整性，比如用存储过程或触发器来保证的完整性

	CASE WHEN 条件 THEN 条件成立的结果 ELSE 不成立的结果 END

	TOP number：用在DISTINCT后面，可以返回number个最接近的数据，可以和order配合取到最前或
最后的数据，如果在number后面加上PERCENT，就会按照百分比返回数据，该百分比会向上取整
	
	WITH TIES：在TOP number后面加上WITH TIES，就必须使用ORDER，然后除了返回number行之外，
还会返回所有ORDER包含字段的值与最后一行的值相同的所有行，也就是说可能不止返回number行
	
	在使用GROUP BY时使用聚合函数，比如COUNT，那么在聚合函数里面可以使用DISTINCT，逻辑是：
先对本组的数据根据指定的字段组进行除重，除重后才开始聚合函数的运算，也可以在聚合函数前面使用
DISTINCT来对聚合后的数据进行除重
	
	OVER：定义一个窗口，这个窗口里面可以操作聚合函数和排名函数的集合，由于OVER子句为这些函
数提供了一个行的窗口，所以这些函数也成为开窗函数(window function),窗口是指用户指定的一组行

	SUM(price) OVER()：使用了当前组的所有数据，计算price总和，因为都是同一组，因此都相同
	SUM(price) OVER(PARTITION BY id)：相同的id分为一组，计算每组的price总和，并赋给相应id
	的行，并且还能与本来的列配合使用：
	
	SUM(price) OVER(PARTITION BY id)/COUNT(price) OVER(PARTITION BY id)：计算每一组平均价
	
	PARTITION BY：自己理解为，临时分组，会在当前的OVER()自动分组，不会影响其他数据，分组效
	果和GROUP BY相同

	可以看到，聚合函数加了OVER()之后，就不会聚合整张表的数据为一行，而是聚合窗口的数据为一
列

排名函数：排名函数因为会对每一行赋予序号，因此OVER里必须有ORDER，ORDER前面可选增加PARTITION BY(可以有多个字段)
	ROW_NUMBER()	对每一行赋一个序号，由小到大，如果逆序，序号的顺序不会改，只会改数据的
			顺序

	RANK()		给每一行赋一个序号，由小到大，相同的值，序号也会一样，新行的序号总是前
			面的序号数量+1

	DENSE_RANK()	给每一行赋一个序号，由小到大，相同的值，序号也会一样，新行的序号总是前
			面的序号+1

	NTILE(number)	对序号进行分组，比如有82行，number为10，那么前面10行为1,11-20行为2，多
			出的两行会平均的分给前面的，也就是前面两组有11行

	排名函数也支持PARTITION BY语句，经过分区的列会自成一派，比如分区id，那么每一组相同id的
行都会重新排名，比如id为1的，有9个，会排1-9，id为2的有5个，会重新排1-5

	OVER不会对原来数据的内容有任何影响，不过里面的ORDER BY可能会影响数据的排序，因此如果想
排序，需要在外围的SELECT语句中的ORDER中进行再次排序

	OVER()会在DISTINCT之前进行处理，因此如果用ROW_NUMBER()的话没有意义，因为每行会生成不同
的数字，所以不会重复，如果用RANK()这种就会有效，因为它会有序号相同的时候

	在字符串前加个N，代表字符串是Unicode类型比如：N'ts'，在数据库中是char或varchar

	CAST：类型转换，CAST(字段 AS NUMERIC(12 , 2))，把一个字段的值转为有12位数字其中有两位
小数

	NULL：NULL在与其他值使用表达式进行比较的时候，结果总是UNKNOWN，甚至在与自己比较的时候
结果也是UNKNOWN，比如：NULL=NULL、NOT NULL=NULL、'TT'=NULL，结果都是UNKNOWN，SQL SERVER在判断
时，只接受值为true的，也就是说如果使用id !='xx'的方式查找，要注意如果id为NULL的话是找不出来的
，因此写语句的时候要记住SQL SERVER是三值谓词逻辑。

	同时处理：对于同一语段，SQL SERVER是同时处理的，也就是说不一定是从左到右执行的，体现在
同一个SELECT语句，后面字段不能使用前面字段的别名，同一个WHERE先number <> 0 AND 5/number>2，还
是可能会出现除0异常，因为有可能SQL SERVER认为第二个表达式的代价较小，先进行计算，这种情况要限
制顺序可以用CASE，CASE的WHEN能保证表达式的顺序，同时的结果就是无序

	字符类型：带var的都是可变长度的，不带var的都是不可变长度的
		带var的：除了保存的字符串之外，还会有两个额外的字节用来保存数据的偏移量，保存
			 的空间会根据具体内容变化，可是因为要计算偏移量，因此更新的效率比较低
			 ，依然不能超出设定的最大值，因此可不可变不是指最大值，而是指最大值范
			 围内的存储空间

		不带的：会按照预设的长度对其进行保存，如果没有存满，就会用空格填充，因此那种右
		 	边有很多空格的，都是不带var的，比较占空间，更新效率高
		那种保存固定长度的ID，证件号就可以用不可变的，保存地址、留言就可以用可变的

	char和nchar：
		char：看说明好像ASCLL码，每个单位是一个字节(2^8)，因此只能存储英文数字符号，可
		      能存储中文，不过每个中文会占用两个单位
		nchar：也就是unicode，每个单位是两个字节(2^16)，因此可以存储所有的符号，包括中
		       文，任何符号只会占用一个单位
	
	排序：
		可接收排序规则的对象：SQL Server实例、数据库、列、表达式
	
	作用：排序规则决定了对象的位置，和对象的定义，比如列不区分大小写，tmp和TMP是一样的，如
过定义了排序规则区分了大小写，那么可以定义tmp的同时定义Tmp和TMP

	比如一般查询字符串英文是不分大小写的，如果查询小写，大写的也能查出来，如果想区分大小写
	SELECT * FROM supplyCopy WHERE supplyId COLLATE Latin1_General_CS_AS = 'TSId1'
	字段后面加上这一句：COLLATE Latin1_General_CS_AS

	如果字符串里想用单引号，那就用两个单引号代表一个单引号

	如果有什么字符串与NULL进行连接，ANSI的标准是结果也是NULL，SQL SERVER可以在这种情况下把
NULL当作空字符串进行处理，需要将以下会话选项设置为OFF：
	SET CONCAT_NULL_YIELDS_NULL OFF
	当然这样不符合规范，还是建议按照标准来

字符串处理函数：
	
	COALESCE：返回所有参数里第一个不为NULL的值
		参数：可变数量的参数

	SUBSTRING：截断字符串里的某一段，参数2超过返回空字符串、参数3超过返回参数2后所有的字符
		参数：1：源数据 2：开始的位置 3：截取长度

	LEFT和RIGHT：返回左边和右边的字符串
		参数：1：源数据 2：字符的个数

	LEN：返回字符串的个数
		参数：1：源数据

	DATALENGTH：返回字符串的字节数
		参数：1：源数据
	
	CHARINDEX：返回子字符串第一次出现在父字符串里的位置
		参数：1：子字符串 2：父字符串 3：[可选]指定开始的位置

	PATINDEX：返回某个模式第一次出现的起始位置，模式：'%[0-9]%'、'%[a-z]%'
		参数：1：模式 2：源数据

	REPLACE：替换函数，可以用来计算某个字符串出现的次数，把要计算的字符串替换为空字符串，
		 然后用原来的长度-替换后的长度，如果替换的字符串长度大于1，那就原来的结果再除长度
		参数：1：源数据 2：被替换的字符串 3;替换的字符串
		
	REPLICATE：以指定的次数复制字符串值
		参数：1：源数据 2：复制的次数
	
	STUFF：删除一个子串，再插入一个新的字符串代替
		参数：1：源数据 2：删除起始位置 3：删除长度 4：插入的替换字符串
	
	UPPER：转大写
		参数：1：源数据
	
	LOWER：转小写
		参数：1：源数据

	RTRIM：删除右边空字符
		参数：1：源数据
	
	LTRIM：删除左边空字符
		参数：1：源数据

字符的转义：
	在like中 ]、[、_、%都有特殊的含义，如果想要搜索他们本身，就需要对他们进行转义
		1：%[]%，在这种情况下，中括号里面的字符就会被转义
		2：或者 like '%xxx%' ESCAPE '转义字符'，定义一个不会出现在字符串里面的符号作为
		   转义字符
	相同的是他们都需要在两个百分号中间进行转义

日期和时间：	

	类型		存储大小	说明			准确度

	DATETIME	8	日期+时间			3.33毫秒
	SMALLDATETIME	4	小单位的日期+时间		1分钟
	DATE		3	日期				1天
	TIME		3-5	时间				可调(最高100纳秒)
	DATETIME2	6-8	日期+时间(更大的范围和准确度)	可调(最高100纳秒)
	DATETIMEOFFSET	8-10	日期+时间(可以用偏移量计算)	可调(最高100纳秒)

	如果要用字符串转为日期类型，最好用 YYYYMMDD hh:mm:ss.nnn 这种格式，因为一些特殊的格
式与DBMS的设置有关，也就是不同的设置会产生不同的结果

	如果不指定具体时间，则默认是00:00，不指定具体日期，则默认是1900年1月1日
	字符串YYYY-MM-DD转时间类型时，DATETIME和SMALLDATETIME是语言相关的，其它的类型是语言无关的

	如果只判断时间的话，比如 WHERE tm='12:30:15.123'，这时SQL Server会自动把字符串转为时间
格式，并且日期是基础日期，也就是1900-1-1，只查询日期也一样，时间会默认为0:0:0

	时间过滤的性能：如果要选择2007年的订单，这时候如果用函数索引就不会生效：
	索引生效：orderdate>='20070101' AND orderdate<'20080101'
	索引无效：YEAR(orderdate) = 2007

	获取当前时间：
		GETDATE()、CURRENT_TIMESTAMP[标准]、GETUTCDATE()[UTC格式]、SYSDATETIME()、
		SYSDATETIMEOFFSET()[包含偏移量]
	
	时间格式转换：
		CAST(源数据 AS 目标类型)，ANSI 标准 SQL
		DATEPART(要获取的类型, 数据源, [可选转换格式])
		可以获取DATE、TIME、DATETIME2、yyyy、MM、dd、hh、mm等
	
	CATEADD：时间的加减计算
		(在某部分超出的时候会自动向上叠加)
		参数1：类型，比如YY、MM、HH、DD等
		参数2：运算的数量：比如20、-13
		参数3：数据源

	DATEDIFF：时间的差计算
		(会用参数2的指定部分的类型减去参数3的指定部分的类型)
		参数1：计算部分的类型，比如YY、MM、HH、DD等
		参数2：数据源1(可以是时间对象，也可以是能隐式转换为时间的字符串)
		参数3：数据源2(可以是时间对象，也可以是能隐式转换为时间的字符串)

	ISDATE：判断字符串是否能转换为时间格式能则返回1，不能返回0
		参数1：字符串

	EXISTS是二值谓词，也就是只有TRUE和FALSE，不会出现UNKNOWN，因为在判断一个东西是否存在，
只要指定了具体的东西，那么结果肯定只有存在和不存在，如果出现未知的话，那么就是指定的东西有问题
，那样根本不会通过编译

	如果使用IN的话，就要注意目标集合里面出现NULL，IN里面的判断是第一个结果or第二个结果or第
三个结果，如果有某个结果为NULL，那么就会出现比如：FALSE or TRUE or UNKNOWN，那么不管其它结果怎
么样，最终的结果肯定是UNKNOWN，因此IN永远会为UNKNOWN， NOT IN也会为UNKNOWN

	对于列名，子查询中使用的列名会由内而外的查找，就是先在本语句中找，找不到再去上一层语句
找，一直往上

	公用表表达式(CTE)：使用这种方式可以产生一个结果集！结果集！不是临时表，如果同一组数据在
查询时需要多次使用，就不用写多个一样的子查询：
	WITH tableName AS (
		SELECT ORGID FROM Supply WHERE supply=0
	)
	如果公用表表达式上面还有其他语句，那么它的上一条语句就必须加分号，否则无法执行
	外部格式别名：在tableName后面加上括号，可以在括号里面起别名，顺序对应查询的字段
	定义多个CTE不需要多个WITH关键字，只需在一个CTE的括号后面加逗号，就能继续定义，并且后定
义的CTE能引用前面的CTE，可以内嵌前面的CTE，也能直接用前面的CTE当主表查询(列必须指定别名)

	WITH使用时注意，因为是虚拟的，所以在定义时不会耗费什么资源，而是在使用时耗费资源，因为
每次使用都会去涉及到的底层表里面进行处理如果多次调用公用表，那么就会多次调用底层表，因此有时还
不如直接用个临时表保存数据，免得多次调用底层表增加开销
	注意临时表不是表变量，而是前缀带#的临时表

	CTE可以递归：执行第一个SELECT的结果用来执行第二个SELECT，第二个SELECT执行的结果继续调
用第二个SELECT，直到返回空集，或者达到一定次数(次数默认100次，也可以自己设置)，临时的数据保存
在tempdb中

	SQL Server除了数据展示时，其他时候都不能使用ORDER BY，因为没有意义，除了两种情况：当前
语句中使用TOP和FOR XML选项，在使用TOP时用ORDER BY，在当前的语句中数据是有序的,可是返回到外部表
之后的数据就无法保证有序性了

视图就是可复用的加强版公用表表达式
	视图的选项：
	在视图名后加
		WITH ENCRYPTION(加密) ：不能看到视图的源SQL
		WITH SCHEMABINDING(绑定)：不能删除视图相关的列，以免导致视图出错
	也可以在最后加
		WITH CHECK OPTION(带检查选项)：该视图关联的表不能修改，免得每次视图返回不同的数据

内联表值函数(其实就是带参数的视图)
	语法:
	CREATE FUNCTION 架构名.函数名
		(@param1 AS INT, @param2 AS CHAR...)
	RETURN TABLE AS		
	RETURN SELECT c1, c2, c3 FROM tableName WHERE id1=@par1 NAD id2=@par2
	使用：
		函数名()，括号里面塞参数

APPLY：
	功能类似于连接JOIN，不过他可以在第二张表引用第一张表的列，也就是用第一张表的每一行匹配
一次第二张表的数据
	CROSS APPLY：交叉连接的功能
	OUTER APPLY：外连接的功能，不过只能连左边，也就是保留第一张表的所有数据

集合运算：
	UNION：并集
	INTERSECT：交集
	EXCEPT：差集

	其中INTERSECT的优先级最高，UNION和EXCEPT的优先级一样，所有的集合运算都会默认使用DISTINCT
，只有UNION支持ALL，其他两种没有直接支持，可以自己用ROW_NUMBER()实现

	如果列名是数字，在引用的时候为了区分列名和数字，列名应该用[]包起来，也就是[列名]

透视转换：
	就是把原来的行列信息换一种方式展示，可能是原本的行变为列，逆透视转换是把列转为行，标准
的SQL中使用CASE语句来达到效果,T-SQL可以用PIVOT和UNPIVOT达到相同的效果,不过没有自己使用CASE灵活

分组集：
	多个表分组的并集，有时候需要对一个表进行不同的分组，并且得到数据，这时候可以在分组后使
用UNION ALL多次达到目的，SQL中有更加便捷的方式只要一个SELETE和一个GROUP BY就能得到多个分组的集
合，在GROUP BY后面加：
	GROUPING SETS ( (分组1), (分组2), (分组3)..... )：多个指定分组的并集
	CUBE(列1, 列2, 列3...)：用字典算法找到所有的组合，包括()空分组，也就是没经过分组的数据
	ROLLUP(列1, 列2, 列3....)：用1,2,3、1,2、1、空这种每次从后面减一列的方式分组取并集
	如果定义多个分组，有某一列没有包含出现在分组中，并且没有聚合，(一般情况下是不合法的行
为)会用NULL填充

区分分组集中不同的分组：
	GROUPING(某一列)：如果当前分组是GROUPING中指定列对应的的分组，GROUPING返回1，否则返回0
	GROUPING_ID(列1, 列2, 列3...)：就是8,4,2,1，只有3列就是4,2,1，这三个不符合哪一列那一列
就置为1，如果都符合为0，都不符合就为7

创建临时表：创建一个名为Number的表，有一个名为n的列，n列有十行数据：1-10
	SELECT * FROM(VALUES(1),(2),(3),(4),(5),(6),(7),(8),(9),(10)) AS Number(n)

INSERT INTO：
	INSERT INTO tableName(row1, row2, row3...) 后面可以指定VALUES、SELECT、EXEC等语句

SELECT INTO：
	在完整的SELETE语句的FROM前面加上INTO newTableName，就能用查询的结果创建一个新表，创建
的新表不会复制3样东西：约束、索引和触发器(主外键约束对其它表有影响、索引因为索引可能是多列复合
索引，而只选择了一部分，可能会不完整，因此也不会有，触发器对其它表也有影响)

BULK INSERT：
	将文件导入数据库

IDENTITY：
	在创建表的时候可以把字段设置为IDENTITY(初始值, 递增值)
	如果加新增值失败了，IDENTITY的标志值也会增加
	通过@@identity获取所有会话的最新IDENTITY值；通过SCOPE_IDENTITY获取当前会话的IDENTITY值
；通过IDENT_CURRENT('表名')，获取对应表的最新IDENTITY值
	可以通过设置 SET IDENTITY_INSERT tableName ON or OFF来决定是否可以手动输入IDENTITY，
如果手动输入的值小于标志值，那么该输入有效，IDENTITY本身不会强制标志列的唯一性可是标志符不会被
改变，只有大于标识符的输入才会改变标识符的值
	只能在列创建的时候把列的属性设置为IDENTITY
	事务回滚是不会回滚IDENTITY的标识值的

TRUNCATE：
	删除表中的所有行，与DELETE不同的是：
	DELETE：以完整模式记录日志，比如会记录删除数据数量的信息；删除所有的数据后IDENTITY的标
志值依然存在；

	TRUNCATE：以最小模式记录日志，因此效率会高很多；删除所有的数据后IDENTITY的标志值会重置
为最初的值；当表被外键表引用时，禁止使用TRUNCATE，即使是空表，如果非要使用，只能先删除正在引用
目标表的所有外键(是取消外键约束，而不仅仅是删除外键列的所有数据)

	DELETE基于联接使用：
		DELETE FROM A 
			FROM TableA AS A 
				JOIN 
			TableB AS B
			  ON A.id=B.id
		WHERE B.number=1
	这样会把A表所有和B表ID相同，并且那一行的B表number=1的数据删除，这是一种非标准用法使用
子查询也能达到相同的效果

如果要使用两个不同数据库的表在同一语句中使用，可以使用[库名.架构名.表名]的方式调用不同库的表

UPDATE：
	UPDATE时，使用的源列值都是更新之前的值，也就是说如果在同一语句中UPDATE了某个数据，然后
在同一语句中使用被更新的值，那么这个值还是更新前的值，只有下一条语句获取的这个值才是更新后的

	同样，UPDATE也能使用联接，虽然一次只能修改一张表的数据，但是SET后面可以同时引用两张表
的列，也就是能用表2的数据为表1赋值

	UPDATE时可以定义一个变量来接受UPDATE后的值，比如：
		UPDATE tableName SET @value=number+=5
	这里SET后面赋值语句会从右往左执行，先改变值，然后复制给@value变量，他们是原子操作

MERGE(表合并)：

	MERGE INTO targetTable			--目标表
	USING sourceTable			--资源表
	  ON targetTableId=sourceTableId	--匹配条件
	WHEN MATCHED AND 
	(targetTableName<>sourceTableName OR targetTableCode<>sourceTableCode) THEN
	  --目标表在资源表找到匹配的数据，并且Name和Code有一样不相等条件成立
	  --AND是可选项，AND不能用在下面两种条件下
		UPDATE SET				--执行修改
			targetTableName=sourceTableName,
			targetTableCode=sourceTableCode
	WHEN NOT MATCHED THEN				--资源表在目标表找不到对应数据
		INSERT(customerName) VALUES(supplyName)	--执行增加
	WHEN NOT MATCHED BY SOURCE THEN			--目标表在资源表找不到对应数据
		delete;					--就删除，删除只能在这个条件下执行
	--操作说明：在目标表的角度看来，INSERT代表缺少了就拿，DELETE代表多余了就删
	--所有的操作都是针对目标表

通过表表达式修改数据：
	WITH T AS(
		SELECT customerId, ROW_NUMBER() OVER(ORDER BY id) AS number FROM tblRemarks
	)
	UPDATE T SET customerId=number
	--定义一个临时表，并且新增一个number列，然后把number列的值赋给源数据的列，如果直接用
UPDATE语句，ROW_NUMBER函数是无法使用的，因此可以通过表表达式来达到为一列增加number的效果

不需要条件对数据进行修改或删除：
	可以删除或修改数据的一定百分比或者指定数量，使用表表达式用TOP查询出想要操作的数据，TOP
可以排序，然后选择想要的数量或百分比，然后用DELETE或UPDATE对表表达式进行操作，会直接对表表达式
查出来的数据进行操作

	表表达式查出来的数据，可以进行修改或删除，会直接影响到源表，因为表表达式在底层会自动转
为对源表的操作，需要注意的是自定义列不能进行修改,不过可以用自定义列赋值给源列

OUTPUT：
	OUTPUT可以在对数据进行修改的时候获取修改的值，增加在语句的WHERE前面，可以使用inserted、
deleted，deleted返回的是修改前的数据，inserted返回的是修改后的数据
	比如：
	UPDATE tableName SET price*=0.8 
		OUTPUT deleted.price, inserted.price
	WHERE store='xx'
	这样就会返回所有被修改行的修改前和修改后的price列

事务必有的四个属性：
	原子性：在一次事务中的操作，要么全部执行，要么全部不执行
	一致性：在任意时刻，多个节点的值是一致的，同一时间点，你在事务A中获取到key1的值与在事务B中获取到key1的值应该都是一样的。
	隔离性：事务之间的数据互相不影响
	持久性：将数据修改写入磁盘
	
锁：
	排他锁(X)：要对资源进行修改时，事务就要获取排他锁，如果目标资源没有锁被把持，那么就可以
获取排他锁，排他锁只能唯一存在，在资源没有其他锁(包括排他锁)被把持的时候才能获取
	共享锁(S)：要对资源进行读取时，事务就要获取共享锁，如果目标资源的排他锁没有被获取，那么
就可以获取共享锁，如果目标资源的共享锁被获取了，后面的事务依然能获取共享锁
	对于一个事务来说，它能同时持有一个资源的排他锁和共享锁，因为一个事务是一个线程，因此不
会发生并发，排他锁并不是执行了UPDATE语句就会被持有，而是数据被修改后的值与修改前不同才会获取对
应修改行的排他锁，注意如果涉及的行到了一定数量，被锁资源的粒度就会升级(本来锁很多行，变成锁一页)

查询当前各个会话的锁状态：

	SELECT 
	  request_session_id,
	  resource_type, 
	  resource_database_id,
	  DB_NAME(resource_database_id),
	  resource_description,
	  resource_associated_entity_id,
	  request_mode,
	  request_status
	FROM sys.dm_tran_locks

意向锁：
	事务为了获取了低粒度资源的锁，要先在更高粒度的资源为该事务获取相同类型的意向锁，比如获
取了行的排他锁，那么会同时获取页和表的意向排他锁，这么做是为了在更高粒度检测不兼容的锁定请求，
意向锁不会阻止其他事务获取不兼容的锁类型

	在获取锁时，如果锁不能获取，那么事务会进入 阻塞状态，在默认情况下，被阻塞的请求会一直等
待，直到原来的事务释放相关的锁，

开启事务后，在事务结束前就会一直把持锁(有的隔离级别可能会自动释放一些锁)，直到提交或回滚

各个隔离级别-所导致>所解决的问题(高隔离级别会出现的问题一般低隔离级别也会出现)：

未提交读-脏读：

	READ UNCOMMITTED，未提交读，如果隔离级别设置成未提交读，那么在读数据的时候是不需要获取
共享锁的，因此直接获取有时候会获取到未提交事务的数据，这时候如果事务进行回滚，未提交读就会拿到
错误的数据，也就是脏读
	
已提交读-不可重复读>脏读：

	READ COMMITTED，已提交读，如果隔离级别设置成已提交读，在读数据时就需要获取共享锁才能读
取数据，不过在读取之后会马上释放，如果在释放共享锁后，其他事务修改了数据，然后当前事务再读取数
据，就会获得新的数据，造成在同一事务内，相同的查询，中间没有进行修改，取得的结果不一致，这就是
不可重复读，或者叫不一致的分析

可重复读-更新冲突-幻读>不可重复读：

	REPEATABLE READ，可重复读，如果隔离级别设置成可重复读，在读取数据时会获取共享锁，并且在
事务内读取时，事务结束前，共享锁不会被释放，因此其它事务无法对被锁定的资源进行修改，这样每次读
的数据就能保持一致性了
	但是因为共享锁锁定的是满足查询条件的行，如果这时候使用INSERT语句新增一行，是不会对被锁
定的数据产生影响的，因此可以新增行，可是增加的行如果满足查询条件，并且在两次查询中间执行，那么
同一事务在第二次查询就会出现新的数据，这就是幻读
	可是如果两个事务都在读取同一资源，共享锁能被两个事务同时获取，然后这两个事务都想修改这
个资源的数据的话，因为共享锁被对方把持，因此无法获取排他锁，两边都在等待对方释放共享锁，这时就
会发生死锁，也就是更新冲突

可序列化-死锁>幻读：

	SERIALIZABLE，可序列化，如果隔离级别设置成可序列化，在读取时获取共享锁，并且在事务结束
前会一直把持共享锁，并且会对获取共享锁的查询语句进行锁定，如果有其他INSERT的语句，增加的数据满
足获取共享锁的查询语句的条件，就会阻塞这个ISNERT语句，如果不满足条件就不会被阻塞，这样就不会出
现幻读了，因为一直保持共享锁，因此也会发生死锁(更新冲突)

快照：
	快照是使用行版本控制的，数据库在每次修改数据时，都会在tempdb库里面创建一个版本，在取数
据时可以根据版本号取数据，具体的创建版本时间是事务提交的时候，如果在一个事务中对数据进行修改，
只要还未提交，那么版本依然不会更新，在其他事务处是不可见的

SNAPSHOT：
	功能和SERIALIZABLE很类似，在事务开启时取最新行版本，根据行版本在tempdb里取对应版本的数据

READ COMMITTED SNAPSHOT：
	功能和COMMITTED SNAPSHOT很类似，在语句执行前取最新行版本，根据行版本在tempdb里取对应版
本的数据

更新冲突：
	快照对更新冲突的处理方式和其它隔离级别不一样，其它隔离级别在冲突时会造成死锁，在快照中，
如果发生更新冲突，那么后面更新的语句会直接报错

死锁：
	如果两个事务去获取对方持有的锁，并且因为不兼容，无法成功获取，就会都进入阻塞状态，因为
是相互阻塞，因此是永久性的阻塞，也就是死锁，如果发生了死锁，SQL Server能很快的检测出来，并且根
据事务的优先级进行处理，先根据优先级，把优先级低的事务当做死锁牺牲品来停止进程，并且回滚该进程
，如果优先级都一样，那么会根据回滚开销最低的进程作为死锁的牺牲品
	如果发生死锁，是两个进程互相获取对方资源导致的，可以尝试调换一下资源的锁获取逻辑，比如
把两个进程的锁获取顺序都改为一样，这样后获取的进程就会被早获取的进程阻塞，等先获取的进程结束后
面的才能开始执行，这样就不会发生死锁了

使用KILL 会话ID可以结束对应会话的进程

定义变量：
	DECLARE 变量名 AS 变量类型
	可以在变量类型后面直接赋值，也可以用SET赋值
赋值：
	SET 变量名 = 值

查询出来的结果直接赋值：
	SET 变量名 = (SELETE语句)如果返回多个数据则报错

	SELECT @id=id FROM table 直接在语句里赋值，如果返回多个数据，则保存返回的最后一个数据

批处理：

	批处理是从客户端发送到SQL Server的一组或多条SQL语句，SQL Server将每一个批处理语句作为单
个可执行单元，批处理需要经理的处理阶段有：
	1、分析：语法检查
	2、解析：检查引用的对象和列是否存在、是否具有访问权限
	3、优化：作为一个执行单元
  在经过这三个阶段后，批处理才会开始被执行

	GO，可以用GO分开多个批处理，GO是一个批处理的结束词
	GO n，可以多次执行这个批处理，n代表的是执行次数
	
	GO是客户端的工具

	多个批处理之间定义的变量无法共用，变量的作用域只在当前的批处理里面

	每个批处理里面，如果有语法错误，那么这个批处理都不会执行，因为SQL Server采取的策略是先
分析，再尝试执行，但是其它用GO隔开的批处理能够执行，因为每个批处理分析没有语法错误才会提交，语
法错误不会提交

	很多CREATE语句不能与其它(IF、WHILE)语句一起编译，比如CREATE VIEW之类的，但是不包括CREATE
TABLE，如果想一起用，可以考虑用GO分开

	如果同一批处理之中，对一个表的结构进行改变，然后马上使用改变后的地方，因为批处理是在执
行前解析的，因此后来增加的结构它认为不存在，因此会出现错误，这时候需要把新结构的使用放在一个新
的批处理中，让它重新解析

流程控制：

	IF ELSE 能跟java里面一样使用，不过后面的条件不需要括起来，并且里面执行的语句也跟java一
样，只有一条语句的话不需要括号，如果有多条语句，就需要使用BEGIN END包起来，BEGIN END作用跟java
的{}一样，说明被包起来的程序是个语句块

	WHILE的用法也与IF一样
	
	这些流程控制语句互相之间可以嵌套使用，并且和批处理语句也相互能嵌套使用

	在表名后面加：ForceSeek，可以强制走表索引

临时表：
	如果创建的表名前面加上#，那么它就是一个临时表，这张表保存在tempdb，并且只有当前会话可见
，如果当前会话结束，这张表会被SQL Server自动删除

全局临时表：
	如果想要表对所有会话可见，那么在表名前面加##，这样这张临时表对所有会话都会可见，如果没
有任何会话引用它，并且并且创建临时表的会话也断开，SQL Server就会自动删除它
	事务也对临时表有效
	显式删除临时表：DROP TABLE tableName，跟删除普通表一样
	如果有大量临时数据，那么使用临时表性能更好

表变量：
	表变量也和临时表一样，在tempdb数据中存在，并且也只对创建它的会话可见，不过它的访问范围
更加有限，只在当前批处理中可见，和一般的变量一样，但是事务的回滚对表变量已完成的操作是无效的，
只对未完成或执行失败的操作有效

表类型：
	通过创建表类型，可以把表类型保存到数据库中，以后再定义表变量、存储过程和用户定义函数的
输入参数时可以重用

EXEC：
	EXEC(execute)可以执行执行字符串类型的SQL，用法是EXEC(@sql)，@sql是一个字符串，因为是字
符串，因此要注意@sql里面的单引号需要转义

sp_executesql：
	使用存储过程的方式执行字符串sql，并且可以参数化赋值，也就是在SQL里定义变量，然后再为变
量赋值，只接受UNICODE类型字符：
	DECLARE @sql AS NVARCHAR(200) = SELECT * FROM user WHERE id = @id;	--定义sql
	EXEC sq_executesql				--执行存储过程
		@stmt = @sql,				--传入sql语句
		@parpams = N'@id AS INT'		--定义一个sql里相同的变量
		@id = 5;				--为变量赋值

例程：

	例程是为了计算结果或执行任务而对代码进行封装的一种编程对象，看这个解释很像函数，SQL Server
支持3种例程：用户定义函数、存储过程、触发器

用户定义函数(UDF，user defined function)：
	
	UDF不能对数据进行修改，NEWID和RAND(随机数)也不能用，因为数据库会在底部进行某种信息设置
，因此会造成看不见的修改

	标量UDF(返回一个值)：
		CREATE FUNCTION dbo.fn_ts(	--创建名为dbo.fn_ts的函数
		  @key AS INT			--参数
		)
		RETURNS NVARCHAR(20)		--返回的类型集合
		AS
		BEGIN
			RETURN(SELECT datacol FROM T1 WHERE keycol = @key)	--根据参数查询并返回
		END

	表值UDF(返回一张表)：没有介绍

	用法：SELECT 结构名.函数名(参数)

存储过程：
	封装逻辑、避免SQL注入、对表操作的权限控制、整合所有执行中出现的错误、提高执行性能(以前
缓存过得执行计划能够重用)、减少网络通信流量(只需要参数和存储过程名就能执行，而不要sql语句)

SET NOCOUNT ON;		禁止显示DML语句(比如影响了多少行的信息)
@@rowcount：		获取存储过程中最近的查询语句返回行数

错误捕获：
	BEGIN TRY					--try，跟java很像
		EXEC('SELECT * FROM SUPPLY1')
		PRINT 'NO ERROR'
	END TRY
	BEGIN CATCH					--catch，不过用begin和end代替{}
		PRINT ERROR_SEVERITY()			--ERROR_SEVERITY()是产生的错误码
	END CATCH 

乐观锁：
	使用版本号控制并发操作，比如给表增加一个version字段，version一开始为0，每行的数据每次进
行改动version都会+1，这时候有两个线程对同一行进行操作，两个线程同时select到数据，这时版本号都为
0，然后线程2先提交修改，首先判断select到的version是否还是为0，如果为0就把version+1，然后修改
，否则就获取到当前的version，把数据的version改成当前的version，然后再去判断，直到某次version相等

	按照当前的场景，线程2发现version还是为0，然后把version改为1，进行修改，接下来线程1也准备
提交，这时候发现数据库里的version为1，而自己的version为0，所以先把自己的version改为1，然后再试图
提交，这次提交就发现version相等了，因此把version改为2，然后修改

	乐观锁开发者自己可以控制version，而悲观锁就是实际上给某些操作加锁，比如synchronized，和
数据库里的行锁表锁等，这些操作是数据库或者语言本身提供支持，因此开发者去启动就行了，不需要自己
实现










