优化法则归纳为5个层次：
1、减少数据访问（减少磁盘访问）
2、返回更少数据（减少网络传输或磁盘访问）
3、减少交互次数（减少网络传输）
4、减少服务器CPU开销（减少CPU及内存开销）
5、利用更多资源（增加资源）

1、通过索引优化：

索引生效：
	当字段上有索引时，当索引字段使用=、>、<、>=、between、in、like "abc%"(模糊在后面)、使用表关联时索
引字段=非索引字段时。
总结：范围查询或者明确查询会使用索引，like的%必须在后面

索引不生效：
	<>、function(index_column) = ?、not in、index_column+1 = ?、like "%abc"、is null(索引不会存储null
)、索引字段和比较字段类型不一致(因为数据库会自动将类型转换成一致，这样就多了一层函数)、在条件比较时不能比
较未知值，比如index_column = column，必须是明确的值。
总结：不能使用非，比如<>、not in等、is null、索引字段不能经过运算、必须只使用字段、like的%不能在左边，比
较两边的类型应该一样，比较的值应该是常量

组合索引：
	需要按照索引的顺序查询，并且符合上面的索引生效条件，比如索引是id、name，那么必须先id = ? AND name
 = ? ，不能直接name = ?，因为索引是在id的节点上面再加一层name索引，不能直接使用name索引

建立索引的列一般是id、编号、时间、年龄等字段

非聚簇索引需要额外的存储空间，并且对insert、update、delete等操作会有额外的开销，因为除了修改原来的数据，
还要额外去维护其它的索引文件的数据

创建索引：CREATE INDEX index_name ON table_name (id, no, type)

2、返回更少的数据

分页：
	在不需要所有数据的时候采取分页，当然客户端需要操作流畅的时候也可以不分页，并且分页前的数据尽量通
过索引查询

只返回需要的字段：

	查询尽量不用*，并且可以剔除那些del_flag、create_time等不需要的字段
	如果有某个字段是大字段，内容很长，并且不是每次都需要这个字段，那么可以用分表，把这个字段单独放在
一个表里，与原来的表成为一对一，不常用的字段也可以这样，可以增加常用表的性能


3、减少访问次数

批处理：
	如果一个逻辑里的sql较多，并且不需要返回值也能全部执行，可以使用批处理，一次处理多条，如果同一个字
段需要查多次，那么可以用in，而不是多次查询，在mybatis中需要获取到sqlSessionBatch，它执行的命令不会发送给
服务器，需要进行commit才会一次性发送

fetchSize：
	查询的时候每次返回的数据量，比如查询出了1000条数据，如果fetchSize=100，那么服务器会分10次返回给客
户端，fetchSize设置太小会造成通信次数过多，设置太大一次性有太多数据会导致内存溢出，因此应该根据业务来设置
，在mybatis中的<select>标签可以设置fetchSize属性，每个sql都可以有各自的fetchSize

存储过程：
	优点：存储过程可以执行多条sql，减少网络交互成本，存储过程只需要进行一次编译，性能更高
	缺点：不可移植、业务逻辑分散、没有应用程序灵活、引用的表或者视图进行了变更，就需要重新编译

业务逻辑优化：
	这个要看业务

4、减少服务器cup开销

绑定变量：
	相同的sql会使用同样的执行计划，因此如果使用绑定变量，那每个sql只需要生成一次执行计划，不使用则几
乎每次查询都会生成执行计划，绑定变量就是在sql中用?代替参数，然后再设置每个参数，mybatis中自动使用了

大量需要like %abc%的数据：
	应该使用全文索引来提高性能

大量复杂的运算应该在客户端处理

5、利用更多资源

1、使用索引：索引生效和不生效的条件
2、使用批处理：如果中间的的sql不需要获取结果
3、使用存储过程：如果某些sql很频繁的执行
4、优化业务逻辑
5、只查询需要的字段、分页
6、分表，把不常用的数据放在另外一张一对一关系的表里
7、分库，按照功能划分到不同的服务器
8、读写分离，开主从服务器
9、把频繁查询的数据放在redis









