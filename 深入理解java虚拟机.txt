java运行时内存数据区域：
	栈、本地方法栈、堆、程序计数器、方法区(永久代，元空间)

    程序计数器：
	程序计数器是线程私有的，它记录了当前程序执行的字节码行号指示器如果执行的是java代码，计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，计数器则为空。程序计数器是唯一一个在JVM中没有规定会内存溢出的区域

    Java虚拟机栈：
	栈是线程私有的，它的生命周期与线程相同，存放的元素是栈帧，每个方法执行时都会创建一个栈帧，它包含了存储局部变量表(包含编译器就可知的各种基本数据类型、对象起始地址的引用、returnAddress类型(栈帧中下条指令的地址))、操作数栈(主要用于保存计算过程的中间结果，比如复制、交换)、动态链接(比如import的类链接)、方法出口等信息。每个方法调用到执行完成都对应着一个栈帧在栈中入栈到出栈的过程
	如果线程请求的栈深度超过虚拟机允许的深度，就会抛出StackOverflowError异常；或者栈扩展时如果申请不到足够的内存就会抛出OutOfMemoryError

    本地方法栈：
	本地方法栈是线程私有的，它与虚拟机栈的作用非常相似，区别只是虚拟机栈为Java方法服务，本地方法栈为虚拟机使用的Native方法服务。本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常

    Java堆：
	堆是线程共享的，此区域的唯一目的就是存放对象实例，几乎所有的对象和数组实例都在这里分配内存，有一些技术可以在栈上分配，不过一般用不上。
	堆还可以细分为：新生代、老年代。再细致一点，新生代还有：Eden、From Survivor、To Survivor等。
	如果堆中的内存不足以完成实例分配，且堆无法再扩展，将会抛出OutOfMemoryError异常

    方法区：
	方法区是线程共享的，它用于存储被虚拟机加载的类信息、常量、静态变量、编译后的代码等。
	虽然方法区被很多人称为永久代，因为方法区由永久代实现。但方法区并不是不会被GC回收的，仅仅是因为HotSpot团队选择将GC分代用在方法区，使用了永久代来实现方法区，可以像管理堆一样管理这块内存，这样就能省去专门为方法区编写管理内存代码的工作。
	JVM对方法区的限制非常宽松，除了和堆一样可以选择固定大小或可扩展外，还可以选择不实现垃圾收集，垃圾收集在这个区域很少发生，就算有比如常量池的回收和对类的卸载，它们的条件都很苛刻
	在JDK8中方法区已经由元空间来实现，内存完全放在本地内存了，字符串常量池也移到了堆中，其它常量池依然在方法区
	JVM规范规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError
    静态常量池(Class文件常量池)：
	存放类的版本、字段、方法、接口等信息，在类被加载时就存在了
    运行时常量池：
	存放符号引用、直接引用，运行时常量池可以在类被加载后才加入常量池的，比如String.intern()方法。JDK1.8中字符串常量池移到了堆中其它运行时常量池依然在方法区
    我们常说的常量池指的是运行时常量池，由于运行时常量池也是方法区的一部分，它同样会抛出OutOfMemoryError异常。

    直接内存：
	在本地方法中进行分配的内存，比如NIO使用了本地函数库进行缓冲区的内存分配，这样就能避免在Java对和Native堆中来回复制数据，提高性能，但是这部分内存不被堆管理，但还是受到本机内存的限制，如果超出依然会抛出OutOfMemoryError，会出现设置了-Xmx(最大堆内存)很大的情况下依然内存溢出，因为JVM之外的内存不够用了


判断对象是否需要回收的算法：

    引用计数算法：
	给对象添加一个引用计数器，当有地方引用它时，计数器+1，当引用失效时，计数器-1，当有对象循环引用时，它将无法
    通知GC回收它们
	引用计数器解决循环引用的方法是，重写了=符号的算法，当A引用B时，就是强引用，如果B此时再引用A，那么就会是弱引     用，算法只对强引用进行计数；如果出现一个很大的循环怎么处理，每次赋值都要遍历每个对象的每个引用判断是否有循环引      用吗？这个问题没找到答案


    可达性分析算法：
	通过一系列GC Roots对象向下搜索，搜索走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，也就是    GC Roots到这个对象不可达时，则证明此对象不可用，所以它们将会被判定是可回收的对象
	1、GC Roots可以是栈帧本地变量表中引用的对象
	2、也可以是方法区中静态变量引用的对象
	3、也可以是方法区常量引用的对象
	4、也可以是本地方法栈中引用的对象

对象的回收与finalize()方法：
	当在可达性分析算法中不可到达某个对象时，这个对象并非是必须回收不可的，而是先将它进行一次标记，并筛选其是否      需要执行finalize()方法，如果finalize()方法已被虚拟机调用过，或者对象没有重写finalize()方法，虚拟机都不会执行
	如果这个对象被判定为有必要执行finalize()方法，那么这对象将会放置在一个叫做F-Queue的队列中，然后会由一个虚拟     机创建，低优先级的Finalizer线程去执行。虚拟机只是会触发这个方法，但不承诺等待它运行结束，因为如果某个对象的         finalize()方法执行缓慢，将会导致F-Queue队列中其它对象一直处于等待中，甚至整个回收系统崩溃。finalize()方法是对象     逃过死亡的最后一次机会，稍后GC将对F-Queue中的对象进行第二次标记，如果执行了finalize()变为可达了，那么它就逃脱了     被回收的命运，第二次标记时它将被移出“即将回收”的集合，此时如果它依然不可达，那基本上它就真的被回收了
	每个对象自我拯救(在finalize()中重新建立可达的引用)的机会只有一次，因为就算自我拯救成功，下次如果被回收时        finalize()方法就不会被执行了，因为它已经执行过一次了
        虽然对象可以通过finalize()方法避免被GC回收，或者回收资源，但是并不建议这么做，因为它运行代价高昂，并且充满    不确定性，通过其它方式完全可以做的更好、更及时，比如通过try-finally回收资源


Java中的引用：
    强引用：
	代码中普遍存在的，用=进行赋值的，垃圾收集器永远不会回收被引用的对象
    软引用：
	用SoftReference类来实现的，当系统内存将要溢出时进行回收
    弱引用：
	用WeakReference类来实现，每当进行GC时就会回收掉弱引用的对象，它的声明周期只有一次GC的间隔
    虚引用：
	PhantomReference类来实现，虚引用唯一的作用就是能在这个对象被回收时得到一个系统通知，无法通过虚引用得到对象


方法区的回收：
    方法区的回收主要分为两部分：废弃常量与无用的类

	废弃常量：
	    以常量池中的字符串为例，假如字符串"ABC"进入了常量池中，但是没有任何String对象引用常量池中的"ABC"      	常量，其它地方也没有引用这个字面量，如果这时发生GC，而且必要的话，这个"ABC"就会被系统清理出常量池，常量池中	的其它符号引用，比如：类、接口、方法、字段等也与此类似

	无用的类：判断一个类是否无用需要符合以下三个条件：
	    1、该类的所有实例都被回收了
	    2、加载该类的ClassLoader已经被回收了
	    3、该类对用的java.lang.Class对象没有被任何地方引用，无法在任何地方通过反杀访问该类的方法
	当满足以上三个条件时，就可以对类进行回收，但不代表一定会进行回收，HotSpot虚拟机提供了参数进行控制：
	    -Xnoclassgc：是否对类进行回收
	    -verbose:class：在JVM加载类时会输出信息
	    -verbose:gc：在发生GC时会输出GC信息
	    -verbose:jni：输出native方法调用情况
	    -XX:+traceClassLoading：查看类加载信息
	    -XX:+TraceClassUnLoading：查看类卸载信息
	在大量使用反射、动态代理、CGLib等字节码框架、或者频繁自定义ClassLoad的场景都需要虚拟机具备写在类的功能，以      保证永久代不会溢出


垃圾收集算法：

    标记-清除算法：
	先对无法到达的对象进行标记，在标记完成之后同一对标记了两次的对象进行回收，不足的是标记与清除的效率都不高，      并且会产生大量不连续的内存碎片

    复制算法：
	将内存分为两块连续、相等的大小，每次只使用其中一块，当一块内存用完时，就将还存活的对象复制到另外一块上，并      将原来那块内存清理掉，这样实现简单高效，而且不会有内存碎片，缺点是内存只有一半，代价太高
	现在的商业虚拟机都采用复制算法来回收新生代
    新生代中的用法：
	由于新生代中98%的对象都活不过一轮GC，所以并不需要按照1:1来划分内存空间，而是分为一块较大的Eden区和两块          Survivor区，每次只是用Eden区和一块Survivor，每当回收时，就将Eden区和Survivor区中还存活着的对象一次性复制到另外      一块Survivor区，然后清理掉Eden和原来的Survivor区，Eden和Survivor的比例是8:1，也就是每次都能使用新生代90%的容量      (当然，如果上次回收Survivor没满的话，实际上最大只有80%+上次没被回收的部分)，仅仅会浪费10%，当存活的对象超过         Survivor区的空间时，就需要依赖老年代进行分配担保(直接将存活的对象放入老年代)
        由于复制算法在对象存活率较高时需要进行较多的复制操作，而且在Survivor区不足的情况下要有额外的空间进行分配担      保，但是老年代没有其它的分配担保空间，所以老年代一般不直接使用这种算法

    空间分配担保：
	发送Minor GC之前会先判断老年代是否能塞的下整个新生代，如果塞不下就会判断HandlePromotionFailure参数：是否允      许担保失败，如果允许，并且老年代剩余的连续空间大于历次晋升老年代的平均值，就会执行一次Minor GC；如果不允许担保
    失败，或者老年代剩余连续空间小于历次晋升老年代的平均值，就会进行FULL GC，然后再Minor GC，如果第一步能直接塞下，     就不用管那么多，直接Minor GC。
	如果大于平均值，但是幸存者大于历次平均值，导致老年代放不下，也会进行Full GC再Minor GC
	

    标记-整理算法：
	标记整理算法在标记的过程与标记-清除算法一样，但是到了清除那一步，不是直接对被标记的对象进行清理，而是让所有     存活的对象都向内存的某一端移动，然后直接清理掉最后一个对象之后的内存，这样就能保证没有内存碎片

    分代收集算法：
	这种算法只是将对分为两部分，新生代和老年代，新生代每次垃圾收集都有大量对象失去，所以采用复制算法，只要付出      少量存活对象的复制成本就可以完成收集；而老年代因为对象存活率高，也没有额外的空间对它进行分配担保，就必须使用标      记整理或者标记清除算法来进行回收


HotSpot的算法实现：
    枚举根节点：
	以可达性分析中从GC Roots节点找引用链的操作为例，可作为GC Roots的节点主要有常量、静态变量、栈帧中的本地变量      表中。可达性分析进行工作时还必须保证整个工作在一个能确保一致性的快照中进行，不可以出现分析过程对象引用关系还在      不断变化的情况，否则分析结果的准确度无法得到保证，这点是GC进行时所有Java线程都停顿的重要原因，Sun将这件事称为：     Stop The World
	根节点枚举的意思是JVM统计所有GC Roots的过程

    安全点(Safepoint)：
	在OopMap(一组数据结构，将对象内的偏移量是什么类型、栈和寄存器中哪些位置是引用等信息记录下来，这样GC在扫描时    就能直接得知这些信息了)的协助下HotStop可以快速且准确地完成GC Roots枚举
	HtoStop并没有为每条指令都很差OopMap，而是只有到达安全点时才记录这些信息，而且到了安全点才能暂停其它线程进行     GC，由于安全点不能太频繁以致于增大运行时的负荷，也不能间隔太久让GC等待时间太长，所以只有在方法调用、循环跳转、      异常跳转等具有这些功能的指令才会产生安全点，因为这些功能都不会操作对象引用
	还有一个问题是，怎么在GC发生时让所有线程都到达最近的安全点，然后停顿下来，这里有抢先式中断和主动式中断。抢      先式中断就是在GC发生时直接把所有线程全部中断，如果有线程不在安全点就先恢复线程，让它跑到安全点上，目前几乎没有      虚拟机采用抢先式终端的方式来响应GC事件。主动式中断就是当GC需要中断线程时，不直接操作线程，而是设置一个标志，各      个线程执行时主动去轮询这个标志，当发现中断标志为真时就自己挂起，而且只在安全点与创建对象分配内存的地方进行轮询      中断标志

    安全区域(Safepoint)：
	安全点可以解决线程运行过程如何进入GC的问题，但是还有一种情况，假如线程没分配到CPU时间呢，这种情况下GC等再久    线程也不会进入安全点，最典型的例子就是线程处理Sleep或者Blocked状态，此时线程就去不到中断点响应JVM的中断请求。
	此时就需要安全区域来解决了，安全区域是指这个区域中的任意地方都不会改变对象引用，在这个区域中进行GC是安全的     ，当线程执行到安全区域中的代码时，就标识自己进入了安全区域，当JVM发起GC时，就不会管标识了安全区域的线程，当线程     要离开安全区域时，就要先检查是否已经完成了根节点枚举或者整个GC过程已经结束，如果没完成就一直等待直到收到可以安      全离开安全区域的信号位为止
	那有哪些安全区域？Sleep和Blocked吗？

参数前缀的含义：
    -：标准参数，所有JVM都支持
    -X：非标准参数，基本都是控制JVM的属性
    -XX：非稳定参数，用来控制JVM的行为
    -D：系统参数

垃圾收集器：

    并行：多条垃圾收集线程并行工作，但用户现场依然处于等待状态
    并发：用户线程与垃圾收集器同时执行，但可能是交替执行，也可能是并行执行在不同的CPU上


    Serial(连续)新生代收集器：
	Serial收集器是一个单线程收集器，所以它只会用一个线程去完成垃圾收集工作，更重要的是，它在进行收集时，必须暂      停其它所有的工作线程，直到它收集结束。但是整个程序时不时停一段时间等待GC对很多应用来说是无法接受的
	但它也有自己的优势，比如虚拟机在Client模式，只有单个CPU的情况下，Serial由于没有线程交互的开销，专心做垃圾收     集器可以获得最高的单线程手机效率，所以在Client模式下依然是默认的新生代收集器
	-Xmn：新生代大小
	-XX:SurvivorRatio：Eden与Survivor区的比例， 默认为8，代表Eden:Survivor=8:1
	-XX:PretenureSizeThreshold：晋升老年代的大小，大于这个参数的对象直接在老年代分配，仅支持Serial和ParNew
	-XX:MaxTenuringThreshold：晋升到老年代的年龄，每次坚持过一次Minor GC后年龄+1，超过这个参数就会进入老年代
	-Xmx：设置最大堆
	-XX:UseSerialGC：虚拟机在Client模式下的默认值，打开后使用Serial + Serial Old组合进行内存回收


    ParNew(Parallel New，并发新生代)新生代收集器：
	ParNew收集器其实就是Serial收集器的多线程版本，除了多线程这点，其它所有控制参数，收集算法，Stop The World，      对象分配规则、回收策略等都与Serial收集器完全一样
	ParNew收集器是许多Server模式下虚拟机中首选的新生代收集器，因为只有它与Serial收集器能与CMS收集器同时进行工作
	-XX:+UseConcMarkSweepGC：使用CMS收集器，这种时候ParNew收集器就是默认的新生代收集器，还有Serial Old处理CMF
	-XX+UseParNewGC：指定ParNew + Serial Old作为收集器组合
	-XX:ParallelGCThreads：进行GC时使用的线程数，默认是与CPU数量相同


    Parallel Scavenge(并发清除)新生代收集器：
	使用复制算法，因此不会出现内存碎片，更加关注吞吐量，也就是GC时间和运行时间的比例，可以指定最长GC时间、指定     GC时间占用运行时间的比例、并且支持自动调节参数
	-XX:MaxGCPauseMillis：最大GC停顿时间，设置一个比0大的毫秒值，收集器会尽可能保证每次花费的时间不超过设定值。    ，设置太小会导致频繁GC
	-XX:GCTimeRatio：相当于吞吐量的倒数，默认为99，也就是默认为1/(1+99)的垃圾收集时间，支持1-99
	-XX:+UseAdaptiveSizePolicy：自适应参数的开关，开启后就不需要指定新生代的大小、Eden和Survivor的比例、晋升老
    年代的年龄等参数，虚拟机会根据系统的运行情况自动调节
	-XX:+UseParallelGC：使用Parallel Scavenge + Serial Old组合


    Serial Old(Serial收集器的老年代版本)老年代收集器：
	同样是一个单线程收集器，使用标记-整理算法


    Parallel Old(Parallel Scavenge的老年代版本)老年代收集器：
	使用多线程和标记-整理算法，可以配置Parallel Scavenge使用，在重视吞吐量的场合可以考虑
	-XX:+UseParallelOldGC：使用Parallel Scavenge + Paralel Old组合


    CMS(Concurrent Mark Sweep)老年代收集器：
	基于标记-清除算法实现的并发收集器，低停顿，注重响应速度
	CMS的目标是最短回收停顿时间，它包含4个步骤：
	    1、初始标记：Stop The World，仅仅标记一下GC Roots能直接关联到的对象
	    2、并发标记：可以和用户线程并发执行，进行GC RootsTracing(从根节点向下扫描)
	    3、重新标记：Stop The World，修正并发标记期间用户程序运行导致的标记变更的对象的标记记录
	    4：并发清除：可以和用户线程并发执行，对标记的对象进行清除
	缺陷：
	    1、CMS的默认回收线程是：(CPU数量+3)/4，当CPU数量少的时候，这可能会占去CPU一半的资源
	    2、无法处理浮动垃圾，也就是并发清除过程中，继续产生新的垃圾，这些垃圾在标记之后出现，CMS无法处理它们，		只能等下次GC，而且由于GC过程中用户线程还要运行，因此还要另外预留一部分内存给用户线程使用，这意味着在老年代		没满的时候就要进行GC了，如果此时老年代满了，就会出现Concurrent Mode Failure。现在默认是老年代占用达到92%就	    进行GC
	    3、由于是标记-清除算法，这会导致大量内存碎片
	Concurrent Mode Failure：CMS特有的错误，当进行第四步并发清除的时候，用户线程产生了新的垃圾放到老年代，此时      老年代放不下，CMS又没标记到新对象，无法进行收集，就会出现这个错误。当发生这个错误时，就会启用备用方案：临时启用     Serial Old收集器来重新进行老年代的垃圾收集
	-XX:CMSInitiatingOccupancyFraction：CMS收集器启动的老年代内存占用阈值，默认是92，太低容易频繁GC，太高又容       易出现Concurrent Mode Failure
	-XX:+UseCMSCompactAtFullCollection：CMS收集器进行FullGC时进行内存碎片的合并整理，此过程无法并发，默认开启
	-XX:CMSFullGCsBeforeCompaction：CMS进行多少次不压缩的FullGC后进行一次带压缩的，默认是0，既每次都整理


    G1(Garbage-First)新老年代整合收集器：
	特点：
	    1、并行与并发：G1能利用多CPU、多核的硬件优势，通过并发让Java程序在GC时继续执行
	    2、分代收集：G1能独自管理整个堆，而且它能采用不同的方式去处理新旧对象以获得更好的收集效果
	    3、空间整合：G1将整个堆分为多个区域(Region)，整体上来看是基于标记-整理算法，局部上来看基于标记-复制算法
	  ，这两种算法都意味着G1不会产生内存碎片，这有利于程序长时间运行
	    4、可预测的停顿：G1除了追求低停顿，还能让使用者明确指定在一个M毫秒的时间段内，消耗在垃圾收集上的时间不	    超过N毫秒
	细节：
	    其他收集器收集的范围都是整个新生代或老年代，而G1是将堆划分为多个大小相等的独立区域(Region)，虽然还保留		着新生代和老年代的概念，但他们不再是隔离的了，它们都是一部分Region(不需要连续)的集合
	    之所以G1能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个堆中进行全区域的垃圾收集。G1跟踪各个		Region里的垃圾堆积的价值大小(回收能获得的空间和回收所需的时间)，在后台维护一个优先列表，每次都优先收集价		值最大的Region，这也是Garbage-First名称的来由，这保证了G1收集器在有限的时间内可以获取尽可能高的收集效率
	    Region不是孤立的，因为一个对象分配在Region中，但是它可能在其它的Region引用或者被引用，在做可达性分析时		  岂不是还得扫面整个堆才能保证准确性？G1在不同的Region直接的对象引用时，会为每个Region维护一个Remembered 		Set，虚拟机发现引用类型的对象被写入时，就会判断是否处于不同Region中，如果是的话，就会将引用信息记录到引用		对象所属的Region的Remembered Set中。当进行内存回收时，通过扫描Remembered Set里的对象就可以避免全堆扫描
	    分代收集器的新生代跟老年代之间相互引用也是维护一个列表，进行GC时扫描这个列表里的对象就行了，不用将其它	  	  代的空间也扫描一遍
	步骤：
	    1、初始标记：Stop The World，仅标记一下GC Roots能关联到的对象
	    2、并发标记：与用户现场并发执行，进行可达性分析，找出存活的对象，并将这段时间用户程序导致记录标记的变动		记录在线程Rememberd Set Logs里
	    3、最终标记：停顿用户线程，将Rememberd Set Logs的变动整合到Remembered Set中
	    4、筛选回收：停顿用户线程，对各个Region的回收价值和成本进行排序，再根据用户期望的GC停顿时间制定回收计划
	结论：
	    如果追求低停顿，或者堆很大，那么G1是很好的选择，但是如果追求吞吐量，G1并不会带来特别的好处

GC日志：

    33.125：[GC[DefNew：3324K-＞152K（3712K），0.0025925 secs]3324K-＞152K（11904K），0.0031680 secs] 100.667：[FullGC[Tenured：0K-＞21 K（10240K），0.0149142secs]4603K-＞210K（19456K），[Perm：2999K-＞ 2999K（21248K）]，0.0150007 secs][Times：user=0.01 sys=0.00，real=0.02 secs]
    33.125：从JVM启动到发生GC时间的秒数
    GC：这里不是指GC类型，而是指停顿类型，FULL GC就是Stop The World，GC则不会
    DefNew：发生GC的区域，defNew：新生代，tenured：老年代，perm：永久代，不同收集器名称有点差异，但不会差太多
    3324K-＞152K（3712K）：GC前342K，GC后152K，发生CG的区域总空间3712K
    3324K-＞152K（11904K）：跟上一行相比，这里展示的是整个堆的
    0.0031680 secs：此次GC占用的时间，单位是秒；有的收集器会出现：[Times：user=0.01 sys=0.00，real=0.02 secs]
    [Times：user=0.01 sys=0.00，real=0.02 secs]：user代表用户消耗的CPU时间，sys代表内核消耗的CPU世界，real代表例如磁盘I/O、线程阻塞的耗时，如果是多核CPU，那么前两者可能会超过real的时间，因为多核运算的时间会叠加，同时计算多个核，叠加起来肯定比单线程的时间更多
    总结：以上共有3段GC信息，分别对3个区域进行GC，每段信息基本格式一致，参考书上面就行了



参数：
    -XX:+PrintGCDetails：在发生GC时打印内存回收日志，并在程序退出时输出当前内存各区域的分配情况





内存分配与回收：

    新生代GC(Minor GC、Young GC)：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕死的特性，所以Minor GC非常频繁，回收速度也比较快。一般都使用复制算法，因此不会存在内存碎片，存活对象过多就会放到老年代

    老年代GC(Major GC、Full GC)：指发生在老年代的GC，出现Major GC，经常会伴随至少一次的Minor GC，但并非绝对，在Parallel Scavenge收集器里就有直接进行Major GC的策略选择过程，一般Major GC速度会比Minor GC慢十倍以上

    Survivor区如果相同年龄的对象占的空间大于Surivor的一半，那么在下一次发生Minor GC时，大于等于该年龄的对象将会直接进入老年代，而非在Survivor的from和to区反复横跳

    如果进行Minor GC前发现老年代连续空间可能装不下此次所有对象(因为极端情况会所有对象都幸存)，就会先进行Full GC再Minor GC，如果配置了允许失败，那么只要老年代的空间大于历次的平均值就会冒险Minor GC，如果空间不够失败了再Full GC，具体判断流程参考：空间分配担保



JDK命令行工具：

    如果要监控运行中的程序，在程序启动时要添加参数：-Dcom.sun.management.jmxremote，开启JMX（Java 管理扩展）功能，否则由于部分工具是基于JMX的，将会无法使用。JDK1.6以上是默认开启的，启动时无需加参数


    jps(JVM Process Status Tool)：显示指定系统内所有的HotSpot虚拟机进程
	-q：只输出LVMID（Local Virtual Machine Identifier），本地虚拟机唯一ID，通常也是进程ID
	-m：输出虚拟机启动时传给主类main函数的参数
	-l：输出主类的全名，如果执行的是Jar包，输出Jar路径
	-v：输出虚拟机启动时的JVM参数


    jstat(JVM Statistics Monitoring Tool)用于收集HotSpot虚拟机各方面的运行数据，所有参数最后都要加进程id
	-class：监视类装载、卸载数量，总空间以及装载耗费时间
	-gc：监视堆状况，包括各个代与其各个区的容量，已用空间，GC时间等
	-gccapacity：基本与-gc相同，但主要输出各个堆区域使用到的最大、最小空间
	-gcutil：基本与-gc相同，但主要输出已使用空间占总空间的百分比
	-gccause：基本与-gc相同，但会额外输出导致上一次GC产生的原因
	-gcnew：监视新生代GC状况
	-gcnewcapacity：基本与-gcnew相同，但主要输出新生代使用到的最大、最小空间
	-gcold：监视老年代GC状况
	-gcoldcapacity：基本与-gcold相同，但主要输出老年代使用到的最大、最小空间
	-gcpremcapacity：输出永久代使用到的最大、最小空间
	-compiler：输出JIT编译器编译过的方法、耗时等信息
	-printcompilation：输出已被JIT编译的方法
	各参数含义（太多了，只列出-gc下的参数）：
	    S0C：年轻代中第一个survivor（幸存区）的容量 （字节）
	    
S1C：年轻代中第二个survivor（幸存区）的容量 (字节)

	    S0U ：年轻代中第一个survivor（幸存区）目前已使用空间 (字节)
	    S1U ：年轻代中第二个survivor（幸存区）目前已使用空间 (字节)

	    EC ：年轻代中Eden（伊甸园）的容量 (字节)
	    
EU ：年轻代中Eden（伊甸园）目前已使用空间 (字节)
	    
OC ：Old代的容量 (字节)

	    OU ：Old代目前已使用空间 (字节)

	    MC：metaspace(元空间)的容量 (字节)
	    
MU：metaspace(元空间)目前已使用空间 (字节)
	    
YGC ：从应用程序启动到采样时年轻代中gc次数

	    YGCT ：从应用程序启动到采样时年轻代中gc所用时间(s)
	    
FGC ：从应用程序启动到采样时old代(全gc)gc次数
	    
FGCT ：从应用程序启动到采样时old代(全gc)gc所用时间(s)
	    
GCT：从应用程序启动到采样时gc用的总时间(s)




    jinfo(Configuration Info For Java)：显示虚拟机配置信息，所有参数最后都要加进程id
	-flag <name>：输出指定虚拟机参数名称的值
	-flag ±<name>：启用或停用指定虚拟机参数，必须是支持的参数，那种自定义的参数无效
	-flags：显示所有的虚拟机参数
	-sysgroup：显示所有的系统属性
	无：打印所有的虚拟机参数与系统属性
	

    jmap(Memory Map For Java)：生成虚拟机的内存转储快照(heapdump文件)，所有参数最后都要加进程id
	-dump:[live,]format=b,file=<filename>：生成Java转储快照，dump后面的3个参数之间用逗号隔开，其中live为可选，        决定了是否只dump出存活的对象，format=b为固定，意思是二进制格式，file就是文件输出的位置
	-finalizerinfo：显示在F-Queue中等待Finalizer线程执行finalize方法的对象
	-heap：显示堆的详细信息，比如使用的收集器、收集器的参数、各个分区分代的使用情况
	-histo：显示堆中数量的统计，比如每个类的实力数量、合计占用空间
	-permstat(jdk1.8下是-clstats)：以ClassLoader为统计口径显示永久代的内存状态
	-F：当虚拟机进程对-dump选项没有相应时，可使用这个选项强制生成dump快照


    jhat(JVM Heap Dump Browser)：用于分许heapdump文件，它会建立一个HTTP服务器，让用户可以在浏览器上查看分析结果
	jhat <file>：直接解析指定的dump文件，然后提供一个服务器进行访问，执行指令后命令行会输出服务器所在的端口，由      于分析功能相对简陋，并且只支持在本机分析，所以一般不会用


    jstack(Stack Trace For Java)：生成虚拟机的线程快照，所有参数最后都要加进程id
	-F：当正常请求不被响应时，强制输出thread dump(线程堆栈）
	-l：除堆栈外，显示关于锁的附加信息
	-m：如果调用到本地方法的话，可以显示C/C++的堆栈


JDK可视化工具：

    JConsole：Java监视与管理控制台
	最重要的是两大块，分别是内存、线程，还有其它一些比如类、CUP、VM整体信息、MBean等
      内存：
	提供了一个时间线查看不同区域的内存占用变化，主要分为两大块：
	    堆内存：
		这部分一共有Eden、Survivor、old三块，记录了新、老年代在不同时间范围下的内存占用情况
	    非堆内存：
		这部分一共有元空间、代码缓存、类空间三块，记录了非堆的内存情况
	除此之外还可以查看不同内存区域当前的占用空间、最大可用空间；新生代、老年代收集器的GC总花费时间与总次数，          并且还能手动进行GC

        线程：
	  可以查看当前VM上的所有线程，并且可以看到每个线程的名称、堆栈跟踪与线程状态；还能检查死锁，并且也提供了一	个时间线查看活动线程的数量变化
	  所以线程起名与分组很重要，不然排查的时候都是Thread1、Thread2...，根本看不出来是哪个线程


    VisualVM：多合一故障处理工具
	主要也是内存与线程分析，可以对堆与线程的dump进行在线分析查看，并且生成离线堆、栈dump(只需选中dump另存为就行      了)；还支持许多插件，比如BTrace可以动态加入调试代码；还能对CPU与内存进行分析，可以分析哪些方法调用最频繁或者	      哪些对象占用最多
























