缓存：

缓存穿透：
    一直请求缓存和数据库里都没有的数据，导致数据库压力过大
    解决：如果查数据库查不到就把缓存的的值设置为null或空字符串，并且设置过期时间，如果查缓存的时候发现返回值是这个空字符串，就不会去查数据库了。设置过期时间是为了防止数据库里的值后来出现了还一直查缓存里的

缓存击穿：
    某个缓存突然过期，导致大量请求直接走到数据库访问，对数据库造成了巨大压力
    解决：设置永不过期，或者在查数据库之前先对key进行加锁，拿到锁后才去数据库里查询并更新缓存，拿不到锁的话就休眠一小段时间，等缓存差不多刷新了再查一遍缓存。尝试加锁可以用可重入锁的tryLock，马上返回true或false

缓存雪崩：
    大量缓存突然过期，并且查询量巨大，引起数据库压力过大
    解决：设置过期时间随机，设置热点数据永不过期

布隆过滤器：
    将key根据多个不同的hash算法转换成多个不同的hash，然后在一个足够大的byte数组里将这些hash下标置1，查询的时候再转换一遍判断这些hash的位置是否都是1，如果有任意一个为0则说明数据绝对不存在，如果全都为1则数据可能不存在，因为这些hash其它key也在用
    案例：发生缓存穿透的时候，先用布隆过滤器判断该key是否存在，如果不存在就不用去查库了，但是这样会因为误算造成有些不存在的key也会查库，因此还是用设置特定的value来判断是否查库比较稳
    优点：速度快，占用空间少
    缺点：会出现误算，并且不可删除
    用法：数组可用redis的string类型代替，它支持字节级别的操作
    降低误算概率：用几组不同的hash算法配几个数组，多重校验
    删除：布隆过滤器的hash加了就不可删除，因为该hash的位置可能也有其他key的，虽然可以每来一个新的key该hash位的byte就+1，但是根本无法判断该key是否已经加过了

跳跃表：
    在链表的基础上，为链表的每个节点加索引，本来只有next，加了索引后就多了L1，L1可能指向100个之后的元素，然后只要链表是有序的，在遍历链表的时候就可以判断只要查找的值比较大，每次都遍历L1，直到找到了接近的值再用next，还可以加L2，指向下1000个，只要需要可以无限加，其实就是空间换时间。在redis中的zset如果元素比较多或者成员是比较长的字符串就会用跳跃表来作为有序集合的实现

redis分布式锁：
    主要用setnx实现，这个指令是如果不存在则set，并返回true or false，只要能拿到锁并设置对应的锁id，就认为获取到锁了，还要设置锁过期时间。设置过期时间和设置锁必须在同一条指令上(有支持)，否则要是加了锁在设置过期时挂了那就凉凉
    释放锁的时候判断锁id跟传入的是否一样，一样才释放，并且释放和id判断应该用脚本写成同一条指令。因为如果判断了id一样，准备删除锁，这时刚好锁过期被其它线程获取到了锁，这时候再进行删除就会误删其他线程的锁

redis为什么单线程还这么快：
    因为redis的性能瓶颈从来都不是cpu，而是内存大小，一次内存操作的时间单位是以纳秒来计算的

redis过期策略：
	1、定时过期：每个设置过期时间的key都需要创建一个定时器，过期立即清除，会占用大量CPU资源去处理过其实据
	2、惰性过期：只有访问某个key时才会判断该key是否过期，极端情况下会出现大量过期key占用内存，节省CPU资源
	3、定期过期：每过一段时间都清理一定数量的key，通过扫描过期字典表里的数据，这个字典会保存所有设置了过期的key      和过期时间，这是个折中方案
	redis同时使用了惰性过期和定时过期

redis内存淘汰策略：
	1、noeviction：内存不足以容纳写入数据时，写入报错
	2、allkeys-lru：当内存不足以容易新写入数据时，移除最少使用的key
	3、allkeys-random：当内存不足以容纳新写入数据时，随机移除某个key
	4、volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的key里，移除最少使用的key
	5、volatile-random：当内存不足以容易新写入数据时，在设置了过期时间的key中随机移除某个key
	6、volatile-ttl：当内存不足以容纳新数据时，在设置了过期时间的key中，移除最早过期的key

redis应用场景：
    数据缓存
    分布式锁
    session共享
    请求限流
    产品秒杀

redis哨兵挂了咋办？
    哨兵集群，哨兵集群是哨兵直接连接到主库，就能通过主库获取其它哨兵的信息，自动进行集群。并且哨兵也是从主库获取到其它从库的信息的
    哨兵判断主库下线后，先通过哨兵集群进行选举一个leader，然后这个leader在对主从进行切换，且必须超过半票都选举同一哨兵才会成功，假如没有，就再进行下一轮投票

redis从库调用：
    redis配置好主从、哨兵后，直接连主库调用就行了，会自动调到从库


锁：

自旋锁：
    如果获取不到锁，则一直重复尝试获取锁，期间占用线程资源

互斥锁：
    获取不到锁则线程挂起，等锁释放后才进行唤醒，期间不占用线程资源，但是如果唤醒很快可能线程上下文切换的成本比自旋锁循环的成本还高

读写锁：
    读锁可以重复获取，写锁获取之后读锁跟写锁再获取会阻塞，直到写锁释放

乐观锁：
    不会锁资源，而是先改了再说，改了之后用版本号判断资源是有冲突

悲观锁：
    先锁资源再说，锁了再改，如果已被锁则阻塞，自旋锁、互斥锁、写锁、原子锁都是悲观锁

原子锁：
    对资源的操作为原子性


epoll和select：
    epoll和select都是I/O多路复用技术，都可以实时监听多个I/O事件的状态，但epoll是系统支持的I/O通知机制，select是轮询机制，因此epoll效率更高


什么是微服务
    微服务是一种架构模式，它提倡将单一的应用程序划分成一组小的服务，每个服务运行在自己独立的进程中

SpringCloud和Dubbo的区别：
    SpringCloud通信用的是http协议RESTFUL风格请求，Dubbo用的是RPC
    SpringCloud对分布式架构有一站式的解决方案，Dubbo则没那么全面

Ribbon负载均衡策略支持：
    1、轮询
    2、随机
    3、最大可用，过滤掉故障服务器后选一个请求数最少的
    4、根据响应时间做加权轮询

Ribbon和Feign的区别：
    1、Ribbon启动用的是@RibbonClient，Feign用的是@EnableFeignClients
    2、Ribbon实在@RibbonClient注解上声明服务，Feign在接口上使用@FeignClient声明

    Ribbon使用@RibboClients启动，用ioc加载一个RestTemplate来发起调用，调用时地址填服务名就行了，注解里可以填@RibbonClien数组，可以为每个服务配置不同的负载均衡，也可以在创建RestTemplae时在@Bean注解那里用@LoadBalanced来为Ribbon指定负载均衡
    Ribbon每30秒从Eureka服务获取一次服务注册信息，期间会在本地缓存一份

    Feign使用@EnableFeignClients注解启动，注解的value需要填一个包名，指定Feign接口的包路径，Feign会去扫描类上加了@FeignClient注解的，这个注解的value是指定这个Feign对应的服务名称，还能指定fallbackFactory来决定相关方法调用失败后去调用指定类的对应方法，这个类会返回一个实现了Feign接口的对象
    Feign整合了Ribbon和Hystrix，因此有负载均衡跟服务熔断能力

    Hystrix使用@EnableCircuitBreaker注解启动，启动后可以在对应方法上加@HystrixCommand注解，指定fallbackMethod属性来指定一个本类的方法名，当该方法调用失败后就会调用fallbackMethod指定的方法进行返回，它的作用是快速失败，防止服务雪崩
Hystrix Dashboard可以监控依赖了spring-boot-starter-actuator包的服务，加了spring-cloud-starter-hystrix包后使用@EnableHystrixDashboard注解启动，在仪表盘服务地址加上/hystrix就能查看了
    提供线程池，不同的服务使用不停的线程池，实现了不同服务调用隔离，避免了服务雪崩
    断路器有三个状态
	1、全开：一段时间内达到一定错误次数就会让请求直接失败
	2、半开：断路器会将部分请求发给该服务判断是否能正常调用，如果能正常调用就关闭断路器
	3、关闭：当服务一直正常时，断路器就是关闭状态

    服务熔断是被动的，服务出现多次异常自动返回预设的错误信息，服务降级是主动的，客户端直接返回预设的错误消息，不调用服务，熔断可以配置失败频率到一定的程度就不再调用服务，过一段时间后再重新尝试，次数、频率和尝试间隔时间都是可配置的，也可以熔断后进行降级，只要在调用者处，比如@FeignClient指定fallbackFactory就可以了
    两种降级方式：@HystrixCommand和@FeignClient里写fallbackFactory

    SpringCloudConfig启动需要Config服务导spring-cloud-config-server包，然后用@EnableConfigServer注解启动
SpringCloudConfig是与Eureka无关的，无需注册到Eureka，如果需要高可用就注册到eureka，只需要在服务里填写spring.cloud.config.uri=config服务的地址，.profile=环境，.label=分支就行了，请求文件的规则就是：服务名/环境.yml或propertity

    Eureka自我保护机制：Eureka服务节点在短时间内与过多服务失去连接，节点就会进入自我保护模式，不再删除注册的数据，并且依然能注册新服务，当故障恢复时，自动退出自我保护模式

    Eureka不会马上剔除关闭的服务，因为它会过一段时间(60S)检测一次服务心跳，如果检测到服务已经有90S没有心跳，就会剔除，服务每30S发送一次心跳，这几个数值都是可配置的

    调用流程：nginx->zuul->服务提供者


分库分表技术：
    客户端分库分表：ShardingJDBC，服务端代理分库分表：MyCat

分库分表下产生的join、分页、事务的问题

雪花算法：
    分布式id生成算法，由64位bit二进制组成，第1位bit不用，代表整数，其后41位bit作为毫秒数，再后10位bit作为机器id，最后12位bit作为序列号
    也就是同一毫秒内每台机器最多能生成2^12-1位id，并且可以挤压机器id的空间来进行扩大
    由于是依据41位毫秒数来生成的，因此系统时间错误可能会造成id冲突，并且是同一机器才会出现时间回调id冲突

zookeeper选举：
    1、先选举自己为leader
    2、广播投票信息、等待其它节点投票信息
    3、收到的节点投票信息是否轮次比自己新，且编号比自己大，如果是则更新投票信息
    4、2-3步骤一直循环，直到有节点获得一半以上选票
    5、如果获得一半以上选票的是自己则把自己设置为leader，且广播

dubbo支持的协议：
    dubbo、rmi、hessian、http、http REST、web service、redis

dubbo序列化：
    dubbo默认序列化为hessian2，rmi默认为java序列化，http默认为json

缓存更新：
    更新数据库时更新缓存可用先改库后删缓存，因为如果先改库再改缓存会导致改库之后数据又被改了，这时候改缓存就是脏数据了
。
    如果是有主从数据库，应该改了之后先延迟，等从库读到了再删，因为改了之后马上删缓存，这时候其他请求读缓存读不到去更新，由于读的从库，可能是旧数据

类的加载过程：
    加载-连接(验证-准备-解析)-初始化-使用-卸载

怎么判断链表是否有回环：
    判断链表回环，两个指针，一个每次走一步，一个每次走两步，如果两步的走到null就是没回环，如果两步的等于一步的就是有回环，因为如果有回环，两步的始终会追上一步的

死锁产生的四个条件：
    
1、互斥条件：一个资源每次只能被一个线程/进程使用
    
2、请求与保持条件：一个线程/进程因请求资源而阻塞时，对已获得的资源保持锁定

    3、不剥夺条件：已获得的资源，未使用完之前不能强行剥夺
    
4、循环等待条件：若干线程/进程之间形成一种头尾详解的循环等待资源关系

dubbo服务挂了zk怎么知道并剔除服务的：
    dubbo注册的是临时节点，一旦客户端不活跃，该节点就会被移除

保证线程的顺序执行：
    
1、对线程对象使用join，这样当前线程就会等join的线程执行完才会执行

    2、使用线程池，核心池容量和最大容量都设置为1，这样每次就只会执行一个线程，并且阻塞队列还能保住顺序

ThreadLocal实现原理：
    它是由每个线程都有的一个ThreadLocal.ThreadLocalMap对象来存储的，这个ThreadLocalMap存储了一个动态的Entry数组，每个Entry都存储了一个key(ThreadLocal)，value(threadLocalValue)，ThreadLocalMap在第一次使用ThreadLocal.set创建，所以一个线程有一个ThreadLocalMap，每个Map保存多个Entry，每个Entry包含ThreadLocal和value，Entry继承了WeakReference，是弱引用，在发生gc时就会被回收

RocketMQ怎么保证全局消息顺序：
    Rocketmq消息要保证全局顺序就只能使用一个消费者一个提供者一个Topic一个队列，Topic默认队列数是16。如果只要保证部分顺序，可以指定sharding key进行分区，每个分区内的消息都能保证顺序

hash和btree索引的使用场景：
    我回答是hash适用数据量少，BTree适用于数据量多，因为hash如果数据量多起来，产生大量hash碰撞肯定影响性能

histrix的线程池模型：
    histrix维护了很多线程池来调用不同服务，具体实现我也不知道

怎么实现每秒接口只处理10个请求：
   当时脑子转不过来老是想着用线程池的方式来实现，时间限制方面无法处理。以下是后面网上查的思路：一个队列保存每个执行任务的时间戳，来了新的任务就先清理队列里超过1秒的元素，然后判断队列是否小于10，如果是就执行，不然就返回，这个队列如果用的是redis的zset就是一种简单的服务器访问限流方式

ioc中bean初始化流程：
    根据Ioc、Aop原理回答，大概就是创建ApplicationContext，创建BeanFactory，加载BeanDefinition，创建Bean，如果有依赖的Bean就先创建依赖的Bean，然后各种后置处理器(Aop就是在这里实现的)，初始化方法，再到各种Aware，比如ApplicationContextAware

缓存的使用场景：
    我说了全国区域信息，客户商品信息，字典

线程池的限制：
    核心池数、最大工作线程数和阻塞队列上限

数据库1亿数据同步到缓存，同步期间一直有数据插入，5台8g内存机器，怎么处理：
    先用canal进行mysql的主从复制，保证了新数据的同步，再用增量迁移给每个机器分配五分之一的旧数据进行迁移

线上的数据库有个字段类型需要修改，怎么保证服务可用的情况下进行字段修改：
    建一个新类型的库，用canal进行主从，把数据转移到从库，然后将服务一个个改为写入从库，从库改主库，面试官好像想听到另外的思路

线程池的几种创建方式：
    我说了ThreadPoolService和Excutors，并说了Excutors不推荐使用的原因

double为什么会出现精度丢失？bigdecimal怎么保证的数据计算精度？bigdecimal真的能绝对保证精度不丢失吗？
    不了解

JVM连环追问：
    Java内存模型是怎样的？哪些区域是线程共享的？堆分哪些区？新生代分哪些区？为什么这么分？新生代用哪些垃圾收集算法？老年代呢？你知道哪些垃圾收集器(到这里我就不会了)？

秒杀场景怎么优化：
    我也不了解，说了缓存跟加机器做负载均衡，面试官看起来不太满意

xss攻击：
    我也不了解

HashMap,HashTable,ConcurrentHashMap之间的区别,他们之间1.7跟1.8有哪些不同：
    HashMap是线程不安全，HashTable是线程安全，ConcurrentHashMap是并发且线程安全
    1.7下的HashMap是数组+链表，ConcurrentHashMap是分段锁
    1.8下的HashMap是数组+链表红黑树，ConcurrentHashMap是CAS

JDK1.8下HashMap红黑树排序问题：
    HashMapJDK1.8的实现是数组+链表+红黑树，红黑树是有序的，如果key没有实现比较器，那红黑树结构下的hash碰撞怎么排序：将key传入System.identityHashCode返回的HashCode的结果进行排序

JDK1.8下的ConcurrentHashMap怎么保证cas的原子性：
    我也不知道

HashMap出现hash冲突是用头插法吗，1.7个1.8有什么不同，头插法会出什么问题吗：
    1.7是头插法，1.8我不清楚，头插法出现什么问题也不清楚

HashMap具体是怎么进行扩容的：
    第一次会扩到比当前容量大的最小2的次方(比如初始容量是13，扩容后就是16)，之后每次put数据量到了总容量*负载因子之后每次容量*2。每次扩容后会创建一个新的数组，旧的数组里每个值都要重新计算hash，然后放入新数组里

ArrayList跟LinkendList的区别：
    其实就是数组跟列表的区别，分析一下各自的优劣势就行了

你们分布式事务怎么解决的：
    答seata，之后必问seata实现机制

mvc执行流程：
    映射得到handle、handle适配器执行handle得到ModleAndView，视图解析器解析得到View，视图渲染器渲染View

怎么实现用户停留在一个页面10s积分＋1：
    我也不知道怎么防止客户端获取用户token后进行恶意操作

最常用的设计模式：
    我说了观察者，并说了使用场景，常用的模式肯定都要懂

什么场景下使用wait的：
    我说了不再需要对资源加锁，wait会释放锁

BeanFactory跟FactoryBean：
    BeanFactory负责创建管理Bean，FactoryBean是一个接口，是对Bean的封装，是一类特殊的bean

用户下单后订单需要3天后不支付自动取消，怎么实现：
    mq发延迟消息，延迟3天后如果订单状态还是未支付就取消

接上个问题，怎么修改订单的失效时间，比如本来3天过期，又改成5天，并且随时可改：
    数据库存储每条未支付的订单和过期时间，开一个定时任务去查过期时间比当前时间小的数据，然后判断支付状态去进行取消，给过期时间加索引可使索引类型达到range，性能也可以保证(当时老想着在mq的基础上扩展，时间仓促加上面试时思路很差根本不适合思考问题，竟然没想出来)

怎么保证缓存和数据库的一致性
    我答了分布式环境下不存在绝对一致性，除非牺牲可用性或者分区容错性，就跟zookeeper选举期间不可用一样，一般情况只要保证最终一致性

工厂模式和抽象工厂的区别：
    抽象工厂我忘记了，当时没答出来(抽象工厂就是生产工厂的工厂)

bean的创建时机：
    容器刷新时会创建当时所有注册了BeanDefinition且非懒加载非原型的bean，创建一个bean时会先创建它所依赖的所有bean，剩余的懒加载、原型bean跟容器刷新后才注册BeanDefinition的bean会在第一次get时创建。
    如果new了一个容器，并且构造器制定了配置(配置文件或者配置类)，容器就会在new时刷新，否则就要手动调用容器的refresh方法进行手动刷新，如果不刷新直接尝试getBean就会抛出容器未刷新异常

频繁出现的问题总结：
    Ioc、Aop、MVC、Boot原理
    常用设计模式
    缓存的使用场景，穿透、击穿、雪崩、布隆过滤器都要知道
    注册中心机制，比如zk的选举，eureka的续租
    Dubbo的各种协议、序列化，这个背一下就行了，不会深问
    HashMap(1.7、1.8)、HashTable、ConcurrentHashMap(1.7、1.8)、同系列Set、ArrayList、LinkedList之间的原理和差异(Set系列很多都是在内部new了一个同种类的型Map来用，比如HashSet内部new了一个HashMap)
    MQ使用场景也经常问，不过一般只问使用场景，最难的也就问了怎么保证消息顺序
    各种场景题
    

    














