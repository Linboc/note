createFilterChain：
	1、创建一个ApplicationFilterChain对象
	2、获取Context容器中所有的FilterMap
	3、使用请求的url去匹配所有的FilterMap，把所有能匹配上的FilterConfig都加入filterChain中
	    1、url为null直接返回false
	    2、filter的URLPattern为null也返回false
	    3、如果url.equals(URLPattern)为true就返回true
	    4、如果URLPattern等于/*就直接返回true
	    5、如果URLPattern以/*结尾，就用url的每个/前的路径加/*去用equals匹配，如果某次相等就返回true
	    6、如果URLPattern是以*.开头，就用*.加url最后一个.之后的字符用equals匹配，如果成功就返回true
	    7、否则返回false
	4、用servletName去匹配所有的filterMap，如果filterMap的servletName属性等于当前这个StandardWrapper的servletName
	    就把这个filterConfig也加入到filterChain中
	5、返回filterChain

	然后如果servlet和filterChain都不为null,就执行filterChain的doFilter方法，这个方法会用迭代器调用filterChain里
每一个filterConfig，然后获取到filterConfig里的filter对象，再调用这个对象的doFilter方法，会把req和resp跟filterChain
传进去，然后filter每次调用filterChain对象的doFilter方法都会持续的让它的filterConfig迭代器一直迭代下一个filter，直到
所有的filterConfig都迭代完，如果继续调用就会调用servlet的service方法

	执行完所有的doFilter()和service()方法之后，就调用filterChain.release()方法对filterChain里的属性进行清除
	
	再然后就是StandardWrapper对servlet进行回收了，如果是普通的servlet，就直接把总分配servle数目-1就行了，如果
是STM servlet，除了对总分配servle数目-1，还要把servlet放回servlet池instancePool属性中，并唤醒线程，以便让没有分配
到servlet的请求继续获取servlet

	StandardContex只能添加FilterDef对象，这个对象定义了filter的类，和名称等信息，在StandardContext启动和reload
的时候，它会把这些FilterDef实例化成ApplicationFilterConfig对象，这个对象只需要一个Context容器和一个FilterDef对象就
能实例化，并且在实例化时会把FilterDef里的filter类实例化出来

	而FilterMap则是表示了在配置文件中对于Filter标签的定义，包含了filterClass、servletClass、urlPattern等属性

StandardContext：
	
	








