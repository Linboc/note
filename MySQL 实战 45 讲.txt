
mysql基本架构：

    客户端
        ↓
    /**** Server层 ↓ ****/
    连接器                                   
        ↓                                       ↘
    分析器：词法分析，语法分析   →    查询缓存：命中则直接返回结果(连接器与分析器都会查询缓存)
        ↓
    优化器：执行计划生成，索引选择
        ↓
    执行器：操作引擎，返回结果
    /**** Server层 ↑ ****/
        ↓
    存储引擎：存放数据，提供读写接口，支持InnoDB、MyISAM、Memory等



连接器：
    任何数据库操作的第一步，都会先连接到数据库上，这个时候接待的就是连接器。连接器负责跟客户端建立连接、获取权限
、维持和管理连接。

    一般的连接命令如下：mysql -h$ip -P$port -u$user -P，然后输入密码即可。如果用户名或密码不对，就会收到一个
Access denied for user错误，然后客户端程序结束。如果认证通过，连接器会到权限表里查出该用户拥有的权限，之后这个连
接里面的权限判断逻辑都将依赖于此时读到的权限。这意味着一个用户成功建立连接后，即使修改了权限，也不会影响已存在
连接的权限，只有新的连接才会使用新的权限设置

    连接完成后，如果没有后续的动作，这个连接就处于空闲状态，可以在show processlist命令中看到它，其中command列
为的值Sleep就代表空闲连接。如果客户端太长时间没动静，连接器就会自动将它断开，这个时间由wait_timeout控制，默认
8小时。这时候如果连接再发送请求就会收到错误提示：Lost connection to MySQL server during query。此时就需要重新
建立连接再执行请求了

    数据库里面，长连接是指建立成功后，如果客户端有持续请求，则一直使用同一个连接。短连接是指每次执行完很少几次查
询就断开连接，下次查询再重新建立一个。由于连接的建立过程比较复杂，因此建议尽量减少建立连接的动作，也就是尽量使
用长连接
    但是全部使用长连接后，可能有时候MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在
连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接积累下来，可能会因为内存占用太大而被系统强行杀
掉(OOM)，这种现象看起来就像是MySQL异常重启了
    要解决这个问题可以考虑两种方案：
        1、定期断开长连接，或者每执行一个占用内存的大查询后，就断开连接，需要时再重连
        2、MySQL 5.7以上版本，可以在每次执行一个比较大的操作后，执行mysql_reset_connection来重新初始化连接资源。
    这个过程不需要重连和重新认证，但是会将连接恢复到刚创建完时的状态


查询缓存：
    MySQL拿到一个查询请求后，会先到查询缓存看看是不是执行过这条语句。之前执行过的查询与结果可能会以key-value
的形式被缓存在内存中。key是查询语句，value是查询结果。如果key能匹配就会直接返回value
    如果语句不再查询缓存中，就会执行后面的阶段。执行完成后再将结果放入查询缓存中。所以如果命中缓存，直接返回结果
效率就会很高。

    但是大多数情况下都不建议用缓存，因为缓存的失效非常频繁，只要有对一个表的更新，这个表的所有查询都会被清空。对
于更新压力大的数据库来说，缓存的命中率会非常低。除非业务是一张静态表才适合使用查询缓存
    MySQL也提供了按需使用的方式。将query_cache_type设置成DEMAND就是默认不使用查询缓存。如果使用查询缓存就可
以在SELECT后面增加SQL_CACHE来显式指定

    需要注意的是MySQL 8.0之后查询缓存功能已经删掉了

分析器：
    如果没有命中查询缓存，就要真正开始执行语句了，因此需要对SQL语句做解析。
    分析器会先做词法分析。输入的是一串SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。例如SELECT * 
FROM T WHERE id=1，从SELECT关键字里可以识别出来这是一个查询语句，将T识别为表名，将id识别为列id。
    识别完词法后就要做语法分析，语法分析器会根据语法规则，判断输入的这个SQL语句是否满足MySQL的语法。如果语句不
对，就会收到You have an error in your SQL syntax的错误提醒

优化器：
    经过了分析器，MySQL就知道要做什么了。在开始执行之前，还要经过优化器的处理。
    优化器是在表里有多个索引的时候，决定使用哪个索引；或者在一个语句有多张表的时候，据欸的那个各个表的连接顺序。

执行器：
    MySQL通过分析器知道了要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。
    开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误。如果有权限，
执行器就会根据表的引擎定义，去使用这个引擎提供的接口。然后调用InnoDB引擎接口去扫表或者铜鼓索引去获取表中对应
的行，满足条件则加入结果集，不是则跳过，然后取下一行重复相同的判断，直到最后一行，然后执行器将所有满足条件的行
组成的记录集作为结果集返回给客户端。
    数据库的慢查询日志中可以看到一个rows_examined的字段，表示这个语句执行过程中扫描了多少行，这个行就是在执行器
每次调用引擎获取数据行的时候累加的。有时候执行器调用一次，在引擎内部扫描了多行，因此引擎扫描行数跟rows_examined
并不是完全相同的


MySQL的记录更新：
    MySQL如果每次更新操作都需要写进磁盘，然后磁盘也要找到对应的记录，然后再更新，整个过程IO、查找成本都很高。
    为了解决这个问题，MySQL的设计者就用了WAL技术来提升更新效率，WAL全程是Write Ahead Logging，它的关键点
就是先写日志，再写磁盘。当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里，并更新内存。同时，
InnoDB引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做
    如果redo log不多，MySQL可以等空闲时再将其更新到磁盘，如果redo log特别多，并且写满了，那MySQL只能先将一部
分redo log更新到磁盘中，然后将这些记录从日志中清掉，为后面的新日志腾出空间

    InnoDB引擎层的redo log(重做日志)是一组文件，比如是4个文件，每个文件1GB，那么redo log一共可以记录4GB的操作，
从头开始写，写到末尾就回到开头循环写。InnoDB记录了两个位置，其中write pos是当前记录的位置，一边写一边后移，写
到最后一个文件就回到第一个文件开头；checkpoint是当前要擦除的位置，也是往后推移并且循环的，在擦除前要把对应的记
录更新到表文件，更新后才能将checkpoint后移
    而write pos和checkpoint之间就是redo log还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint就表示
redo log满了，这时候不能再执行新的更新操作，得停下来将checkpoint推进一下
    有了redo log后，InnoDB就可以保证即使数据库发生重启，之前提交的记录都不会丢失，这个能力称为crash-safe
    redo log记录的是这个页做了什么，比如id=2的行c字段+2

redo log的落盘：
    事务提交会将日志写入log buffer中，然后的落盘机制通过innodb_flush_log_at_trx_commit参数来控制，有三个值：
        0：每秒写入一次os buffer，并调用fsync()刷盘
        1：每次都写入os buffer，并调用fsync()刷盘
        2：每次都写入os buffer，每秒调用一次fsync()刷盘

    server层的binlog(归档日志)，上面讲的redo log是InnoDB引擎特有的，而binlog是MySQL的server层实现，所有引擎都可
以使用。binlog是追加写入的，binlog文件写到一定大小后会切换到下一个，并不会像redo log那样覆盖以前的日志
    binlog的记录有两种模式，原始sql与row格式，row格式会记录更新前与更新后的值

    binlog的落盘：
        sync_binlog的值表示每写缓存多少次就同步到磁盘，1表示每次都写入

    了解了以上的概念之后，然后就是update语句执行的内部流程：
        1、执行器先通过引擎找到id=2这行。由于id是主键，引擎直接用树搜索找到这一行。如果这一行所在的数据页本来就在
    内存中，就直接返回给执行器；否则就先从磁盘读入内存，然后再返回
        2、执行器拿到引擎给的行数据，把这个值加上1，得到新的行数据，再调用引擎接口写入这行新数据
        3、引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log中，此时redo log处于prepare状态。然后告知
    执行器执行完成了，随时可以提交事务
        4、执行器生成这个操作的binlog，并将binlog刷盘
        5、执行器调用引擎的提交事务接口，将刚刚写入的redo log改成commit状态，update语句结束
        补充：上面这个流程如果在binlog刷盘后出现断电，数据就会不一致了，因此MySQL重启后恢复会检查redo log是否处于
    prepare阶段，如果是的话就检查binlog是否完整，通过commit的时候写入到redo log中的XID来到binlog中进行匹配，如
    果能匹配则自动进行commit，否则就(撤销redo log的记录还是将数据补充到binlog?)
        这就是二阶段提交，先prepare再commit，二阶段提交是跨系统维持数据逻辑一致性常用的一个方案







