
mysql基本架构：

    客户端
        ↓
    /**** Server层 ↓ ****/
    连接器                                   
        ↓                                       ↘
    分析器：词法分析，语法分析   →    查询缓存：命中则直接返回结果(连接器与分析器都会查询缓存)
        ↓
    优化器：执行计划生成，索引选择
        ↓
    执行器：操作引擎，返回结果
    /**** Server层 ↑ ****/
        ↓
    存储引擎：存放数据，提供读写接口，支持InnoDB、MyISAM、Memory等



连接器：
    任何数据库操作的第一步，都会先连接到数据库上，这个时候接待的就是连接器。连接器负责跟客户端建立连接、获取权限
、维持和管理连接。

    一般的连接命令如下：mysql -h$ip -P$port -u$user -P，然后输入密码即可。如果用户名或密码不对，就会收到一个
Access denied for user错误，然后客户端程序结束。如果认证通过，连接器会到权限表里查出该用户拥有的权限，之后这个连
接里面的权限判断逻辑都将依赖于此时读到的权限。这意味着一个用户成功建立连接后，即使修改了权限，也不会影响已存在
连接的权限，只有新的连接才会使用新的权限设置

    连接完成后，如果没有后续的动作，这个连接就处于空闲状态，可以在show processlist命令中看到它，其中command列
为的值Sleep就代表空闲连接。如果客户端太长时间没动静，连接器就会自动将它断开，这个时间由wait_timeout控制，默认
8小时。这时候如果连接再发送请求就会收到错误提示：Lost connection to MySQL server during query。此时就需要重新
建立连接再执行请求了

    数据库里面，长连接是指建立成功后，如果客户端有持续请求，则一直使用同一个连接。短连接是指每次执行完很少几次查
询就断开连接，下次查询再重新建立一个。由于连接的建立过程比较复杂，因此建议尽量减少建立连接的动作，也就是尽量使
用长连接
    但是全部使用长连接后，可能有时候MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在
连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接积累下来，可能会因为内存占用太大而被系统强行杀
掉(OOM)，这种现象看起来就像是MySQL异常重启了
    要解决这个问题可以考虑两种方案：
        1、定期断开长连接，或者每执行一个占用内存的大查询后，就断开连接，需要时再重连
        2、MySQL 5.7以上版本，可以在每次执行一个比较大的操作后，执行mysql_reset_connection来重新初始化连接资源。
    这个过程不需要重连和重新认证，但是会将连接恢复到刚创建完时的状态


查询缓存：
    MySQL拿到一个查询请求后，会先到查询缓存看看是不是执行过这条语句。之前执行过的查询与结果可能会以key-value
的形式被缓存在内存中。key是查询语句，value是查询结果。如果key能匹配就会直接返回value
    如果语句不再查询缓存中，就会执行后面的阶段。执行完成后再将结果放入查询缓存中。所以如果命中缓存，直接返回结果
效率就会很高。

    但是大多数情况下都不建议用缓存，因为缓存的失效非常频繁，只要有对一个表的更新，这个表的所有查询都会被清空。对
于更新压力大的数据库来说，缓存的命中率会非常低。除非业务是一张静态表才适合使用查询缓存
    MySQL也提供了按需使用的方式。将query_cache_type设置成DEMAND就是默认不适用查询缓存。如果使用查询缓存就可
以在SELECT后面增加SQL_CACHE来显式指定

    需要注意的是MySQL 8.0之后查询缓存功能已经删掉了


分析器：

    














