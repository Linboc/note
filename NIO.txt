
BIO(同步阻塞)：
        BIO就是每个请求都启动一个线程/线程池去执行，如果没有请求就阻塞等待请求

NIO(同步非阻塞IO)：
        通过一个线程去查询一批有事件的channel，然后每个请求启用一个线程/线程池去处理
        因为数据并不一定时刻有交互，因此只有触发事件时才会处理，就不会一个请求死占着一个线程
        每个请求对应一个channel，多个channnel对应一个selector，selector可以去轮训看看有没有发生感兴趣的事件(事件可以用注册的方式添加)，如果有，就能拿到一个SelectionKey列表，SelectionKey里面封装了请求和事件类型，然后就遍历每个key，拿到key对应的channel，然后读或写buffer，启动线程/线程池根据不同的事件去执行不同的逻辑

AIO(异步非阻塞IO)：
        读数据和写数据都交给操作系统来做，中间通过一个Buffer来交互，系统读好了就会传个Buffer过来，数据准备好放在Buffer里面让系统去写。数据准备好后由操作系统来调接口，期间不需要轮询，因此是异步


以下3种都是NIO，只不过有不同 程度的优化，其中AIO指的就是epoll：
    select：
        select相比普通的同步阻塞I/O的优势在于不用在I/O阻塞的时候还一直去read，read需要从用户态切换到内核态，频繁切
    换会造成大量开销。它只用一个线程去遍历有哪些文件描述符已经就绪，然后去读取对应就绪的文件描述符的socket就行了
    。遍历也不是一直开死循环去查，这会占用大量CPU，而是操作系统网卡收到数据包后，通知发送中断信号给CPU，CPU会
    响应这个中断信号，去唤醒数据包对应的进程，进程才会对文件描述符进行遍历，否则会一直挂起直到超时

    poll：
        poll相比于select，select监听文件描述符，是传一个数组进去，然后返回的函数会修改这个数组，将监听的并且就绪的文
    件描述符的位置置为1，这样就需要不断创建新的数组传进去，由于监听的文件描述符很少会变动，因此这是不必要的开销。
    因此poll就是将监听的文件描述符与就绪的文件描述符分开，不再需要每次都重置监听的文件描述符，第二点是select监听的
    文件描述符是个数组，它的限制默认是1024，如果要修改很麻烦，而poll将其改成了链表，因此没有了1024的监听限制

    epoll：
        epoll就不再需要每次将要监听的文件描述符拷贝到内核态了，而是有事件就绪后，操作系统会将事件放入一个就绪链表中
    ，只要一直从这个链表中读取事件就可以了







